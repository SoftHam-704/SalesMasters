/******************************************************************************/
/****        Generated by IBExpert 2024.1.22.1 13/12/2025 08:39:19         ****/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES WIN1252;

SET CLIENTLIB 'C:\Program Files (x86)\Firebird\Firebird_5_0\fbclient.dll';

CREATE DATABASE 'LOCALHOST/3070:C:\SalesMasters\Dados50\Nova\BASESALES.FDB'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 16384
DEFAULT CHARACTER SET WIN1252 COLLATION WIN_PTBR;



/******************************************************************************/
/****                              Generators                              ****/
/******************************************************************************/

CREATE GENERATOR GEN_AGENDA_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_AGENDA_ID TO 16161;

CREATE GENERATOR GEN_AREA_ATU_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_AREA_ATU_ID TO 66;

CREATE GENERATOR GEN_BANDEIRA_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_BANDEIRA_ID TO 0;

CREATE GENERATOR GEN_CAD_PROD_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CAD_PROD_ID TO 73881;

CREATE GENERATOR GEN_CAIXA_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CAIXA_ID TO 0;

CREATE GENERATOR GEN_CCUSTOS_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CCUSTOS_ID TO 0;

CREATE GENERATOR GEN_CLIENTES_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CLIENTES_ID TO 666;

CREATE GENERATOR GEN_CLI_ANIV_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CLI_ANIV_ID TO 871;

CREATE GENERATOR GEN_CLI_IND_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CLI_IND_ID TO 301;

CREATE GENERATOR GEN_CONTASPGREC_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CONTASPGREC_ID TO 1421;

CREATE GENERATOR GEN_CONTAS_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CONTAS_ID TO 44;

CREATE GENERATOR GEN_CONTATO_FOR_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CONTATO_FOR_ID TO 107;

CREATE GENERATOR GEN_CRED_DEV_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CRED_DEV_ID TO 224;

CREATE GENERATOR GEN_CRM_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CRM_ID TO 671;

CREATE GENERATOR GEN_CRM_INTERACOES_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CRM_INTERACOES_ID TO 16162;

CREATE GENERATOR GEN_CURVAABC_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_CURVAABC_ID TO 0;

CREATE GENERATOR GEN_DESCONTOS_IND_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_DESCONTOS_IND_ID TO 0;

CREATE GENERATOR GEN_FATURA_PED_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_FATURA_PED_ID TO 5;

CREATE GENERATOR GEN_FORMA_PAGAMENTO_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_FORMA_PAGAMENTO_ID TO 0;

CREATE GENERATOR GEN_FORNECEDORES_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_FORNECEDORES_ID TO 63;

CREATE GENERATOR GEN_FRACRECEBIMENTOS_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_FRACRECEBIMENTOS_ID TO 0;

CREATE GENERATOR GEN_GRUPOS_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_GRUPOS_ID TO 148;

CREATE GENERATOR GEN_GRUPO_DESC_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_GRUPO_DESC_ID TO 82;

CREATE GENERATOR GEN_ITENS_PED_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_ITENS_PED_ID TO 939689;

CREATE GENERATOR GEN_LOTE_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_LOTE_ID TO 0;

CREATE GENERATOR GEN_PARAMETROS_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_PARAMETROS_ID TO 3;

CREATE GENERATOR GEN_PEDIDOS_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_PEDIDOS_ID TO 905258;

CREATE GENERATOR GEN_PRODUTOS_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_PRODUTOS_ID TO 637034;

CREATE GENERATOR GEN_REGIOES_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_REGIOES_ID TO 12;

CREATE GENERATOR GEN_RGBCORES_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_RGBCORES_ID TO 10;

CREATE GENERATOR GEN_SALDO_PGREC_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_SALDO_PGREC_ID TO 0;

CREATE GENERATOR GEN_TABELAS_PRECO_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_TABELAS_PRECO_ID TO 0;

CREATE GENERATOR GEN_TELEMKT_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_TELEMKT_ID TO 670;

CREATE GENERATOR GEN_TRANSPORTADORA_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_TRANSPORTADORA_ID TO 122;

CREATE GENERATOR GEN_USER_NOMES_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_USER_NOMES_ID TO 10;

CREATE GENERATOR GEN_VENDEDORES_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR GEN_VENDEDORES_ID TO 17;

CREATE GENERATOR REPL_ITENS_GEN_ID START WITH 1 INCREMENT BY 1;
SET GENERATOR REPL_ITENS_GEN_ID TO 2422349;



/******************************************************************************/
/****                              Exceptions                              ****/
/******************************************************************************/

CREATE EXCEPTION EX_INVALID_INPUT 'Parâmetro IFOR (indústria) obrigatório';



/******************************************************************************/
/****                          Stored procedures                           ****/
/******************************************************************************/



SET TERM ^ ;

CREATE PROCEDURE EXCLUIRRECEB (
    VNUMLANCTO INTEGER,
    VUSARECEB VARCHAR(1))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE MOVCAIXA (
    DIA DATE,
    OPERACAO VARCHAR(1),
    VALOR DOUBLE PRECISION,
    OPER VARCHAR(20),
    HISTOR BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    USACAIXA VARCHAR(1),
    CONTACRE INTEGER,
    CONTADEB INTEGER,
    CCUSTO INTEGER,
    IDORIGEM INTEGER,
    FLAG CHAR(2))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_AJUSTASEQ (
    IPEDIDO VARCHAR(10),
    IIND INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_AREAATU (
    IPESQ VARCHAR(60))
RETURNS (
    ID INTEGER,
    DESCRICAO VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_ATV_POR_OPER
RETURNS (
    OGERAL INTEGER,
    OMES INTEGER,
    ODIA INTEGER,
    OOPERADOR VARCHAR(25))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_ATZCODORI (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ATZDESCADD (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ATZGRUPO (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ATZIPI (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ATZLOTE (
    IID INTEGER,
    IFLAG CHAR(2),
    IPLACON INTEGER,
    IDC CHAR(1))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ATZMULTIPLOS (
    IINDUSTRIA INTEGER,
    IPEDIDO VARCHAR(10))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ATZTBNOVA (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ATZTOTAIS (
    IINDUSTRIA INTEGER,
    IPEDIDO VARCHAR(10),
    ICLIESPECIAL CHAR(1),
    ISEPARAPORGRUPO CHAR(1),
    IREPETEITEM BOOLEAN)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ATZTOTAIS2 (
    IINDUSTRIA INTEGER,
    IPEDIDO VARCHAR(10),
    ICHAR CHAR(1),
    IADD CHAR(4))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ATZVLRNORMAL (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20),
    EHPROMO CHAR(1))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_BAIXAFATURADOS (
    IFOR INTEGER,
    IPEDIDO VARCHAR(10))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_BUSCADADOSCLI (
    ICLIENTE INTEGER,
    IFOR INTEGER)
RETURNS (
    OCOMPRADOR VARCHAR(55),
    OEMAILCOMPRADOR VARCHAR(60),
    OTRANSP INTEGER,
    ODESC1 DOUBLE PRECISION,
    ODESC2 DOUBLE PRECISION,
    ODESC3 DOUBLE PRECISION,
    ODESC4 DOUBLE PRECISION,
    ODESC5 DOUBLE PRECISION,
    ODESC6 DOUBLE PRECISION,
    ODESC7 DOUBLE PRECISION,
    ODESC8 DOUBLE PRECISION,
    ODESC9 DOUBLE PRECISION,
    ODESC10 DOUBLE PRECISION,
    OPRAZO VARCHAR(20),
    OTABELA VARCHAR(20),
    OIPI DOUBLE PRECISION,
    ONOMRED VARCHAR(30),
    OVENDEDOR INTEGER,
    OSUFRAMA VARCHAR(15),
    OREDELOJA VARCHAR(35),
    OOBSPEDIDO VARCHAR(300),
    OFRETE CHAR(1))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_BUSCANUMPED
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CCUSTO (
    IPESQ VARCHAR(50))
RETURNS (
    ID INTEGER,
    NOME VARCHAR(45))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLIAREAATU (
    ICLIENTE INTEGER)
RETURNS (
    ATU_IDCLI INTEGER,
    ATU_ATUAID INTEGER,
    CLI_NOMRED VARCHAR(30),
    ATU_DESCRICAO VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLIDESCPRO (
    ICLIENTE INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_FORCODIGO INTEGER,
    CLI_GRUPO INTEGER,
    CLI_DESC1 DOUBLE PRECISION,
    CLI_DESC2 DOUBLE PRECISION,
    CLI_DESC3 DOUBLE PRECISION,
    CLI_DESC4 DOUBLE PRECISION,
    CLI_DESC5 DOUBLE PRECISION,
    CLI_DESC6 DOUBLE PRECISION,
    CLI_DESC7 DOUBLE PRECISION,
    CLI_DESC8 DOUBLE PRECISION,
    CLI_DESC9 DOUBLE PRECISION,
    FOR_NOME VARCHAR(15),
    GRU_NOME VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLIENTES (
    IPESQUISA VARCHAR(60),
    IVEND INTEGER,
    IFLAG CHAR(1))
RETURNS (
    ID INTEGER,
    CNPJ VARCHAR(18),
    REDUZIDO VARCHAR(30),
    RAZAO VARCHAR(75),
    TELEFONE VARCHAR(20),
    FAX VARCHAR(200),
    CELULAR VARCHAR(20),
    CIDADE VARCHAR(25),
    ESTADO VARCHAR(2),
    VENDEDOR INTEGER,
    SITUACAO VARCHAR(1),
    REGIAO VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLIENTESINATIVOS (
    IIND INTEGER,
    IVEND1 INTEGER,
    IDIAS INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_NOME VARCHAR(75),
    CLI_FONE1 VARCHAR(20),
    CLI_CIDADE VARCHAR(25),
    VEN_NOME VARCHAR(30),
    ULTCOMPRA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLIFOR (
    IPESQ VARCHAR(40),
    IFLAG CHAR(1))
RETURNS (
    NOME VARCHAR(60),
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLINUNCACOMPROU (
    IIND INTEGER,
    IPROD VARCHAR(25))
RETURNS (
    CLI_NOMRED VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLIPORAREAATU (
    IFOR INTEGER,
    IFLAG CHAR(1))
RETURNS (
    ATU_IDCLI INTEGER,
    CLI_NOMRED VARCHAR(30),
    CLI_EMAIL VARCHAR(200),
    CLI_IMP CHAR(1))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLIPORINDUSTRIA (
    IFOR INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_NOMRED VARCHAR(30),
    CLI_NOME VARCHAR(75),
    CLI_CIDADE VARCHAR(25),
    CLI_IMP VARCHAR(1),
    CLI_EMAIL VARCHAR(200))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLIPROPECCAO (
    IIND INTEGER)
RETURNS (
    CLI_NOMRED VARCHAR(50),
    CLI_EMAIL VARCHAR(200),
    CLI_IMP CHAR(1))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLIRED (
    IVEND INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_NOMRED VARCHAR(30),
    CLI_NOME VARCHAR(75),
    CLI_CIDADE VARCHAR(25),
    CLI_IMP VARCHAR(1),
    CLI_EMAIL VARCHAR(200),
    CLI_CNPJ VARCHAR(18))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CLITELEMKT (
    IVEND INTEGER)
RETURNS (
    CLIID INTEGER,
    NOMERED VARCHAR(30),
    RAZAO VARCHAR(75),
    ULTDATA DATE,
    STATUS CHAR(1))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_COMISSAO_SOMA (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    IVALFAT DOUBLE PRECISION)
RETURNS (
    OVALOR DOUBLE PRECISION,
    OPERCENT DOUBLE PRECISION,
    OPORGRUPO BOOLEAN,
    VFREIO DOUBLE PRECISION,
    VOUTRO DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_COMISSAOVENDEDOR (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    IVALFAT DOUBLE PRECISION,
    ITABELA VARCHAR(20))
RETURNS (
    OVALOR DOUBLE PRECISION,
    OPERCENT DOUBLE PRECISION,
    OPORGRUPO BOOLEAN)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_COMPARATIVO2CLI (
    IDATA1 DATE,
    IDATA2 DATE,
    IFOR INTEGER,
    IREFERENCIA INTEGER,
    IALVO INTEGER,
    IFLAG INTEGER)
RETURNS (
    CODIGO VARCHAR(25),
    DESCRICAO VARCHAR(100),
    REF DOUBLE PRECISION,
    ALVO DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_COMPARATIVO2GRP (
    IDATA1 DATE,
    IDATA2 DATE,
    IFOR INTEGER,
    IREFERENCIA INTEGER,
    IALVO INTEGER,
    IFLAG INTEGER)
RETURNS (
    CODIGO VARCHAR(25),
    DESCRICAO VARCHAR(100),
    REF DOUBLE PRECISION,
    ALVO DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CONDPAG (
    IPESQ VARCHAR(40))
RETURNS (
    ID INTEGER,
    DESCRICAO VARCHAR(30),
    PARCELAS INTEGER,
    BANDEIRA VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CONTATOFOR (
    IFOR INTEGER)
RETURNS (
    CON_FORNEC INTEGER,
    CON_NOME VARCHAR(45),
    CON_GARGO VARCHAR(25),
    CON_FONE VARCHAR(15),
    CON_CELULAR VARCHAR(15),
    CON_EMAIL VARCHAR(60),
    CON_DTNASC DATE,
    CON_CODIGO INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CONTATOSCLI (
    IIDCLIENTE INTEGER)
RETURNS (
    ANI_CLIENTE INTEGER,
    ANI_NOME VARCHAR(55),
    ANI_FUNCAO VARCHAR(35),
    ANI_DIAANIV SMALLINT,
    ANI_MES SMALLINT,
    ANI_FONE VARCHAR(15),
    ANI_EMAIL VARCHAR(80),
    ANI_NIVER DATE,
    ANI_OBS VARCHAR(600),
    ANI_LANCTO INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CREDDEV (
    IPESQUISA VARCHAR(60),
    IFLAG CHAR(1))
RETURNS (
    ID INTEGER,
    CD_TIPO VARCHAR(1),
    CD_NOME VARCHAR(50),
    CD_TIPOEXT VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_DADOSIND (
    ICLIENTE INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_FORCODIGO INTEGER,
    CLI_DESC1 DOUBLE PRECISION,
    CLI_DESC2 DOUBLE PRECISION,
    CLI_DESC3 DOUBLE PRECISION,
    CLI_DESC4 DOUBLE PRECISION,
    CLI_DESC5 DOUBLE PRECISION,
    CLI_DESC6 DOUBLE PRECISION,
    CLI_DESC7 DOUBLE PRECISION,
    CLI_DESC8 DOUBLE PRECISION,
    CLI_DESC9 DOUBLE PRECISION,
    CLI_DESC10 DOUBLE PRECISION,
    CLI_TRANSPORTADORA INTEGER,
    CLI_PRAZOPG VARCHAR(20),
    CLI_IPI INTEGER,
    FOR_NOMERED VARCHAR(15),
    NOME VARCHAR(60),
    CLI_TABELA VARCHAR(20),
    CLI_CODCLIIND VARCHAR(15),
    CLI_OBSPARTICULAR VARCHAR(600))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_DESCADDQTD (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_DESCONTOIND (
    IFOR INTEGER)
RETURNS (
    DES_ID INTEGER,
    DES_CODIND INTEGER,
    DES_VALINI DOUBLE PRECISION,
    DES_VALFIM DOUBLE PRECISION,
    DES_DESCONTO INTEGER,
    GRU_DESC1 DOUBLE PRECISION,
    GRU_DESC2 DOUBLE PRECISION,
    GRU_DESC3 DOUBLE PRECISION,
    GRU_DESC4 DOUBLE PRECISION,
    GRU_DESC5 DOUBLE PRECISION,
    GRU_DESC6 DOUBLE PRECISION,
    GRU_DESC7 DOUBLE PRECISION,
    GRU_DESC8 DOUBLE PRECISION,
    GRU_DESC9 DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_DESCPADRAO (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_DESCPADRAO2 (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ESPELHARPED (
    IPEDORI VARCHAR(10),
    IPEDNEW VARCHAR(10),
    IFOR INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_EXCLUIRPEDIDO (
    IPED VARCHAR(10),
    IFOR INTEGER,
    IFLAG CHAR(1))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_EXCLUIRPROD (
    IIND INTEGER,
    ITAB VARCHAR(25),
    ICODPROD INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_FORRED (
    IVEND INTEGER)
RETURNS (
    FOR_CODIGO INTEGER,
    FOR_NOMERED VARCHAR(15),
    FOR_NOME VARCHAR(75),
    FOR_TIPOFRETE CHAR(1))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_FORVENDASCLI (
    IFOR INTEGER)
RETURNS (
    CLI_NOMRED VARCHAR(30),
    DATA DATE,
    TOTAL DOUBLE PRECISION,
    CLI_FONE1 VARCHAR(20),
    PED_INDUSTRIA INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_FUNCIONARIOS (
    IPESQUISA VARCHAR(60))
RETURNS (
    ID INTEGER,
    NOME VARCHAR(45),
    NOMEUSU VARCHAR(50),
    FONE VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_GRAFTELECLIIND (
    XDT1 DATE,
    XDT2 DATE,
    XIND INTEGER,
    XCLI INTEGER)
RETURNS (
    OMES INTEGER,
    OMESANO VARCHAR(10),
    OTOTAL DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_GRAFVENDAS (
    XDT1 DATE,
    XDT2 DATE,
    XIND INTEGER)
RETURNS (
    OTOTAL DOUBLE PRECISION,
    OMESEXT DATE,
    OMES CHAR(3))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_GRAFVENDASCLI (
    XDT1 DATE,
    XDT2 DATE,
    XIND INTEGER,
    XCLI INTEGER)
RETURNS (
    OMESANO DATE,
    OTOTAL DOUBLE PRECISION,
    OMES CHAR(3))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_GRUPODESCONTO
RETURNS (
    ID INTEGER,
    DESC1 DOUBLE PRECISION,
    DESC2 DOUBLE PRECISION,
    DESC3 DOUBLE PRECISION,
    DESC4 DOUBLE PRECISION,
    DESC5 DOUBLE PRECISION,
    DESC6 DOUBLE PRECISION,
    DESC7 DOUBLE PRECISION,
    DESC8 DOUBLE PRECISION,
    DESC9 DOUBLE PRECISION,
    DESC10 DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_GRUPOPROD (
    IPESQ VARCHAR(60))
RETURNS (
    ID INTEGER,
    NOME VARCHAR(50),
    PERCOM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_HISTCLIENTESPRODUTOS (
    IIND INTEGER,
    IPROD VARCHAR(25))
RETURNS (
    ITE_PRODUTO VARCHAR(25),
    CLI_NOMRED VARCHAR(30),
    ULTCOMPRA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_HISTCOMPRACLI (
    IDATA1 DATE,
    IDATA2 DATE,
    IFLAG CHAR(1),
    ICLIENTE INTEGER)
RETURNS (
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    DIA DATE,
    TOTAL DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_HISTVENDAITEM (
    IPROD VARCHAR(25),
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    MES INTEGER,
    ITE_PRODUTO VARCHAR(25),
    TOTAL DOUBLE PRECISION,
    MESANO DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_IMPRIMEITEPED (
    IPED VARCHAR(10),
    IFOR INTEGER,
    ITAB VARCHAR(20))
RETURNS (
    ITE_PRODUTO VARCHAR(25) /* TYPE OF COLUMN ITENS_PED.ITE_PRODUTO */,
    ITE_EMBUCH VARCHAR(15) /* TYPE OF COLUMN ITENS_PED.ITE_EMBUCH */,
    ITE_QUANT DOUBLE PRECISION /* TYPE OF COLUMN ITENS_PED.ITE_QUANT */,
    ITE_PUNI DOUBLE PRECISION /* TYPE OF COLUMN ITENS_PED.ITE_PUNI */,
    ITE_PUNILIQ DOUBLE PRECISION /* TYPE OF COLUMN ITENS_PED.ITE_PUNILIQ */,
    ITE_IPI NUMERIC(7,2) /* TYPE OF COLUMN ITENS_PED.ITE_IPI */,
    ITE_TOTLIQUIDO DOUBLE PRECISION /* TYPE OF COLUMN ITENS_PED.ITE_TOTLIQUIDO */,
    ITE_NOMEPROD VARCHAR(100) /* TYPE OF COLUMN ITENS_PED.ITE_NOMEPROD */,
    ITE_DESCONTOS VARCHAR(200) /* TYPE OF COLUMN ITENS_PED.ITE_DESCONTOS */,
    PRO_CODORIGINAL VARCHAR(40) /* TYPE OF COLUMN PRODUTOS.PRO_CODORIGINAL */,
    ITE_SEQ SMALLINT /* TYPE OF COLUMN ITENS_PED.ITE_SEQ */,
    ITE_TOTBRUTO DOUBLE PRECISION /* TYPE OF COLUMN ITENS_PED.ITE_TOTBRUTO */,
    ITE_VALCOMIPI DOUBLE PRECISION /* TYPE OF COLUMN ITENS_PED.ITE_VALCOMIPI */,
    PRO_APLICACAO2 VARCHAR(800) /* TYPE OF COLUMN PRODUTOS.PRO_APLICACAO2 */,
    ITE_CONVERSAO VARCHAR(300) /* TYPE OF COLUMN PRODUTOS.ITE_CONVERSAO */,
    ITE_PESO DOUBLE PRECISION /* TYPE OF COLUMN PRODUTOS.ITE_PESO */,
    ITE_ST DOUBLE PRECISION /* TYPE OF COLUMN ITENS_PED.ITE_ST */,
    ITE_VALCOMST DOUBLE PRECISION /* TYPE OF COLUMN ITENS_PED.ITE_VALCOMST */,
    ITE_LANCTO INTEGER,
    PRO_EMBALAGEM INTEGER,
    ITE_PUNILIQCOMIMPOSTO DOUBLE PRECISION,
    ITE_NUMPEDCLI VARCHAR(25))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_IMPRIMEPED (
    IFOR INTEGER,
    IPED VARCHAR(10))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    PED_CLIENTE INTEGER,
    PED_INDUSTRIA INTEGER,
    PED_VENDEDOR INTEGER,
    PED_TOTLIQ DOUBLE PRECISION,
    PED_TOTBRUTO DOUBLE PRECISION,
    PED_OBS VARCHAR(600),
    PED_CONDPAG VARCHAR(100),
    PED_TRANSP INTEGER,
    PED_TIPOFRETE VARCHAR(1),
    PED_TOTALIPI DOUBLE PRECISION,
    PED_OBSFORA VARCHAR(600),
    PED_CLIIND VARCHAR(15),
    PED_SITUACAO VARCHAR(1),
    PED_COMPRADOR VARCHAR(30),
    PED_EMAILCOMP VARCHAR(60),
    PED_TABELA VARCHAR(20),
    CLI_NOME VARCHAR(75),
    CLI_ENDERECO VARCHAR(200),
    CLI_BAIRRO VARCHAR(100),
    CLI_CEP VARCHAR(11),
    CLI_UF VARCHAR(2),
    CLI_CIDADE VARCHAR(25),
    CLI_CNPJ VARCHAR(18),
    CLI_INSCRICAO VARCHAR(18),
    CLI_FONE1 VARCHAR(20),
    CLI_FONE2 VARCHAR(20),
    CLI_FONE3 VARCHAR(20),
    CLI_EMAIL VARCHAR(200),
    CLI_PTOREF VARCHAR(250),
    CLI_ENDCOB VARCHAR(45),
    CLI_BAICOB VARCHAR(25),
    CLI_CIDCOB VARCHAR(25),
    CLI_CEPCOB VARCHAR(11),
    CLI_UFCOB VARCHAR(2),
    CLI_EMAILNFE VARCHAR(60),
    CLI_SUFRAMA VARCHAR(15),
    CLI_CAIXAPOSTAL VARCHAR(20),
    CLI_COMPENDERECO VARCHAR(50),
    CLI_EMAILFINANC VARCHAR(60),
    CLI_NOMRED VARCHAR(30),
    NOME VARCHAR(60),
    ENDERECO VARCHAR(45),
    BAIRRO VARCHAR(25),
    CIDADE VARCHAR(25),
    CEP VARCHAR(11),
    UF VARCHAR(2),
    CNPJ VARCHAR(18),
    IEST VARCHAR(15),
    TELEFONE1 VARCHAR(15),
    EMAIL VARCHAR(50),
    FOR_NOME VARCHAR(75),
    FOR_EMAIL VARCHAR(120),
    FOR_LOCIMAGEM VARCHAR(50),
    FOR_CODREP INTEGER,
    VEN_NOME VARCHAR(45),
    VEN_FONE1 VARCHAR(20),
    SITUACAO VARCHAR(10),
    TIPOFRETE VARCHAR(10),
    CLI_OBSPEDIDO VARCHAR(600),
    CLI_OBSPARTICULAR VARCHAR(600),
    FOR_NOMERED VARCHAR(15))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_INDCLIPODECOMPRAR (
    ICLIENTE INTEGER)
RETURNS (
    CLI_ID INTEGER,
    CLI_INDID INTEGER,
    FOR_NOMERED VARCHAR(15))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_INDUSTRIAS (
    IPESQUISA VARCHAR(60),
    IVEND INTEGER,
    IFLAG CHAR(1))
RETURNS (
    ID INTEGER,
    CNPJ VARCHAR(18),
    REDUZIDO VARCHAR(15),
    RAZAO VARCHAR(75),
    TELEFONE VARCHAR(25),
    TELEFONE2 VARCHAR(25),
    SITUACAO VARCHAR(1))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_ITEMUNICACOMPRA (
    IFOR INTEGER,
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    PRODUTO VARCHAR(25),
    CLIENTE VARCHAR(30),
    QUANT INTEGER,
    DIA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_ITENSCRM (
    ICLI INTEGER,
    IFOR INTEGER)
RETURNS (
    AGE_LANCTO INTEGER,
    AGE_DATA DATE,
    AGE_CLIENTE INTEGER,
    AGE_HORARIO VARCHAR(5),
    AGE_STATUS VARCHAR(1),
    AGE_OBS VARCHAR(1800),
    AGE_INDUSTRIA INTEGER,
    AGE_TELEFONE VARCHAR(35),
    AGE_CONTATO VARCHAR(35),
    AGE_OPERADOR VARCHAR(25),
    FOR_NOMERED VARCHAR(15),
    AGE_TOPICO VARCHAR(25),
    STATUSEXT VARCHAR(20),
    AGE_TIPOINTERACAO CHAR(1),
    INTERACAO VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_ITENSNUNCACOMPRADOS (
    ICLIENTE INTEGER,
    IINDUSTRIA INTEGER,
    ICATEG VARCHAR(1))
RETURNS (
    PRO_CODPROD VARCHAR(25),
    PRO_LINHA VARCHAR(800),
    PRO_NOME VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_ITENSPRIMEIRACOMPRA (
    IINDUSTRIA INTEGER,
    ICLIENTE INTEGER,
    IPEDIDO VARCHAR(10))
RETURNS (
    OPRODUTO VARCHAR(6000))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_ITENSPROMOCLI (
    IPROD VARCHAR(25),
    ITABELA VARCHAR(25))
RETURNS (
    ITEM_CODPROD VARCHAR(25),
    ITEM_VALIDADE DATE,
    ITEM_VALOR DOUBLE PRECISION,
    CLI_NOMRED VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_ITENSTELEMKT (
    ICLI INTEGER,
    IFOR INTEGER)
RETURNS (
    AGE_LANCTO INTEGER,
    AGE_DATA DATE,
    AGE_CLIENTE INTEGER,
    AGE_HORARIO VARCHAR(5),
    AGE_STATUS VARCHAR(1),
    AGE_OBS VARCHAR(1800),
    AGE_INDUSTRIA INTEGER,
    AGE_TELEFONE VARCHAR(35),
    AGE_CONTATO VARCHAR(35),
    AGE_OPERADOR VARCHAR(25),
    FOR_NOMERED VARCHAR(15),
    AGE_TOPICO VARCHAR(25),
    STATUSEXT VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_LANCTOSNAOCOMPRADO (
    IDFOR INTEGER,
    IDCLI INTEGER)
RETURNS (
    IDNAOCOMP VARCHAR(25),
    QTDLANCTOS INTEGER,
    PROTIFOLIO INTEGER,
    LANCAMENTO CHAR(1),
    QTDNAOCOMP INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_LISTARECEBER (
    ICLIENTE INTEGER,
    IVENDA INTEGER)
RETURNS (
    OLANCTO INTEGER,
    ODOCTO VARCHAR(15),
    ODATA DATE,
    OVALOR DOUBLE PRECISION,
    OVENC DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAANO (
    ICLIENTE INTEGER,
    IVEND INTEGER,
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDE CHAR(1))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    INDUSTRIA VARCHAR(15),
    MESANO VARCHAR(10),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAANOCLI (
    IDATA1 DATE,
    IDATA2 DATE,
    IGRUPOLOJA BOOLEAN,
    IFOR INTEGER,
    IDETALHADA BOOLEAN)
RETURNS (
    PEDIDO VARCHAR(10),
    CLIENTE VARCHAR(30),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION,
    MES VARCHAR(10),
    INDUSTRIA VARCHAR(35),
    DATAPED DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAANOVEND (
    IDATA1 DATE,
    IDATA2 DATE,
    IVEND INTEGER)
RETURNS (
    INDUSTRIA VARCHAR(30),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION,
    MES VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPACLIGERAL (
    IIND INTEGER,
    ICLI INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDELOJA CHAR(1))
RETURNS (
    OCODIGO VARCHAR(25),
    ODESCRICAO VARCHAR(50),
    OCLIENTE INTEGER,
    OGERAL INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPACLIMONTH_TO_MONTH (
    IDATA1 DATE,
    IDATA2 DATE,
    IGRUPOLOJA BOOLEAN,
    IFOR INTEGER)
RETURNS (
    CLIENTE VARCHAR(30),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION,
    MES VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPACOMP (
    IINDUSTRIA INTEGER,
    ICLIENTE1 INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IFILTRO CHAR(1),
    ICATEG CHAR(1))
RETURNS (
    MES CHAR(25),
    ATU DOUBLE PRECISION,
    ANT DOUBLE PRECISION,
    RET DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAFECHASELLS (
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDE CHAR(1))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    CLIENTE VARCHAR(35),
    MESANO VARCHAR(10),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAGERALCLI (
    IDATA1 DATE,
    IDATA2 DATE,
    IFLAG CHAR(1),
    IFOR INTEGER,
    ICLI INTEGER,
    IREDE BOOLEAN,
    IVENDEDOR INTEGER)
RETURNS (
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(45),
    DIA DATE,
    TOTAL DOUBLE PRECISION,
    DIASSEMCOMPRA INTEGER,
    CLIUF CHAR(2))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAGRLOJAS (
    IDATA1 DATE,
    IDATA2 DATE,
    IFOR INTEGER)
RETURNS (
    CLIENTE VARCHAR(30),
    GRUPO VARCHAR(35),
    TOTAL DOUBLE PRECISION,
    MES DATE,
    PEDIDO VARCHAR(10),
    QUANT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAITEMVENDIDO (
    PDT1 DATE,
    PDT2 DATE,
    PIND INTEGER,
    PCLI INTEGER,
    PGRUPOLOJAS BOOLEAN,
    PCATEGORIA BOOLEAN)
RETURNS (
    ITEM VARCHAR(25),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION,
    MESANO VARCHAR(10),
    DIA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAITENSCLIENTE (
    IDATA1 DATE,
    IDATA2 DATE,
    IFOR INTEGER,
    ICLI1 INTEGER)
RETURNS (
    ITEM VARCHAR(25),
    CLI_NOMRED VARCHAR(30),
    TOTALQTD DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAMETAVEND (
    PINICIO DATE,
    PFIM DATE)
RETURNS (
    OVENDEDOR VARCHAR(45),
    OINDUSTRIA VARCHAR(15),
    OMES INTEGER,
    OPREVISTO DOUBLE PRECISION,
    OREALIZADO DOUBLE PRECISION,
    OPERC DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAMOM (
    MES_REFERENCIA INTEGER,
    ANO_REFERENCIA INTEGER,
    IFOR INTEGER,
    IREDE BOOLEAN)
RETURNS (
    CLIENTE VARCHAR(30),
    VALOR_ANT DOUBLE PRECISION,
    QTD_ANT DOUBLE PRECISION,
    VALOR_ATU DOUBLE PRECISION,
    QTD_ATU DOUBLE PRECISION,
    PERC_VAL DOUBLE PRECISION,
    PERC_QTD DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAMOSTRASELLOUT (
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDE CHAR(1))
RETURNS (
    CLIENTE VARCHAR(35),
    MESANO VARCHAR(10),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAPAPORGRUPO (
    IDT1 DATE,
    IDT2 DATE,
    IIND INTEGER,
    IVEND INTEGER)
RETURNS (
    ODESCGRUPO VARCHAR(50),
    OQUANT DOUBLE PRECISION,
    OMESANO VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MERGECADPRO
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_MERGEPEDIDOS (
    INUMERO INTEGER,
    IPEDIDO VARCHAR(10),
    IDATA DATE,
    IFOR INTEGER,
    ICLI INTEGER,
    ITRANSP INTEGER,
    IVENDEDOR INTEGER,
    ICLIIND VARCHAR(15),
    IDATAFAT DATE,
    INFFAT VARCHAR(15),
    IPRI DOUBLE PRECISION,
    ISEG DOUBLE PRECISION,
    ITER DOUBLE PRECISION,
    IQUA DOUBLE PRECISION,
    IQUI DOUBLE PRECISION,
    ISEX DOUBLE PRECISION,
    ISET DOUBLE PRECISION,
    IOIT DOUBLE PRECISION,
    INOV DOUBLE PRECISION,
    IDEZ DOUBLE PRECISION,
    IDESCADD DOUBLE PRECISION,
    ICONDPAG VARCHAR(100),
    IOBS VARCHAR(600),
    ISITU VARCHAR(1),
    ITOTLIQ DOUBLE PRECISION,
    ITOTBRU DOUBLE PRECISION,
    IENVIADO VARCHAR(1),
    IDTENVIO DATE,
    IACRESC DOUBLE PRECISION,
    IEXPORTADO VARCHAR(1),
    ICOEF DOUBLE PRECISION,
    IOBSFORA VARCHAR(600),
    ITIPOFRETE VARCHAR(1),
    ITOTALIPI DOUBLE PRECISION,
    ICOMPRADOR VARCHAR(30),
    IEMAILCOMP VARCHAR(60),
    ITABELA VARCHAR(20),
    ICRUD CHAR(1))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_METAINDPREV (
    IANO INTEGER,
    IFOR INTEGER)
RETURNS (
    INDUSTRIA VARCHAR(30),
    FLAG VARCHAR(12),
    JAN DOUBLE PRECISION,
    FEV DOUBLE PRECISION,
    MAR DOUBLE PRECISION,
    ABR DOUBLE PRECISION,
    MAI DOUBLE PRECISION,
    JUN DOUBLE PRECISION,
    JUL DOUBLE PRECISION,
    AGO DOUBLE PRECISION,
    STB DOUBLE PRECISION,
    OUT DOUBLE PRECISION,
    NOV DOUBLE PRECISION,
    DEZ DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_METAINDREALIZ (
    IANO INTEGER,
    IFOR INTEGER)
RETURNS (
    INDUSTRIA VARCHAR(30),
    FLAG VARCHAR(12),
    JAN DOUBLE PRECISION,
    FEV DOUBLE PRECISION,
    MAR DOUBLE PRECISION,
    ABR DOUBLE PRECISION,
    MAI DOUBLE PRECISION,
    JUN DOUBLE PRECISION,
    JUL DOUBLE PRECISION,
    AGO DOUBLE PRECISION,
    STB DOUBLE PRECISION,
    OUT DOUBLE PRECISION,
    NOV DOUBLE PRECISION,
    DEZ DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_METAINDRESULT (
    IANO INTEGER,
    IFOR INTEGER)
RETURNS (
    INDUSTRIA VARCHAR(30),
    FLAG VARCHAR(12),
    JANX DOUBLE PRECISION,
    FEVX DOUBLE PRECISION,
    MARX DOUBLE PRECISION,
    ABRX DOUBLE PRECISION,
    MAIX DOUBLE PRECISION,
    JUNX DOUBLE PRECISION,
    JULX DOUBLE PRECISION,
    AGOX DOUBLE PRECISION,
    STBX DOUBLE PRECISION,
    OUTX DOUBLE PRECISION,
    NOVX DOUBLE PRECISION,
    DEZX DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_METASCLI (
    ICLI INTEGER)
RETURNS (
    MET_INDUSTRIA INTEGER,
    MET_CLIENTE INTEGER,
    MET_VALOR DOUBLE PRECISION,
    MET_DATA DATE,
    MET_MESANO VARCHAR(8),
    FOR_NOMERED VARCHAR(15))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_METASIND (
    IFOR INTEGER)
RETURNS (
    MET_INDUSTRIA INTEGER,
    MET_VALOR DOUBLE PRECISION,
    MET_DATA DATE,
    MET_MESANO VARCHAR(8),
    MET_METATELEMKT INTEGER,
    TOTAL DOUBLE PRECISION,
    PERCENTUAL DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_METASMES (
    IFOR INTEGER,
    IMES VARCHAR(8),
    DT1 DATE,
    DT2 DATE)
RETURNS (
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    TOTPEDIDOS DOUBLE PRECISION,
    TOTFATURADOS DOUBLE PRECISION,
    PERCENTUAL DOUBLE PRECISION,
    META DOUBLE PRECISION,
    TOTALQTD INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_METASMESOLD (
    IMES VARCHAR(8),
    DT1 DATE,
    DT2 DATE)
RETURNS (
    FOR_NOMERED VARCHAR(15),
    TOTPEDIDOS DOUBLE PRECISION,
    TOTFATURADOS DOUBLE PRECISION,
    PERCENTUAL DOUBLE PRECISION,
    META DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_METASVENDEDOR (
    IVENDEDOR INTEGER,
    IANO INTEGER)
RETURNS (
    MET_ANO INTEGER,
    MET_MES INTEGER,
    MET_VENDEDOR INTEGER,
    MET_INDUSTRIA INTEGER,
    MET_MESVALOR DOUBLE PRECISION,
    FOR_NOMERED VARCHAR(15))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MOSTRACAIXA (
    DATAINI DATE,
    DATAFIM DATE)
RETURNS (
    DATALANC DATE,
    SALDOANT NUMERIC(9,2),
    CREDITO NUMERIC(9,2),
    DEBITO NUMERIC(9,2),
    SALDOATU NUMERIC(9,2),
    TIPO VARCHAR(1),
    VALOR_DC NUMERIC(9,2),
    CAIID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MOSTRACRM (
    ICLIENTE INTEGER)
RETURNS (
    TELE_ID INTEGER,
    TELE_CLIENTE INTEGER,
    CLI_NOMRED VARCHAR(30),
    DATA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MOSTRAPED (
    PIND INTEGER,
    PCLI INTEGER,
    PVEND INTEGER,
    PSITU CHAR(1))
RETURNS (
    PEDIDO VARCHAR(10),
    DATA DATE,
    CLIENTE VARCHAR(30),
    SITUACAO VARCHAR(1),
    CONDICOES VARCHAR(100),
    ENVIO DATE,
    BRUTO DOUBLE PRECISION,
    LIQUIDO DOUBLE PRECISION,
    COMIPI DOUBLE PRECISION,
    INDUSTRIA INTEGER,
    CLIID INTEGER,
    TRANSPID INTEGER,
    RAZAO VARCHAR(75),
    FATURADO DOUBLE PRECISION,
    TABELA VARCHAR(20),
    VENDEDOR INTEGER,
    INDRED VARCHAR(15))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MOSTRAPEDINDEX (
    PIND INTEGER,
    PCLI INTEGER,
    PVEND INTEGER,
    PSITU CHAR(1))
RETURNS (
    PEDIDO VARCHAR(10),
    DATA DATE,
    CLIENTE VARCHAR(30),
    SITUACAO VARCHAR(1),
    CONDICOES VARCHAR(100),
    ENVIO DATE,
    BRUTO DOUBLE PRECISION,
    LIQUIDO DOUBLE PRECISION,
    COMIPI DOUBLE PRECISION,
    INDUSTRIA INTEGER,
    CLIID INTEGER,
    TRANSPID INTEGER,
    RAZAO VARCHAR(75),
    FATURADO DOUBLE PRECISION,
    TABELA VARCHAR(25),
    VENDEDOR INTEGER,
    INDRED VARCHAR(15),
    NUMPEDCLI VARCHAR(15),
    NUMPEDIND VARCHAR(15))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MOSTRAPGREC (
    IFAV INTEGER,
    IROT CHAR(1),
    ISIT CHAR(1),
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    ID INTEGER,
    DOCTO VARCHAR(15),
    DTLANCTO DATE,
    CREDEB CHAR(1),
    CONTA INTEGER,
    VALOR NUMERIC(15,2),
    VENCTO DATE,
    VALORPAGO NUMERIC(15,2),
    DATAPGTO DATE,
    CLIFOR_ID INTEGER,
    CLIFOR VARCHAR(60),
    DESCCONTA VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MOSTRAPROD (
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20),
    IGRUPO INTEGER,
    IPESQUISA VARCHAR(100))
RETURNS (
    ID INTEGER,
    CODIND INTEGER,
    CODIGO VARCHAR(25),
    CONVERSAO VARCHAR(300),
    NOME VARCHAR(100),
    PRECO1 DOUBLE PRECISION,
    PRECO2 DOUBLE PRECISION,
    PRECO3 DOUBLE PRECISION,
    LIQUIDO DOUBLE PRECISION,
    DATATAB DATE,
    EMBALAGEM INTEGER,
    DATAPROMO DATE,
    IPI NUMERIC(9,2),
    CODIGO2 VARCHAR(25),
    ST DOUBLE PRECISION,
    NOMETABELA VARCHAR(20),
    GRUPOPRO INTEGER,
    DESCADIC2 DOUBLE PRECISION,
    PESO DOUBLE PRECISION,
    PREPESO DOUBLE PRECISION,
    STATUS VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MOSTRATMKT (
    ICLIENTE INTEGER)
RETURNS (
    TELE_ID INTEGER,
    TELE_CLIENTE INTEGER,
    CLI_NOMRED VARCHAR(30),
    DATA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_NIVERCLI (
    IDATAINI DATE,
    IDATAFIM DATE)
RETURNS (
    ANI_NOME VARCHAR(55),
    ANI_FUNCAO VARCHAR(35),
    ANI_FONE VARCHAR(15),
    ANI_EMAIL VARCHAR(60),
    ANI_OBS VARCHAR(600),
    CLI_NOMRED VARCHAR(30),
    ANI_NIVER VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_NIVERFOR (
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    CON_NOME VARCHAR(45),
    CON_CARGO VARCHAR(25),
    CON_FONE VARCHAR(15),
    CON_CELULAR VARCHAR(15),
    CON_EMAIL VARCHAR(60),
    FOR_NOMERED VARCHAR(15),
    DIA VARCHAR(6))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_NIVERFUNCIONARIOS (
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    VENDEDOR VARCHAR(45),
    DIA VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_NIVERS (
    IDATAINI DATE,
    IDATAFIM DATE)
RETURNS (
    CONTATO VARCHAR(55),
    EMPRESA VARCHAR(50),
    FUNCAO VARCHAR(35),
    FONE VARCHAR(15),
    EMAIL VARCHAR(60),
    ANI_NIVER VARCHAR(10),
    DTNASC DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_OBJ_REAL_CLI (
    IFOR INTEGER,
    IDATA1 DATE,
    IDATA2 DATE)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_PEDIDOSCLI (
    ICLIENTE INTEGER)
RETURNS (
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    PED_TOTLIQ DOUBLE PRECISION,
    FOR_NOMERED VARCHAR(15),
    PED_CLIENTE INTEGER,
    PED_INDUSTRIA INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_PEDSEMFAT (
    PIND INTEGER,
    PCLI INTEGER,
    PNF VARCHAR(300))
RETURNS (
    PEDIDO VARCHAR(10),
    DATAPED DATE,
    CLIENTE VARCHAR(30),
    SITUACAO VARCHAR(1),
    LIQUIDO DOUBLE PRECISION,
    COMIPI DOUBLE PRECISION,
    INDUSTRIA INTEGER,
    CLIID INTEGER,
    FATURADO DOUBLE PRECISION,
    NUMPEDIND VARCHAR(15),
    IDPROD VARCHAR(25),
    QTDVENDIDA DOUBLE PRECISION,
    QTDFATURADA INTEGER,
    SALDO INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_PGREC (
    IDATA1 DATE,
    IDATA2 DATE,
    IROTINA CHAR(1),
    ICLIFOR INTEGER,
    IFLAG CHAR(2),
    ICCUSTO INTEGER,
    ICONTA INTEGER)
RETURNS (
    ID INTEGER,
    DOCTO VARCHAR(15),
    DTLANCTO DATE,
    CREDEB CHAR(1),
    CONTA INTEGER,
    VALOR DOUBLE PRECISION,
    VENCTO DATE,
    VALORPAGO DOUBLE PRECISION,
    DATAPGTO DATE,
    CLIFOR_ID INTEGER,
    CLIFOR VARCHAR(60),
    DESCRICAO VARCHAR(600),
    SALDO DOUBLE PRECISION,
    PARCELA INTEGER,
    CCUSTO VARCHAR(60),
    CTACRE VARCHAR(10),
    CTADEB VARCHAR(10),
    JUROS DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_PGREC_REL (
    IDATA1 DATE,
    IDATA2 DATE,
    IROTINA CHAR(1),
    ICLIFOR INTEGER,
    IFLAG CHAR(2),
    ICCUSTO INTEGER,
    ICONTA VARCHAR(10))
RETURNS (
    ID INTEGER,
    DOCTO VARCHAR(15),
    DTLANCTO DATE,
    CREDEB CHAR(1),
    CONTA INTEGER,
    VALOR DOUBLE PRECISION,
    VENCTO DATE,
    VALORPAGO DOUBLE PRECISION,
    DATAPGTO DATE,
    CLIFOR_ID INTEGER,
    CLIFOR VARCHAR(60),
    DESCRICAO VARCHAR(600),
    SALDO DOUBLE PRECISION,
    PARCELA INTEGER,
    CCUSTO VARCHAR(60),
    CTACRE VARCHAR(10),
    CTADEB VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_PLACON (
    IPESQ VARCHAR(40))
RETURNS (
    GRAU VARCHAR(10),
    ID INTEGER,
    DESCRICAO VARCHAR(50),
    TIPO CHAR(1),
    DESCTIPO VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_POLITDESC (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_POSICAOSELLS (
    ICLIENTE INTEGER,
    IVEND INTEGER,
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDE CHAR(1))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    INDUSTRIA VARCHAR(15),
    MESANO VARCHAR(10),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_PRODPED (
    IFOR INTEGER,
    ITAB VARCHAR(20))
RETURNS (
    ID INTEGER,
    CODIND INTEGER,
    CODIGO VARCHAR(25),
    CONVERSAO VARCHAR(300),
    NOME VARCHAR(100),
    PRECO1 DOUBLE PRECISION,
    PRECO2 DOUBLE PRECISION,
    PRECO3 DOUBLE PRECISION,
    DATATAB DATE,
    EMBALAGEM INTEGER,
    DATAPROMO DATE,
    IPI DOUBLE PRECISION,
    CODIGO2 VARCHAR(25),
    LINHA VARCHAR(50),
    GRUPODES INTEGER,
    DESCADIC DOUBLE PRECISION,
    ST DOUBLE PRECISION,
    GRUPOPRO INTEGER,
    NOMETABELA VARCHAR(20),
    DESCADIC2 DOUBLE PRECISION,
    PESO DOUBLE PRECISION,
    PREPESO DOUBLE PRECISION,
    STATUS CHAR(1))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_PROTABELAS (
    IINDUSTRIA INTEGER)
RETURNS (
    PRO_NOMETABELA VARCHAR(25))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RECBOLETOS (
    IDATA1 DATE,
    IDATA2 DATE,
    IFLAG VARCHAR(1))
RETURNS (
    LAN_LANCTO INTEGER,
    LAN_DOCTO VARCHAR(15),
    LAN_DATA DATE,
    LAN_VALOR DOUBLE PRECISION,
    LAN_CLIFOR INTEGER,
    LAN_CLIFORNOME VARCHAR(60),
    LAN_VENCIMENTO DATE,
    LAN_NOSSONUMERO VARCHAR(25),
    LAN_SEL CHAR(1),
    LAN_PATHBOLETO VARCHAR(300),
    LAN_DESCRICAO BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    CLI_EMAIL VARCHAR(100),
    CLI_RAZAO VARCHAR(60),
    CLI_ENDERECO VARCHAR(45),
    CLI_BAIRRO VARCHAR(25),
    CLI_TIPO CHAR(1),
    CLI_CIDADE VARCHAR(25),
    CLI_UF VARCHAR(2),
    CLI_CEP VARCHAR(10),
    CLI_CNPJ VARCHAR(18),
    CLI_ENDENUM VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RECEBEITENSBAIXAXML (
    PDADOS BLOB SUB_TYPE BINARY SEGMENT SIZE 80)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_RECEBEITENSPED (
    PDADOS BLOB SUB_TYPE BINARY SEGMENT SIZE 80,
    IREPETEITENS BOOLEAN)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_RECEBEITENSPEDEXCEL (
    PDADOS BLOB SUB_TYPE BINARY SEGMENT SIZE 80)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_REGIAOVEND (
    IVEND INTEGER)
RETURNS (
    ID INTEGER,
    REGIAO VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_REGIOES (
    IPESQ VARCHAR(60))
RETURNS (
    ID INTEGER,
    DESCRICAO VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELCLIATUAREGIAO (
    IDAREA INTEGER,
    IDREGIAO INTEGER)
RETURNS (
    IDCLI INTEGER,
    NOMERED VARCHAR(30),
    REGIAO VARCHAR(50),
    ENDERECO VARCHAR(200),
    ENDNUM VARCHAR(15),
    CIDADE VARCHAR(25),
    TELEFONE VARCHAR(20),
    BAIRRO VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELCLIENTES (
    IFLAG INTEGER,
    IDT1 DATE,
    IDT2 DATE,
    IFILTRO INTEGER,
    ATIVO CHAR(1))
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_NOME VARCHAR(75) /* TYPE OF COLUMN CLIENTES.CLI_NOME */,
    CLI_FANTASIA VARCHAR(45) /* TYPE OF COLUMN CLIENTES.CLI_FANTASIA */,
    CLI_ENDERECO VARCHAR(200) /* TYPE OF COLUMN CLIENTES.CLI_ENDERECO */,
    CLI_BAIRRO VARCHAR(100) /* TYPE OF COLUMN CLIENTES.CLI_BAIRRO */,
    CLI_CIDADE VARCHAR(25) /* TYPE OF COLUMN CLIENTES.CLI_CIDADE */,
    CLI_CEP VARCHAR(11) /* TYPE OF COLUMN CLIENTES.CLI_CEP */,
    CLI_UF VARCHAR(2) /* TYPE OF COLUMN CLIENTES.CLI_UF */,
    CLI_TIPOPES VARCHAR(1) /* TYPE OF COLUMN CLIENTES.CLI_TIPOPES */,
    CLI_PTOREF VARCHAR(250) /* TYPE OF COLUMN CLIENTES.CLI_PTOREF */,
    CLI_CNPJ VARCHAR(18) /* TYPE OF COLUMN CLIENTES.CLI_CNPJ */,
    CLI_INSCRICAO VARCHAR(18) /* TYPE OF COLUMN CLIENTES.CLI_INSCRICAO */,
    CLI_FONE1 VARCHAR(20) /* TYPE OF COLUMN CLIENTES.CLI_FONE1 */,
    CLI_FONE2 VARCHAR(20) /* TYPE OF COLUMN CLIENTES.CLI_FONE2 */,
    CLI_FONE3 VARCHAR(20) /* TYPE OF COLUMN CLIENTES.CLI_FONE3 */,
    CLI_ENDCOB VARCHAR(45) /* TYPE OF COLUMN CLIENTES.CLI_ENDCOB */,
    CLI_BAICOB VARCHAR(25) /* TYPE OF COLUMN CLIENTES.CLI_BAICOB */,
    CLI_CIDCOB VARCHAR(25) /* TYPE OF COLUMN CLIENTES.CLI_CIDCOB */,
    CLI_CEPCOB VARCHAR(11) /* TYPE OF COLUMN CLIENTES.CLI_CEPCOB */,
    CLI_UFCOB VARCHAR(2) /* TYPE OF COLUMN CLIENTES.CLI_UFCOB */,
    CLI_EMAIL VARCHAR(200) /* TYPE OF COLUMN CLIENTES.CLI_EMAIL */,
    CLI_REFCOME VARCHAR(600) /* TYPE OF COLUMN CLIENTES.CLI_REFCOME */,
    CLI_EMAILNFE VARCHAR(60) /* TYPE OF COLUMN CLIENTES.CLI_EMAILNFE */,
    CLI_IMP VARCHAR(1) /* TYPE OF COLUMN CLIENTES.CLI_IMP */,
    CLI_SUFRAMA VARCHAR(15) /* TYPE OF COLUMN CLIENTES.CLI_SUFRAMA */,
    CLI_VENCSUF DATE /* TYPE OF COLUMN CLIENTES.CLI_VENCSUF */,
    CLI_CAIXAPOSTAL VARCHAR(20) /* TYPE OF COLUMN CLIENTES.CLI_CAIXAPOSTAL */,
    CLI_OBS VARCHAR(800) /* TYPE OF COLUMN CLIENTES.CLI_OBS */,
    CLI_COMPENDERECO VARCHAR(50) /* TYPE OF COLUMN CLIENTES.CLI_COMPENDERECO */,
    CLI_ATUACAO VARCHAR(1) /* TYPE OF COLUMN CLIENTES.CLI_ATUACAO */,
    CLI_OBSPEDIDO VARCHAR(300) /* TYPE OF COLUMN CLIENTES.CLI_OBSPEDIDO */,
    CLI_EMAILFINANC VARCHAR(60) /* TYPE OF COLUMN CLIENTES.CLI_EMAILFINANC */,
    CLI_SKYPE VARCHAR(150) /* TYPE OF COLUMN CLIENTES.CLI_SKYPE */,
    CLI_NOMRED VARCHAR(30) /* TYPE OF COLUMN CLIENTES.CLI_NOMRED */,
    CLI_REGIMEEMP VARCHAR(1) /* TYPE OF COLUMN CLIENTES.CLI_REGIMEEMP */,
    CLI_REGIAO2 SMALLINT /* TYPE OF COLUMN CLIENTES.CLI_REGIAO2 */,
    CLI_VENDEDOR INTEGER,
    CLI_REGIAOATU VARCHAR(50),
    ANI_NIVER DATE,
    CLI_IDCIDADE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELCLIIND (
    IFOR INTEGER,
    IVEND INTEGER)
RETURNS (
    CLI_NOME VARCHAR(75),
    CLI_FONE1 VARCHAR(20),
    CLI_CIDADE VARCHAR(25),
    CLI_EMAIL VARCHAR(200),
    CLI_CNPJ VARCHAR(18),
    TOTAL DOUBLE PRECISION,
    DATA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELFATPENDENDE (
    IFOR INTEGER,
    IFLAG BOOLEAN)
RETURNS (
    FAT_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    PED_TOTLIQ DOUBLE PRECISION,
    CLI_NOMRED VARCHAR(30),
    FOR_NOMERED VARCHAR(15),
    FATURADO DOUBLE PRECISION,
    PED_CONDPAG VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELFATURAMENTOS (
    IFOR INTEGER,
    IVEN INTEGER,
    IDT1 DATE,
    IDT2 DATE)
RETURNS (
    VEN_NOME VARCHAR(45),
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    FAT_PEDIDO VARCHAR(10),
    FAT_DATAFAT DATE,
    FAT_VALORFAT DOUBLE PRECISION,
    FAT_NF VARCHAR(10),
    FAT_PERCENT DOUBLE PRECISION,
    FAT_COMISSAO DOUBLE PRECISION,
    PED_TOTLIQ DOUBLE PRECISION,
    PED_DATA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELITENS (
    IFOR INTEGER,
    ITABELA VARCHAR(20))
RETURNS (
    PRO_CODIGO INTEGER,
    PRO_CODPROD VARCHAR(25),
    PRO_CODORIGINAL VARCHAR(40),
    PRO_NOME VARCHAR(100),
    PRO_VALORNORMAL DOUBLE PRECISION,
    PRO_VALORPROMO DOUBLE PRECISION,
    PRO_INDUSTRIA INTEGER,
    PRO_PRECO3 DOUBLE PRECISION,
    ITE_CONVERSAO VARCHAR(300),
    PRO_IPI DOUBLE PRECISION,
    PRO_ST DOUBLE PRECISION,
    PRE_LIQ DOUBLE PRECISION,
    PRO_APLICACAO2 VARCHAR(800),
    PRO_EMBALAGEM INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELITENSCOMDESCONTO (
    IFOR INTEGER,
    ITABELA VARCHAR(20),
    IDES1 DOUBLE PRECISION,
    IDES2 DOUBLE PRECISION,
    IDES3 DOUBLE PRECISION,
    IDES4 DOUBLE PRECISION,
    IDES5 DOUBLE PRECISION,
    IDES6 DOUBLE PRECISION,
    IDES7 DOUBLE PRECISION,
    IDES8 DOUBLE PRECISION,
    IDES9 DOUBLE PRECISION)
RETURNS (
    PRO_CODIGO INTEGER,
    PRO_CODPROD VARCHAR(25),
    PRO_CODORIGINAL VARCHAR(40),
    PRO_NOME VARCHAR(100),
    PRO_VALORNORMAL DOUBLE PRECISION,
    PRO_VALORPROMO DOUBLE PRECISION,
    PRO_INDUSTRIA INTEGER,
    PRO_PRECO3 DOUBLE PRECISION,
    ITE_CONVERSAO VARCHAR(300),
    PRO_IPI DOUBLE PRECISION,
    PRO_ST DOUBLE PRECISION,
    PRE_LIQ DOUBLE PRECISION,
    PRO_APLICACAO2 VARCHAR(800),
    PRO_EMBALAGEM INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELPRODPED (
    IFOR INTEGER,
    ITAB VARCHAR(20))
RETURNS (
    ID INTEGER,
    CODIND INTEGER,
    CODIGO VARCHAR(25),
    CONVERSAO VARCHAR(300),
    NOME VARCHAR(100),
    PRECO1 DOUBLE PRECISION,
    PRECO2 DOUBLE PRECISION,
    PRECO3 DOUBLE PRECISION,
    DATATAB DATE,
    EMBALAGEM INTEGER,
    DATAPROMO DATE,
    IPI DOUBLE PRECISION,
    CODIGO2 VARCHAR(25),
    LINHA VARCHAR(50),
    GRUPODES INTEGER,
    DESCADIC DOUBLE PRECISION,
    ST DOUBLE PRECISION,
    GRUPOPRO INTEGER,
    NOMETABELA VARCHAR(20),
    DESCADIC2 DOUBLE PRECISION,
    PESO DOUBLE PRECISION,
    PREPESO DOUBLE PRECISION,
    STATUS CHAR(1),
    APLICACAO VARCHAR(800))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELTELEPORIND (
    XDATA1 DATE,
    XDATA2 DATE,
    XIND1 INTEGER,
    XOPE INTEGER)
RETURNS (
    AGE_LANCTO INTEGER,
    AGE_DATA DATE,
    AGE_CLIENTE INTEGER,
    AGE_HORARIO VARCHAR(5),
    AGE_STATUS VARCHAR(1),
    AGE_OBS VARCHAR(1800),
    AGE_INDUSTRIA INTEGER,
    AGE_TELEFONE VARCHAR(35),
    AGE_CONTATO VARCHAR(35),
    AGE_OPERADOR VARCHAR(35),
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    CLI_CIDADE VARCHAR(25),
    CLI_CNPJ VARCHAR(18),
    CLI_FONE1 VARCHAR(20),
    METACOMPLETADA DOUBLE PRECISION,
    LIGACOES INTEGER,
    METAIND INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RELVENDAS (
    IFOR INTEGER,
    ICLI INTEGER,
    IVEND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IFLAG CHAR(1))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    FOR_NOME VARCHAR(75),
    CLI_NOME VARCHAR(50),
    PED_TOTLIQ DOUBLE PRECISION,
    VALORFAT DOUBLE PRECISION,
    PED_TOTBRUTO DOUBLE PRECISION,
    CLI_CIDADE VARCHAR(25),
    CLI_UF VARCHAR(2),
    NUMPEDCLI VARCHAR(15),
    NUMPEDIND VARCHAR(15))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_RETIRALETRASCOD (
    PTEXTO VARCHAR(20))
RETURNS (
    OLIMPO VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_SELLOUT (
    IFOR INTEGER,
    IANO INTEGER,
    ICLI INTEGER)
RETURNS (
    ROTINA VARCHAR(20),
    VALOR DOUBLE PRECISION,
    QUANT INTEGER,
    MES DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_SOMATOTAIS (
    IFOR INTEGER,
    IPED VARCHAR(10))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_TRANSPORTADORA (
    IPESQ VARCHAR(60))
RETURNS (
    ID INTEGER,
    NOME VARCHAR(60),
    TELEFONE VARCHAR(15),
    CIDADE VARCHAR(25))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_VENDAPROD (
    IFOR INTEGER,
    ICLI INTEGER,
    IVEND INTEGER,
    IPROD VARCHAR(25),
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    ITE_PRODUTO VARCHAR(25),
    ITE_NOMEPROD VARCHAR(100),
    ITE_EMBUCH VARCHAR(15),
    QUANT DOUBLE PRECISION,
    PRECO DOUBLE PRECISION,
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    CLI_NOMRED VARCHAR(30),
    PRECOLIQ DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_VENDAPRODGRP (
    IFOR INTEGER,
    ICLI INTEGER,
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    ITE_PRODUTO VARCHAR(25),
    ITE_NOMEPROD VARCHAR(100),
    QUANT DOUBLE PRECISION,
    PRECO DOUBLE PRECISION,
    GRU_NOME VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_VENDEDORIND (
    IVENDEDOR INTEGER)
RETURNS (
    VIN_INDUSTRIA INTEGER,
    VIN_CODIGO INTEGER,
    VIN_PERCOM DOUBLE PRECISION,
    FOR_NOMERED VARCHAR(15))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_ZERARVALORESTAB (
    IIND INTEGER,
    ITAB VARCHAR(25),
    IFLAG CHAR(2),
    IVALOR DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PWBI_ATUACAO
RETURNS (
    ATU_ID INTEGER,
    ATU_DESCRICAO VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_BRIDGEPROD
RETURNS (
    IDPROD INTEGER,
    CODPROD VARCHAR(25),
    IDINDUSTRIA INTEGER,
    IDGRUPO INTEGER,
    LINHALEVE CHAR(1),
    LINHAPESADA CHAR(1),
    LINHAAGRICOLA CHAR(1),
    LINHAUTILITARIOS CHAR(1),
    LINHAOFFROAD CHAR(1),
    CATEGORIA VARCHAR(35),
    FAMILIA VARCHAR(35))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_CLIENTES
RETURNS (
    CLI_NOMERED VARCHAR(30),
    CLI_CODIGO INTEGER,
    CLI_REDELOJA VARCHAR(35),
    ATUACAO VARCHAR(60),
    CLI_ATUACAOPRINCIPAL INTEGER,
    CLI_REGIAO SMALLINT,
    CLI_UF VARCHAR(2),
    CLI_VENDEDOR INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_CRM (
    IANO_INI DATE,
    IANO_FIM DATE)
RETURNS (
    AGE_CLIENTE INTEGER,
    AGE_INDUSTRIA INTEGER,
    AGE_DATA DATE,
    AGE_HORARIO VARCHAR(10),
    AGE_STATUS CHAR(1),
    AGE_TIPONTERACAO CHAR(30),
    AGE_TOPICO VARCHAR(25),
    AGE_TIPOVISITA CHAR(1),
    AGE_TIPOPROSPECCAO CHAR(1),
    VEN_NOME VARCHAR(45))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_EMPRESA
RETURNS (
    EMP_LOGOTIPO VARCHAR(200),
    EMP_NOME VARCHAR(50),
    EMP_ID INTEGER,
    EMP_GENERICO VARCHAR(200))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_FATURAMENTO (
    IANO_INI DATE,
    IANO_FIM DATE)
RETURNS (
    FAT_PEDIDO VARCHAR(10),
    FAT_INDUSTRIA INTEGER,
    FAT_VALORFAT DOUBLE PRECISION,
    FAT_DATAFAT DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_GRUPOS
RETURNS (
    GRU_CODIGO INTEGER,
    GRU_NOME VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_INDUSTRIAS
RETURNS (
    FOR_CODIGO INTEGER,
    FOR_NOMERED VARCHAR(15),
    FOR_HOMEPAGE VARCHAR(150))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_ITENSPED (
    IANO_INI DATE,
    IANO_FIM DATE)
RETURNS (
    ITE_PEDIDO VARCHAR(10),
    PRODUTO VARCHAR(25),
    PED_INDUSTRIA INTEGER,
    PED_CLIENTE INTEGER,
    PED_VENDEDOR INTEGER,
    ITE_QUANT DOUBLE PRECISION,
    ITE_TOTLIQUIDO NUMERIC(15,2),
    PED_DATA DATE,
    GRU_CODIGO INTEGER,
    PED_DATA2 DATE,
    ITE_IDPRODUTO INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_METASIND
RETURNS (
    MET_INDUSTRIA INTEGER,
    MET_VALOR DOUBLE PRECISION,
    MET_DATA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_METASVEND
RETURNS (
    MET_VENDEDOR INTEGER,
    MET_INDUSTRIA INTEGER,
    MET_VALOR DOUBLE PRECISION,
    MET_DATA DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_PEDIDOS (
    IANO_INI DATE,
    IANO_FIM DATE)
RETURNS (
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    PED_SITUACAO CHAR(1),
    PED_INDUSTRIA INTEGER,
    PED_VENDEDOR INTEGER,
    PED_CLIENTE INTEGER,
    VALOR_PED DOUBLE PRECISION,
    QTD_PED DOUBLE PRECISION,
    QTD_FAT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_PRODUTOS
RETURNS (
    PRO_CODPROD VARCHAR(25),
    PRO_INDUSTRIA INTEGER,
    PRO_GRUPOPRO INTEGER,
    CONTAGEM INTEGER,
    PRO_LINHA VARCHAR(50),
    PRO_CURVA CHAR(1),
    PRO_CHAVECOMBINADA VARCHAR(40),
    PRO_CATEGORIA VARCHAR(25),
    PRO_IDPROD INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_REGIOES
RETURNS (
    REG_CODIGO INTEGER,
    REG_NOME VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PWBI_VENDEDORES
RETURNS (
    VEN_CODIGO INTEGER,
    VEN_NOME VARCHAR(45),
    VEN_NOMEUSU VARCHAR(50),
    VEN_IMAGEM VARCHAR(200))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_ATZCIDADES
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_ATZGENS
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_ATZREGIOES
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_BALANCETE (
    PDT1 DATE,
    PDT2 DATE)
RETURNS (
    CON_GRAU VARCHAR(10),
    CON_DESCRICAO VARCHAR(50),
    SALDOINI DOUBLE PRECISION,
    ENTRADA DOUBLE PRECISION,
    SAIDA DOUBLE PRECISION,
    SALDO DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_BLOBEMPARTES (
    PBLOB BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    PDELIMITADOR CHAR(1))
RETURNS (
    IDX INTEGER,
    PARTE VARCHAR(30000))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_CADTABELA (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    P_ROTINA CHAR(1))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CALC_PERC_CLIATIVO_CLIMES
RETURNS (
    INDUSTRIA VARCHAR(20),
    CLIGERAL INTEGER,
    CLIMES INTEGER,
    PERCENTUAL DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_CALC_PERC_CRM_CLIMES
RETURNS (
    INDUSTRIA VARCHAR(20),
    CLIGERAL INTEGER,
    CLIMES INTEGER,
    PERCENTUAL DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_CALDESEMPENHO (
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    OVENDADIA DOUBLE PRECISION,
    OVENDAMES DOUBLE PRECISION,
    OTICKETMEDIO DOUBLE PRECISION,
    OCLIATENDIDOS INTEGER,
    OPERFATHOJE DOUBLE PRECISION,
    OPERFATMES DOUBLE PRECISION,
    OPERTICKET DOUBLE PRECISION,
    OPERATENDIMENTO DOUBLE PRECISION,
    OATENDULTSEMANA INTEGER,
    OPERCATENDULTSEM DOUBLE PRECISION,
    QTDCLIVENDAS INTEGER,
    PERCCLIVENDAS DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_CALLIQPROD (
    P_BRUTO DOUBLE PRECISION,
    P_DES1 DOUBLE PRECISION,
    P_DES2 DOUBLE PRECISION,
    P_DES3 DOUBLE PRECISION,
    P_DES4 DOUBLE PRECISION,
    P_DES5 DOUBLE PRECISION,
    P_DES6 DOUBLE PRECISION,
    P_DES7 DOUBLE PRECISION,
    P_DES8 DOUBLE PRECISION,
    P_DES9 DOUBLE PRECISION)
RETURNS (
    RESULTADO DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_CURVA_01 (
    PDATA1 DATE,
    PDATA2 DATE,
    PIND INTEGER,
    PUF CHAR(2),
    PIND2 INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CURVA_02 (
    PDATA1 DATE,
    PDATA2 DATE,
    PCLI INTEGER,
    PUF CHAR(2),
    PCLI2 INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CURVA_03 (
    PDATA1 DATE,
    PDATA2 DATE,
    PCLI INTEGER,
    PCLI2 INTEGER,
    PIND INTEGER,
    PUF VARCHAR(2),
    PGRUPOPRO INTEGER,
    PGRUPOLOJA BOOLEAN)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CURVA_04 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE,
    PCLI INTEGER,
    PCLI2 INTEGER,
    PUF VARCHAR(2))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CURVA_05 (
    PDATA1 DATE,
    PDATA2 DATE,
    PIND INTEGER,
    PUF VARCHAR(2))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CURVA_06 (
    PDATA1 DATE,
    PDATA2 DATE,
    PCLI INTEGER,
    PIND INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CURVA_07 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE,
    PGRP INTEGER,
    PCLI INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CURVA_08 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE,
    PRLJ VARCHAR(35))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CURVA_09 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_CURVA_10 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE,
    PVENDEDOR INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_DEL_ITE_PED (
    IIND INTEGER,
    IPRO VARCHAR(25),
    IEMB VARCHAR(25),
    IPED VARCHAR(10))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_DELETA_PROD_DUPL (
    ITABELA VARCHAR(20),
    IFOR INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_DELETAITEMPED (
    IIND INTEGER,
    IPED VARCHAR(10))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_DRE (
    PDT1 DATE,
    PDT2 DATE)
RETURNS (
    CON_CODIGO INTEGER,
    CON_DESCRICAO VARCHAR(50),
    CON_GRAU VARCHAR(10),
    TOTAL_CONTA DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_FLUXO (
    CODCONTA INTEGER,
    INICIO DATE,
    FIM DATE)
RETURNS (
    LANCAMENTO INTEGER,
    TIPO VARCHAR(10),
    CLIFOR VARCHAR(60),
    CREDITO NUMERIC(15,2),
    DEBITO NUMERIC(15,2),
    DATALANCAMENTO DATE,
    DESCRICAO VARCHAR(300),
    CONTA VARCHAR(80))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_FLUXOPREV (
    CODCONTA INTEGER,
    INICIO DATE,
    FIM DATE)
RETURNS (
    LANCAMENTO INTEGER,
    TIPO VARCHAR(10),
    CLIFOR VARCHAR(60),
    CREDITO NUMERIC(15,2),
    DEBITO NUMERIC(15,2),
    DATALANCAMENTO DATE,
    DESCRICAO VARCHAR(300),
    CONTA VARCHAR(80))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_IMPTABELA (
    PBLOB BLOB SUB_TYPE TEXT SEGMENT SIZE 80)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_INS_CAIXA
RETURNS (
    OCHAVE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_INS_CLIENTES
RETURNS (
    OCHAVE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_INS_CREDDEV
RETURNS (
    OCHAVE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_INS_FORMAPG
RETURNS (
    OCHAVE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_INS_GRUPOPRO
RETURNS (
    OCHAVE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_INS_GRUPOPRODES
RETURNS (
    OCHAVE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_INS_INDUSTRIA
RETURNS (
    OCHAVE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_INS_TRANSP
RETURNS (
    OCHAVE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_INSEREPEDIDO (
    IPEDIDO VARCHAR(10),
    INUMPED INTEGER,
    IDATA DATE,
    IINDUSTRIA INTEGER,
    ICLIENTE INTEGER,
    ITRANSP INTEGER,
    IVENDEDOR INTEGER,
    ITABELA VARCHAR(20),
    ICONDPAG VARCHAR(100),
    ISITUACAO VARCHAR(1),
    ITIPOFRETE VARCHAR(1),
    IEXPORTADO VARCHAR(1),
    ICOMPRADOR VARCHAR(30),
    IEMAILCOMP VARCHAR(60),
    IPRI DOUBLE PRECISION,
    ISEG DOUBLE PRECISION,
    ITER DOUBLE PRECISION,
    IQUA DOUBLE PRECISION,
    IQUI DOUBLE PRECISION,
    ISEX DOUBLE PRECISION,
    ISET DOUBLE PRECISION,
    IOIT DOUBLE PRECISION,
    INOV DOUBLE PRECISION,
    IDEZ DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_INSERIR_REPL (
    PDADOS VARCHAR(31900))
RETURNS (
    SQL VARCHAR(2000))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_MONTA_CURVA (
    PIND INTEGER,
    VINDEXCURVA INTEGER,
    VFILTRO CHAR(1),
    PDATA1 DATE,
    PDATA2 DATE,
    PUF CHAR(2),
    PCLI INTEGER,
    PGRP INTEGER,
    PGRUPOLOJA BOOLEAN)
RETURNS (
    DESCRICAO VARCHAR(50),
    QUANTIDADE DOUBLE PRECISION,
    VALOR DOUBLE PRECISION,
    PERCENTUAL DOUBLE PRECISION,
    ACUMULADO DOUBLE PRECISION,
    CLASSIFICACAO VARCHAR(1),
    GERAL DOUBLE PRECISION,
    CONVERSAO VARCHAR(25),
    PERC DOUBLE PRECISION,
    PERCQTD DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_MONTAREPLICADOR (
    ITABELAS VARCHAR(2000))
RETURNS (
    VVALOR VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_MONTATABELAS (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_PORTIFOLIO_VENDAS (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    IDFOR INTEGER,
    NOME VARCHAR(30),
    PORTIFOLIO INTEGER,
    VENDAS INTEGER,
    PERCENTUAL NUMERIC(6,2))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_QUEBRABLOB (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80)
RETURNS (
    CIND VARCHAR(3),
    CDESCONTO VARCHAR(3),
    CGRUPOPROD VARCHAR(3),
    CTABELA VARCHAR(20),
    CDATATAB VARCHAR(10),
    CVENCPROMO VARCHAR(10),
    CSTATUS VARCHAR(50),
    CCODIGO VARCHAR(25),
    CDESCR VARCHAR(50),
    CPRECO1 VARCHAR(10),
    CPRECO2 VARCHAR(10),
    CPRECO3 VARCHAR(10),
    CDBARRAS VARCHAR(13),
    CPESO VARCHAR(10),
    CAPLIC VARCHAR(100),
    CEMBAL VARCHAR(10),
    CST VARCHAR(10),
    CIPI VARCHAR(10),
    CCODORI VARCHAR(40),
    CPREPESO VARCHAR(10),
    CCONVERSAO VARCHAR(300),
    CDESCESPEC VARCHAR(10),
    CNCM VARCHAR(10),
    CDESCADD VARCHAR(10),
    CCODIGO2 VARCHAR(25),
    CPERCOMGRUPO VARCHAR(10),
    CSETOR VARCHAR(35))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_RAZAO (
    PDT1 DATE,
    PDT2 DATE)
RETURNS (
    CON_CODIGO INTEGER,
    CON_TIPO VARCHAR(1),
    CON_GRAU VARCHAR(10),
    CON_DESCRICAO VARCHAR(50),
    TOTAL_CONTA DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_RECEBEPRODUTOS (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_RECEBETABELA (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    P_ROTINA CHAR(1))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_REL_CLIENTES_YTD (
    MES_REFERENCIA INTEGER,
    ANO_REFERENCIA INTEGER,
    IFOR INTEGER,
    IREDE BOOLEAN)
RETURNS (
    CLIENTE VARCHAR(30),
    VALOR_ANT DOUBLE PRECISION,
    QTD_ANT DOUBLE PRECISION,
    VALOR_ATU DOUBLE PRECISION,
    QTD_ATU DOUBLE PRECISION,
    PERC_VAL DOUBLE PRECISION,
    PERC_QTD DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_RELCRMPORIND (
    XDATA1 DATE,
    XDATA2 DATE,
    XIND1 INTEGER)
RETURNS (
    AGE_LANCTO INTEGER,
    AGE_DATA DATE,
    AGE_CLIENTE INTEGER,
    AGE_HORARIO VARCHAR(5),
    AGE_STATUS VARCHAR(1),
    AGE_OBS VARCHAR(1800),
    AGE_INDUSTRIA INTEGER,
    AGE_TELEFONE VARCHAR(35),
    AGE_CONTATO VARCHAR(35),
    AGE_OPERADOR VARCHAR(35),
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    CLI_CIDADE VARCHAR(25),
    CLI_CNPJ VARCHAR(18),
    CLI_FONE1 VARCHAR(20),
    METACOMPLETADA DOUBLE PRECISION,
    LIGACOES INTEGER,
    METAIND INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SAMEPERIOD_3YARS (
    IANO INTEGER)
RETURNS (
    OANO INTEGER,
    OMES VARCHAR(10),
    OQTD INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SAMEPERIOD_QTD (
    IANO INTEGER)
RETURNS (
    OANO INTEGER,
    OMES VARCHAR(10),
    OVALOR INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SAMEPERIOD_VALANO (
    IANO INTEGER)
RETURNS (
    OANO INTEGER,
    OMES VARCHAR(10),
    OVALOR DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SAMEPERIOD_VALOR (
    IANO INTEGER)
RETURNS (
    OANO INTEGER,
    OMES VARCHAR(10),
    OVALOR DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SPLIT_RECEBER (
    PTEXTO VARCHAR(32000),
    PDELIMITADOR CHAR(1))
RETURNS (
    IDX INTEGER,
    LINHA VARCHAR(2000))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_SPLITSTRING (
    PTEXTO VARCHAR(30000),
    PDELIMITADOR CHAR(1))
RETURNS (
    IDX INTEGER,
    TEXTO VARCHAR(500))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_STATUSTRIGGERS (
    ISTATUS INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SP_TEMP (
    ITABELA VARCHAR(30))
RETURNS (
    VCAMPOS VARCHAR(800))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_TOP10_FOR (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    OIDCLI INTEGER,
    ONOME VARCHAR(15),
    OVALOR DOUBLE PRECISION,
    OCOR VARCHAR(12))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_TOP10_FOR_QTD (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    OIDCLI INTEGER,
    ONOME VARCHAR(15),
    OVALOR DOUBLE PRECISION,
    OCOR VARCHAR(12))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_TOP10_QTD (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    OIDCLI INTEGER,
    ONOME VARCHAR(30),
    OVALOR DOUBLE PRECISION,
    OCOR VARCHAR(12))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_TOP10_VAL (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    OIDCLI INTEGER,
    ONOME VARCHAR(30),
    OVALOR DOUBLE PRECISION,
    OCOR VARCHAR(12))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SP_TOTALIZA_CONTAS (
    PDATAINI DATE,
    PDATAFIM DATE)
RETURNS (
    ID INTEGER,
    ID_PAI INTEGER,
    GRAU VARCHAR(8),
    DESCRICAO VARCHAR(50),
    TOTAL NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE TRANSF_DADOS_CLIENTES (
    VTABELA VARCHAR(20))
RETURNS (
    SQL VARCHAR(32000))
AS
BEGIN
  SUSPEND;
END^






SET TERM ; ^



/******************************************************************************/
/****                           Stored functions                           ****/
/******************************************************************************/



SET TERM ^ ;

CREATE FUNCTION FN_NORMALIZAR_CNPJ (
    CODIGO VARCHAR(50))
RETURNS VARCHAR(50)
AS
BEGIN
  RETURN NULL;
END^





CREATE FUNCTION FN_NORMALIZAR_CODIGO (
    CODIGO VARCHAR(50))
RETURNS VARCHAR(50)
AS
BEGIN
  RETURN NULL;
END^






SET TERM ; ^



/******************************************************************************/
/****                                Tables                                ****/
/******************************************************************************/



CREATE TABLE AGENDA (
    AGE_LANCTO         INTEGER NOT NULL,
    AGE_DATA           TIMESTAMP NOT NULL,
    AGE_HORARIO        VARCHAR(5) NOT NULL,
    AGE_STATUS         VARCHAR(1),
    AGE_CLIENTE        INTEGER NOT NULL,
    AGE_OBS            BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    AGE_INDUSTRIA      INTEGER NOT NULL,
    AGE_NOMECLI        VARCHAR(65),
    AGE_TELEFONE       VARCHAR(35),
    AGE_CONTATO        VARCHAR(35),
    AGE_OPERADOR       VARCHAR(25) NOT NULL,
    AGE_ASSUNTO        VARCHAR(1800),
    AGE_TOPICO         VARCHAR(25),
    AGE_SEQ            INTEGER,
    GID                VARCHAR(38),
    AGE_TIPOINTERACAO  CHAR(1)
);

CREATE TABLE AREA_ATU (
    ATU_ID         INTEGER NOT NULL,
    ATU_DESCRICAO  VARCHAR(60) NOT NULL,
    ATU_SEL        VARCHAR(1),
    GID            VARCHAR(38)
);

CREATE TABLE ATUA_CLI (
    ATU_IDCLI   INTEGER NOT NULL,
    ATU_ATUAID  INTEGER NOT NULL,
    ATU_SEL     VARCHAR(1),
    GID         VARCHAR(38)
);

CREATE TABLE BAIXAXML (
    NUMPED     VARCHAR(15) NOT NULL,
    CODPROD    VARCHAR(25) NOT NULL,
    QTDFAT     INTEGER,
    VALUNIT    DOUBLE PRECISION,
    TOTPROD    DOUBLE PRECISION,
    SEQUENCIA  INTEGER
);

CREATE TABLE BANDEIRA (
    CODIGO     INTEGER NOT NULL,
    DESCRICAO  VARCHAR(50),
    ATIVO      VARCHAR(1)
);

CREATE TABLE CAD_PROD (
    PRO_ID                 INTEGER NOT NULL,
    PRO_INDUSTRIA          INTEGER NOT NULL,
    PRO_CODPROD            VARCHAR(25),
    PRO_CODIGOORIGINAL     VARCHAR(50),
    PRO_CODIGONORMALIZADO  VARCHAR(40),
    PRO_NOME               VARCHAR(100),
    PRO_PRODUTOLANCAMENTO  BOOLEAN,
    PRO_DATALANCAMENTO     DATE,
    PRO_CURVAINDUSTRIA     CHAR(1),
    PRO_CODBARRAS          VARCHAR(13),
    PRO_GRUPO              INTEGER,
    PRO_SETOR              VARCHAR(30),
    PRO_LINHA              VARCHAR(50),
    PRO_EMBALAGEM          INTEGER,
    PRO_PESO               DOUBLE PRECISION,
    PRO_CONVERSAO          VARCHAR(300),
    PRO_NCM                VARCHAR(10),
    PRO_APLICACAO          VARCHAR(300),
    PRO_APLICACAO2         VARCHAR(800),
    PRO_LINHALEVE          BOOLEAN,
    PRO_LINHAPESADA        BOOLEAN,
    PRO_LINHAAGRICOLA      BOOLEAN,
    PRO_LINHAUTILITARIOS   BOOLEAN,
    PRO_OFFROAD            BOOLEAN,
    PRO_STATUS             BOOLEAN,
    PRO_MOTOCICLETAS       BOOLEAN,
    PRO_ORIGEM             CHAR(1)
);

CREATE TABLE CAD_TABELASPRE (
    ITAB_IDPROD          INTEGER NOT NULL,
    ITAB_IDINDUSTRIA     INTEGER NOT NULL,
    ITAB_TABELA          VARCHAR(20) NOT NULL,
    ITAB_GRUPODESCONTO   INTEGER,
    ITAB_DESCONTOADD     DOUBLE PRECISION,
    ITAB_IPI             DOUBLE PRECISION,
    ITAB_ST              DOUBLE PRECISION,
    ITAB_PREPESO         DOUBLE PRECISION,
    ITAB_PRECOBRUTO      DOUBLE PRECISION,
    ITAB_PRECOPROMO      DOUBLE PRECISION,
    ITAB_PRECOESPECIAL   DOUBLE PRECISION,
    ITAB_DATATABELA      DATE,
    ITAB_DATAVENCIMENTO  DATE,
    ITAB_STATUS          BOOLEAN
);

CREATE TABLE CAIXA (
    CAI_LANCAMENTO   INTEGER NOT NULL,
    CAI_DATA         DATE,
    CAI_CONTA        INTEGER,
    CAI_DC           VARCHAR(1),
    CAI_VALOR        DOUBLE PRECISION,
    CAI_OPERADOR     VARCHAR(20),
    CAI_HISTORICO    VARCHAR(200),
    CAI_CLIFOR       INTEGER,
    CAI_CLIFORNOME   VARCHAR(60),
    CAI_CONTADEBITO  INTEGER,
    CAI_CCUSTO       INTEGER,
    CAI_IDORIGEM     INTEGER,
    CAI_FLAG         CHAR(2)
);

CREATE TABLE CCUSTOS (
    CC_ID         INTEGER NOT NULL,
    CC_DESCRICAO  VARCHAR(60)
);

CREATE TABLE CIDADES (
    CODIGO  INTEGER NOT NULL,
    CODMUN  INTEGER,
    CODUF   INTEGER,
    NOME    VARCHAR(60),
    UF      VARCHAR(2)
);

CREATE TABLE CIDADES_REGIOES (
    REG_ID  INTEGER NOT NULL,
    CID_ID  INTEGER NOT NULL
);

CREATE TABLE CLI_ANIV (
    ANI_CLIENTE  SMALLINT NOT NULL,
    ANI_NOME     VARCHAR(55) NOT NULL,
    ANI_FUNCAO   VARCHAR(35) NOT NULL,
    ANI_FONE     VARCHAR(15),
    ANI_EMAIL    VARCHAR(60),
    ANI_DIAANIV  SMALLINT,
    ANI_MES      SMALLINT,
    ANI_NIVER    DATE,
    ANI_LANCTO   INTEGER,
    ANI_OBS      VARCHAR(600),
    ANI_SEL      CHAR(1),
    GID          VARCHAR(38)
);

CREATE TABLE CLI_DESCPRO (
    CLI_CODIGO     INTEGER NOT NULL,
    CLI_FORCODIGO  INTEGER NOT NULL,
    CLI_GRUPO      INTEGER NOT NULL,
    CLI_DESC1      DOUBLE PRECISION,
    CLI_DESC2      DOUBLE PRECISION,
    CLI_DESC3      DOUBLE PRECISION,
    CLI_DESC4      DOUBLE PRECISION,
    CLI_DESC5      DOUBLE PRECISION,
    CLI_DESC6      DOUBLE PRECISION,
    CLI_DESC7      DOUBLE PRECISION,
    CLI_DESC8      DOUBLE PRECISION,
    CLI_DESC9      DOUBLE PRECISION,
    GID            VARCHAR(38)
);

CREATE TABLE CLI_IND (
    CLI_LANCAMENTO      INTEGER,
    CLI_CODIGO          INTEGER NOT NULL,
    CLI_FORCODIGO       INTEGER NOT NULL,
    CLI_DESC1           DOUBLE PRECISION,
    CLI_DESC2           DOUBLE PRECISION,
    CLI_DESC3           DOUBLE PRECISION,
    CLI_DESC4           DOUBLE PRECISION,
    CLI_DESC5           DOUBLE PRECISION,
    CLI_DESC6           DOUBLE PRECISION,
    CLI_DESC7           DOUBLE PRECISION,
    CLI_DESC8           DOUBLE PRECISION,
    CLI_DESC9           DOUBLE PRECISION,
    CLI_DESC10          DOUBLE PRECISION,
    CLI_TRANSPORTADORA  INTEGER,
    CLI_PRAZOPG         VARCHAR(20),
    CLI_IPI             INTEGER,
    CLI_TABELA          VARCHAR(20),
    CLI_CODCLIIND       VARCHAR(15),
    CLI_OBSPARTICULAR   VARCHAR(600),
    CLI_COMPRADOR       VARCHAR(50),
    GID                 VARCHAR(38),
    CLI_FRETE           CHAR(1),
    CLI_EMAILCOMPRADOR  VARCHAR(100),
    CLI_DESC11          DOUBLE PRECISION
);

CREATE TABLE CLIENTES (
    CLI_CODIGO            INTEGER NOT NULL,
    CLI_CNPJ              VARCHAR(18) NOT NULL,
    CLI_INSCRICAO         VARCHAR(18),
    CLI_TIPOPES           VARCHAR(1),
    CLI_NOME              VARCHAR(75),
    CLI_NOMRED            VARCHAR(30),
    CLI_FANTASIA          VARCHAR(45),
    CLI_ENDERECO          VARCHAR(200),
    CLI_ENDNUM            VARCHAR(15),
    CLI_COMPENDERECO      VARCHAR(50),
    CLI_BAIRRO            VARCHAR(100),
    CLI_CIDADE            VARCHAR(25),
    CLI_UF                VARCHAR(2),
    CLI_CEP               VARCHAR(11),
    CLI_PTOREF            VARCHAR(250),
    CLI_FONE1             VARCHAR(20),
    CLI_FONE2             VARCHAR(20),
    CLI_FONE3             VARCHAR(20),
    CLI_ENDCOB            VARCHAR(45),
    CLI_BAICOB            VARCHAR(25),
    CLI_CIDCOB            VARCHAR(25),
    CLI_CEPCOB            VARCHAR(11),
    CLI_UFCOB             VARCHAR(2),
    CLI_EMAIL             VARCHAR(200),
    CLI_EMAILNFE          VARCHAR(60),
    CLI_SKYPE             VARCHAR(150),
    CLI_REFCOME           VARCHAR(600),
    CLI_SUFRAMA           VARCHAR(15),
    CLI_VENCSUF           DATE,
    CLI_CAIXAPOSTAL       VARCHAR(20),
    CLI_OBS               VARCHAR(800),
    CLI_OBSPEDIDO         VARCHAR(300),
    CLI_EMAILFINANC       VARCHAR(60),
    CLI_VENDEDOR          SMALLINT,
    CLI_REGIMEEMP         VARCHAR(1),
    CLI_REGIAO2           SMALLINT,
    CLI_ATUACAO           VARCHAR(1),
    CLI_REDELOJA          VARCHAR(35),
    CLI_DATACAD           DATE,
    CLI_USUARIO           VARCHAR(25),
    CLI_DATAALT           DATE,
    CLI_IMP               VARCHAR(1),
    CLI_IDCIDADE          INTEGER,
    CLI_DATAABERTURA      DATE,
    CLI_ATUACAOPRINCIPAL  INTEGER,
    GID                   VARCHAR(38)
);

CREATE TABLE CLIENTES2 (
    CLI_CODIGO            INTEGER NOT NULL,
    CLI_CNPJ              VARCHAR(18) NOT NULL,
    CLI_INSCRICAO         VARCHAR(18),
    CLI_TIPOPES           VARCHAR(1),
    CLI_NOME              VARCHAR(75),
    CLI_NOMRED            VARCHAR(30),
    CLI_FANTASIA          VARCHAR(45),
    CLI_ENDERECO          VARCHAR(200),
    CLI_ENDNUM            VARCHAR(15),
    CLI_COMPENDERECO      VARCHAR(50),
    CLI_BAIRRO            VARCHAR(100),
    CLI_CIDADE            VARCHAR(25),
    CLI_UF                VARCHAR(2),
    CLI_CEP               VARCHAR(11),
    CLI_PTOREF            VARCHAR(250),
    CLI_FONE1             VARCHAR(20),
    CLI_FONE2             VARCHAR(20),
    CLI_FONE3             VARCHAR(20),
    CLI_ENDCOB            VARCHAR(45),
    CLI_BAICOB            VARCHAR(25),
    CLI_CIDCOB            VARCHAR(25),
    CLI_CEPCOB            VARCHAR(11),
    CLI_UFCOB             VARCHAR(2),
    CLI_EMAIL             VARCHAR(200),
    CLI_EMAILNFE          VARCHAR(60),
    CLI_SKYPE             VARCHAR(50),
    CLI_REFCOME           VARCHAR(600),
    CLI_SUFRAMA           VARCHAR(15),
    CLI_VENCSUF           DATE,
    CLI_CAIXAPOSTAL       VARCHAR(20),
    CLI_OBS               VARCHAR(800),
    CLI_OBSPEDIDO         VARCHAR(300),
    CLI_EMAILFINANC       VARCHAR(60),
    CLI_VENDEDOR          SMALLINT,
    CLI_REGIMEEMP         VARCHAR(1),
    CLI_REGIAO2           SMALLINT,
    CLI_ATUACAO           VARCHAR(1),
    CLI_REDELOJA          VARCHAR(35),
    CLI_DATACAD           DATE,
    CLI_USUARIO           VARCHAR(25),
    CLI_DATAALT           DATE,
    CLI_IMP               VARCHAR(1),
    CLI_IDCIDADE          INTEGER,
    CLI_DATAABERTURA      DATE,
    CLI_ATUACAOPRINCIPAL  INTEGER,
    GID                   VARCHAR(38)
);

CREATE TABLE CONTAS (
    CON_CODIGO     SMALLINT NOT NULL,
    CON_CREDEV     VARCHAR(1),
    CON_DESCRICAO  VARCHAR(50),
    CON_GRAU       VARCHAR(10),
    CON_TIPO       VARCHAR(1),
    GID            VARCHAR(38),
    CON_SALDO      DOUBLE PRECISION,
    CON_IDPAI      INTEGER
);

CREATE TABLE CONTASPGREC (
    LAN_LANCTO       INTEGER NOT NULL,
    LAN_DOCTO        VARCHAR(15) NOT NULL,
    LAN_DATA         DATE,
    LAN_CREDEB       VARCHAR(1),
    LAN_CONTA        INTEGER,
    LAN_VALOR        NUMERIC(9,2),
    LAN_VALORPAGO    NUMERIC(9,2),
    LAN_DATAPAGO     DATE,
    LAN_CLIFOR       INTEGER NOT NULL,
    LAN_CLIFORNOME   VARCHAR(60),
    LAN_VENCIMENTO   DATE,
    LAN_GRAU         VARCHAR(9),
    LAN_NOSSONUMERO  VARCHAR(25),
    LAN_SEL          VARCHAR(1),
    LAN_ENVIAR       VARCHAR(1),
    LAN_DESCRICAO    VARCHAR(500),
    GID              VARCHAR(38),
    LAN_SALDODEV     DOUBLE PRECISION,
    LAN_PATHBOLETO   VARCHAR(300),
    LAN_FLAG         CHAR(1),
    LAN_PARCELA      INTEGER,
    LAN_CTACONTAB    INTEGER
);

CREATE TABLE CONTATO_FOR (
    CON_CODIGO   SMALLINT NOT NULL,
    CON_FORNEC   SMALLINT NOT NULL,
    CON_NOME     VARCHAR(45) NOT NULL,
    CON_GARGO    VARCHAR(25) NOT NULL,
    CON_FONE     VARCHAR(15),
    CON_CELULAR  VARCHAR(15),
    CON_EMAIL    VARCHAR(60),
    CON_DTNASC   DATE,
    GID          VARCHAR(38)
);

CREATE TABLE CONTROLE_REPL (
    REPL_ENV          INTEGER,
    REPL_REC          INTEGER,
    REPL_ULTIMOENVIO  DATE,
    REPL_ULTIMORECTO  DATE
);

CREATE TABLE CRED_DEV (
    CD_CODIGO    SMALLINT NOT NULL,
    CD_TIPO      VARCHAR(1),
    CD_NOME      VARCHAR(50),
    CD_ENDERECO  VARCHAR(50),
    CD_BAIRRO    VARCHAR(25),
    CD_CIDADE    VARCHAR(25),
    CD_UF        VARCHAR(2),
    CD_CEP       VARCHAR(11),
    CD_FONE      VARCHAR(20),
    CD_OBS       BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    GID          VARCHAR(38),
    CD_CPFCNPJ   VARCHAR(18),
    CD_ENDENUM   VARCHAR(10),
    CD_EMAIL     VARCHAR(100)
);

CREATE TABLE CRM (
    TELE_ID          INTEGER NOT NULL,
    TELE_CLIENTE     INTEGER NOT NULL,
    TELE_OBSGERAL    BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    TELE_OBSCLI      VARCHAR(800),
    GID              VARCHAR(38),
    TELE_IDOPERADOR  INTEGER
);

CREATE TABLE CRM_INTERACOES (
    AGE_LANCTO          INTEGER NOT NULL,
    AGE_DATA            DATE NOT NULL,
    AGE_HORARIO         VARCHAR(5) NOT NULL,
    AGE_STATUS          VARCHAR(1),
    AGE_TIPOINTERACAO   CHAR(1),
    AGE_CLIENTE         INTEGER NOT NULL,
    AGE_INDUSTRIA       INTEGER,
    AGE_NOMECLI         VARCHAR(65),
    AGE_TELEFONE        VARCHAR(35),
    AGE_CONTATO         VARCHAR(35),
    AGE_OPERADOR        VARCHAR(25) NOT NULL,
    AGE_ASSUNTO         VARCHAR(1800),
    AGE_TOPICO          VARCHAR(25),
    AGE_CRM             INTEGER,
    AGE_OBS             BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    GID                 VARCHAR(38),
    AGE_TIPOVISITA      CHAR(1),
    AGE_TIPOPROSPECCAO  CHAR(1)
);

CREATE TABLE CURVAABC (
    SEQ            INTEGER NOT NULL,
    DESCRICAO      VARCHAR(50),
    QUANTIDADE     DOUBLE PRECISION,
    VALOR          DOUBLE PRECISION,
    PERCENTUAL     DOUBLE PRECISION,
    ACUMULADO      DOUBLE PRECISION,
    CLASSIFICACAO  VARCHAR(1),
    GERAL          DOUBLE PRECISION,
    ID             VARCHAR(25),
    CONVERSAO      VARCHAR(200)
);

CREATE TABLE DADOSREPL (
    GID     VARCHAR(38),
    TABELA  VARCHAR(30),
    DADOS   VARCHAR(2000)
);

CREATE TABLE DESCONTOS_IND (
    DES_ID        INTEGER NOT NULL,
    DES_CODIND    INTEGER NOT NULL,
    DES_VALINI    DOUBLE PRECISION,
    DES_VALFIM    DOUBLE PRECISION,
    DES_DESCONTO  INTEGER NOT NULL
);

CREATE TABLE EMPRESA_STATUS (
    CHAVE         VARCHAR(20) NOT NULL,
    STATUS        VARCHAR(1),
    NOME          VARCHAR(60),
    LOGOTIPO      VARCHAR(200),
    LOGOGENERICO  VARCHAR(200)
);

CREATE TABLE FATURA_PED (
    FAT_LANCTO        INTEGER NOT NULL,
    FAT_PEDIDO        VARCHAR(10) NOT NULL,
    FAT_DATAFAT       TIMESTAMP,
    FAT_VALORFAT      DOUBLE PRECISION,
    FAT_NF            VARCHAR(10),
    FAT_OBS           VARCHAR(100),
    FAT_PERCENT       NUMERIC(5,2),
    FAT_COMISSAO      NUMERIC(9,2),
    FAT_INDUSTRIA     INTEGER NOT NULL,
    FAT_PERCOMISSIND  CHAR(1),
    GID               VARCHAR(38)
);

CREATE TABLE FORMA_PAGAMENTO (
    CON_CODIGO       INTEGER NOT NULL,
    CON_DESCRICAO    VARCHAR(30),
    CON_ECARTAO      VARCHAR(1),
    CON_PARCELAS     INTEGER,
    CON_INTERVALO    INTEGER,
    CON_TAXA         DOUBLE PRECISION,
    CON_USA_NFE      VARCHAR(1),
    CON_ATIVO        VARCHAR(1),
    CON_BANDEIRA     INTEGER,
    CON_USA_CAIXA    VARCHAR(1),
    CON_USA_CTASREC  VARCHAR(1),
    CON_CONTACX      INTEGER,
    CON_CONTAREC     INTEGER,
    CON_CCUSTO       INTEGER
);

CREATE TABLE FORNECEDORES (
    FOR_CODIGO      INTEGER NOT NULL,
    FOR_NOME        VARCHAR(75),
    FOR_ENDERECO    VARCHAR(45),
    FOR_BAIRRO      VARCHAR(25),
    FOR_CIDADE      VARCHAR(25),
    FOR_UF          VARCHAR(2),
    FOR_CEP         VARCHAR(10),
    FOR_FONE        VARCHAR(25),
    FOR_FONE2       VARCHAR(25),
    FOR_FAX         VARCHAR(15),
    FOR_CGC         VARCHAR(18) NOT NULL,
    FOR_INSCRICAO   VARCHAR(20),
    FOR_EMAIL       VARCHAR(120),
    FOR_CODREP      INTEGER,
    FOR_PERCOM      DOUBLE PRECISION,
    FOR_DES1        DOUBLE PRECISION,
    FOR_DES2        DOUBLE PRECISION,
    FOR_DES3        DOUBLE PRECISION,
    FOR_DES4        DOUBLE PRECISION,
    FOR_DES5        DOUBLE PRECISION,
    FOR_DES6        DOUBLE PRECISION,
    FOR_DES7        DOUBLE PRECISION,
    FOR_DES8        DOUBLE PRECISION,
    FOR_DES9        DOUBLE PRECISION,
    FOR_DES10       DOUBLE PRECISION,
    FOR_HOMEPAGE    VARCHAR(150),
    FOR_CONTATOREP  VARCHAR(50),
    OBSERVACOES     BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    FOR_OBS2        BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    FOR_NOMERED     VARCHAR(15) NOT NULL,
    FOR_TIPO2       VARCHAR(1),
    FOR_LOCIMAGEM   VARCHAR(50),
    GID             VARCHAR(38),
    FOR_TIPOFRETE   CHAR(1)
);

CREATE TABLE FRACRECEBIMENTOS (
    CTA_ID             INTEGER NOT NULL,
    CTA_PARCELA        INTEGER NOT NULL,
    CTA_VENDA          INTEGER,
    CTA_IDFORMA        INTEGER,
    CTA_DESCPAGAMENTO  VARCHAR(60),
    CTA_VALORPAGO      NUMERIC(9,2),
    CTA_USACAIXA       VARCHAR(1),
    CTA_OPERADOR       VARCHAR(20),
    CTA_DATA           DATE,
    CTA_CONTA          INTEGER,
    CTA_CONTACX        INTEGER,
    CTA_DEBCRE         CHAR(1),
    CTA_CONTADEBITO    INTEGER,
    CTA_DOCTO          VARCHAR(15) NOT NULL,
    CTA_PARCIAL        INTEGER
);

CREATE TABLE GRUPO_DESC (
    GRU_CODIGO  SMALLINT NOT NULL,
    GRU_DESC1   DOUBLE PRECISION,
    GRU_DESC2   DOUBLE PRECISION,
    GRU_DESC3   DOUBLE PRECISION,
    GRU_DESC4   DOUBLE PRECISION,
    GRU_DESC5   DOUBLE PRECISION,
    GRU_DESC6   DOUBLE PRECISION,
    GRU_DESC7   DOUBLE PRECISION,
    GRU_DESC8   DOUBLE PRECISION,
    GRU_DESC9   DOUBLE PRECISION,
    GRU_DESC10  DOUBLE PRECISION,
    GID         VARCHAR(38)
);

CREATE TABLE GRUPOS (
    GRU_CODIGO     INTEGER NOT NULL,
    GRU_NOME       VARCHAR(50),
    GRU_PERCOMISS  DOUBLE PRECISION,
    GID            VARCHAR(38)
);

CREATE TABLE IND_METAS (
    MET_ANO        INTEGER,
    MET_INDUSTRIA  INTEGER,
    MET_JAN        DOUBLE PRECISION,
    MET_FEV        DOUBLE PRECISION,
    MET_MAR        DOUBLE PRECISION,
    MET_ABR        DOUBLE PRECISION,
    MET_MAI        DOUBLE PRECISION,
    MET_JUN        DOUBLE PRECISION,
    MET_JUL        DOUBLE PRECISION,
    MET_AGO        DOUBLE PRECISION,
    MET_SET        DOUBLE PRECISION,
    MET_OUT        DOUBLE PRECISION,
    MET_NOV        DOUBLE PRECISION,
    MET_DEZ        DOUBLE PRECISION
);

CREATE TABLE INDCLIENTES (
    CLI_ID     INTEGER NOT NULL,
    CLI_INDID  INTEGER NOT NULL,
    GID        VARCHAR(38)
);

CREATE TABLE ITEMPROMOCLI (
    ITEM_PROCODPROD  VARCHAR(25) NOT NULL,
    ITEM_INDUSTRIA   INTEGER NOT NULL,
    ITEM_CLIID       INTEGER NOT NULL,
    ITEM_VALIDADE    DATE NOT NULL,
    ITEM_VALOR       DOUBLE PRECISION NOT NULL,
    ITEM_TABELA      VARCHAR(20),
    GID              VARCHAR(38)
);

CREATE TABLE ITENS_PED (
    ITE_LANCTO             INTEGER NOT NULL,
    ITE_PEDIDO             VARCHAR(10) NOT NULL,
    ITE_INDUSTRIA          INTEGER NOT NULL,
    ITE_PRODUTO            VARCHAR(25) NOT NULL,
    ITE_EMBUCH             VARCHAR(15),
    ITE_NOMEPROD           VARCHAR(100),
    ITE_GRUPO              SMALLINT,
    ITE_DATA               TIMESTAMP,
    ITE_QUANT              DOUBLE PRECISION,
    ITE_PUNI               DOUBLE PRECISION,
    ITE_PUNILIQ            DOUBLE PRECISION,
    ITE_TOTLIQUIDO         DOUBLE PRECISION,
    ITE_DESCADIC           DOUBLE PRECISION,
    ITE_DES1               DOUBLE PRECISION,
    ITE_DES2               DOUBLE PRECISION,
    ITE_DES3               DOUBLE PRECISION,
    ITE_DES4               DOUBLE PRECISION,
    ITE_DES5               DOUBLE PRECISION,
    ITE_DES6               DOUBLE PRECISION,
    ITE_DES7               DOUBLE PRECISION,
    ITE_DES8               DOUBLE PRECISION,
    ITE_DES9               DOUBLE PRECISION,
    ITE_DES10              DOUBLE PRECISION,
    ITE_DES11              DOUBLE PRECISION,
    ITE_DESCONTOS          VARCHAR(200),
    ITE_TOTBRUTO           DOUBLE PRECISION,
    ITE_VALCOMIPI          DOUBLE PRECISION,
    ITE_IPI                NUMERIC(7,2),
    ITE_ST                 DOUBLE PRECISION,
    ITE_VALCOMST           DOUBLE PRECISION,
    ITE_FATURADO           VARCHAR(1),
    ITE_QTDFAT             INTEGER,
    ITE_CLIENTE            INTEGER,
    ITE_VENDEDOR           SMALLINT,
    ITE_EXPORTADO          VARCHAR(1),
    ITE_COTACAO            VARCHAR(1),
    ITE_SEQ                SMALLINT,
    ITE_STATUS             CHAR(1),
    ITE_PUNILIQCOMIMPOSTO  DOUBLE PRECISION,
    GID                    VARCHAR(38),
    ITE_NUMPEDCLI          VARCHAR(25),
    ITE_IDPRODUTO          INTEGER,
    ITE_NORMALIZADO        VARCHAR(25)
);

CREATE TABLE LOTE (
    LOT_ID         INTEGER NOT NULL,
    LOT_DATA       DATE,
    LOT_FLAG       CHAR(2) NOT NULL,
    LOT_DEBCRE     CHAR(1) NOT NULL,
    LOT_IDORIGEM   INTEGER NOT NULL,
    LOT_CCUSTO     INTEGER NOT NULL,
    LOT_PLACON     INTEGER NOT NULL,
    LOT_VALOR      DOUBLE PRECISION NOT NULL,
    LOT_HISTORICO  VARCHAR(300)
);

CREATE TABLE METAS_VEND (
    MET_ANO          INTEGER NOT NULL,
    MET_MES          INTEGER NOT NULL,
    MET_VENDEDOR     INTEGER NOT NULL,
    MET_INDUSTRIA    INTEGER NOT NULL,
    MET_MESVALOR     DOUBLE PRECISION,
    MET_DATA         DATE,
    MET_MESLIGACOES  INTEGER
);

CREATE TABLE METASCLI (
    MET_INDUSTRIA  INTEGER NOT NULL,
    MET_CLIENTE    INTEGER NOT NULL,
    MET_MESANO     VARCHAR(8) NOT NULL,
    MET_DATA       DATE,
    MET_VALOR      DOUBLE PRECISION,
    MET_MES        INTEGER,
    GID            VARCHAR(38)
);

CREATE TABLE METASIND (
    MET_INDUSTRIA    INTEGER NOT NULL,
    MET_VALOR        DOUBLE PRECISION,
    MET_DATA         DATE,
    MET_MESANO       VARCHAR(8) NOT NULL,
    MET_METATELEMKT  INTEGER,
    GID              VARCHAR(38)
);

CREATE TABLE PARAMETROS (
    CODIGO                 SMALLINT,
    PAR_SISUSER            VARCHAR(30) NOT NULL,
    PAR_ORDEMPED           VARCHAR(1),
    PAR_ENTER              VARCHAR(1),
    PAR_PERMITEDUP         VARCHAR(1),
    PAR_DESCONTOESPEC      VARCHAR(1),
    PAR_ORDEMITENS         VARCHAR(1),
    PAR_DESCGRUPO          VARCHAR(1),
    PAR_PESQUISA           VARCHAR(1),
    PAR_ENTERBUSCA         VARCHAR(1),
    PAR_CODIGOLIMPO        VARCHAR(1),
    PAR_ZERADESCONTO       VARCHAR(1),
    PAR_IGNORADESCONTO     VARCHAR(1),
    PAR_TIRAEMAILCONTACAO  VARCHAR(1),
    PAR_PERMANECEDESCONTO  VARCHAR(1),
    PAR_VALIDADEPROMO      VARCHAR(1),
    PAR_CONFRECEMAIL       VARCHAR(1),
    PAR_MEDIDAS            VARCHAR(1),
    PAR_PESQCODIGO         VARCHAR(1),
    PAR_SMTP               VARCHAR(60),
    PAR_USUARIO            VARCHAR(60),
    PAR_EMAIL              VARCHAR(60),
    PAR_SENHA              VARCHAR(20),
    PAR_PORTA              VARCHAR(3),
    PAR_AUTENTICA          VARCHAR(1),
    PAR_SEGURA             VARCHAR(1),
    PAR_SKIN               VARCHAR(40),
    PAR_CODORI             VARCHAR(1),
    PAR_AVISAAGENDA        VARCHAR(1),
    PAR_SALVAPEDIDO        VARCHAR(1),
    PAR_EMAILALT           VARCHAR(60),
    PAR_CASADECIMAL        VARCHAR(1),
    PAR_IDREPL_REC         INTEGER,
    PAR_IDREPL_ENV         INTEGER,
    PAR_BACKUP             VARCHAR(2),
    VENDEDOR               INTEGER,
    PAR_OBSPEDIDOS         BLOB SUB_TYPE BINARY SEGMENT SIZE 80,
    PAR_IDUSER             INTEGER,
    PAR_INICIOPEDIDO       CHAR(1),
    PAR_BUSCACLIENTE       CHAR(1),
    PAR_TIPOFRETE          CHAR(1)
);

CREATE TABLE PEDIDOS (
    PED_NUMERO       INTEGER NOT NULL,
    PED_PEDIDO       VARCHAR(10) NOT NULL,
    PED_TABELA       VARCHAR(25) NOT NULL,
    PED_DATA         DATE,
    PED_INDUSTRIA    INTEGER NOT NULL,
    PED_CLIENTE      INTEGER NOT NULL,
    PED_TRANSP       INTEGER NOT NULL,
    PED_VENDEDOR     SMALLINT NOT NULL,
    PED_CLIIND       VARCHAR(15),
    PED_SITUACAO     VARCHAR(1),
    PED_PRI          DOUBLE PRECISION,
    PED_SEG          DOUBLE PRECISION,
    PED_TER          DOUBLE PRECISION,
    PED_QUA          DOUBLE PRECISION,
    PED_QUI          DOUBLE PRECISION,
    PED_SEX          DOUBLE PRECISION,
    PED_SET          DOUBLE PRECISION,
    PED_OIT          DOUBLE PRECISION,
    PED_NOV          DOUBLE PRECISION,
    PED_DEZ          DOUBLE PRECISION,
    PED_DESCADIC     DOUBLE PRECISION,
    PED_COEFICIENTE  DOUBLE PRECISION,
    PED_CONDPAG      VARCHAR(100),
    PED_TIPOFRETE    VARCHAR(1),
    PED_TOTLIQ       DOUBLE PRECISION,
    PED_TOTBRUTO     DOUBLE PRECISION,
    PED_ACRESCIMO    DOUBLE PRECISION,
    PED_TOTALIPI     DOUBLE PRECISION,
    PED_COMPRADOR    VARCHAR(30),
    PED_EMAILCOMP    VARCHAR(60),
    PED_DATAFAT      DATE,
    PED_NFFAT        VARCHAR(15),
    PED_OBS          VARCHAR(600),
    PED_OBSFORA      VARCHAR(6000),
    PED_EXPORTADO    VARCHAR(1),
    PED_ENVIADO      VARCHAR(1),
    PED_DATAENVIO    TIMESTAMP,
    GID              VARCHAR(38)
);

CREATE TABLE PRO_TEMPCURVA (
    PRO_ID         INTEGER,
    PRO_DESCRICAO  VARCHAR(100),
    PRO_CODPROD    VARCHAR(25) NOT NULL,
    PRO_GRUPOPRO   INTEGER
);

CREATE TABLE PRODUTOS (
    PRO_CODIGO            INTEGER NOT NULL,
    PRO_INDUSTRIA         INTEGER NOT NULL,
    PRO_NOMETABELA        VARCHAR(20),
    PRO_CODPROD           VARCHAR(25) NOT NULL,
    ITE_CODIGO2           VARCHAR(25),
    PRO_CODBARRAS         VARCHAR(13),
    PRO_CODORIGINAL       VARCHAR(40),
    PRO_GRUPO             SMALLINT,
    PRO_SETOR             VARCHAR(30),
    PRO_NOME              VARCHAR(100),
    PRO_VALORNORMAL       DOUBLE PRECISION,
    PRO_VALORPROMO        DOUBLE PRECISION,
    PRO_PRECO3            DOUBLE PRECISION,
    PRO_DESCADIC          DOUBLE PRECISION,
    PRO_LINHA             VARCHAR(50),
    PRO_EMBALAGEM         INTEGER,
    PRO_IPI               NUMERIC(9,2),
    PRO_PRELIQ            DOUBLE PRECISION,
    ITE_PESO              DOUBLE PRECISION,
    ITE_PREPESO           DOUBLE PRECISION,
    ITE_CONVERSAO         VARCHAR(300),
    PRO_ST                DOUBLE PRECISION,
    PRO_NCM               VARCHAR(10),
    PRO_GRUPOPRO          INTEGER,
    PRO_DESCADIC2         DOUBLE PRECISION,
    PRO_APLICACAO         VARCHAR(300),
    PRO_APLICACAO2        VARCHAR(800),
    PRO_SEQ               SMALLINT,
    PRO_TEMP              VARCHAR(30),
    PRO_QTDPED            DOUBLE PRECISION,
    PRO_DATATABELA        DATE,
    PRO_VENCPROMOCAO      DATE,
    PRO_STATUS            VARCHAR(1),
    GID                   VARCHAR(38),
    PRO_LINHALEVE         BOOLEAN,
    PRO_LINHAPESADA       BOOLEAN,
    PRO_LINHAAGRICOLA     BOOLEAN,
    PRO_LINHAUTILITARIOS  BOOLEAN
);

CREATE TABLE REGIOES (
    REG_CODIGO     SMALLINT NOT NULL,
    REG_DESCRICAO  VARCHAR(50),
    GID            VARCHAR(38)
);

CREATE TABLE REPL_ITENS (
    ID          INTEGER NOT NULL,
    TABELA      VARCHAR(40),
    GID         VARCHAR(38),
    TIPO        CHAR(1),
    DATA        DATE,
    SESSION_ID  INTEGER,
    PEDIDO      VARCHAR(10),
    INDUSTRIA   INTEGER,
    PRODUTO     VARCHAR(25),
    CHAVE1      VARCHAR(60),
    CHAVE2      VARCHAR(60),
    USUARIO     VARCHAR(50)
);

CREATE TABLE RGBCORES (
    ID   INTEGER NOT NULL,
    COR  VARCHAR(12)
);

CREATE TABLE SALDO_PGREC (
    SAL_DOCTO     VARCHAR(15) NOT NULL,
    SAL_PARCELA   INTEGER NOT NULL,
    SAL_SALDO     DOUBLE PRECISION,
    SAL_ID        INTEGER,
    SAL_ULTPAGTO  DATE,
    SAL_CONCRE    INTEGER,
    SAL_CONDEB    INTEGER,
    SAL_GRAUCRE   VARCHAR(10),
    SAL_GRAUDEB   VARCHAR(10)
);

CREATE TABLE SELLOUT (
    SO_ANO          INTEGER NOT NULL,
    SO_MES          INTEGER NOT NULL,
    SO_INDUSTRIA    INTEGER NOT NULL,
    SO_CLIENTE      INTEGER NOT NULL,
    SO_METAVALOR    DOUBLE PRECISION,
    SO_METAQTD      DOUBLE PRECISION,
    SO_VENDA_VALOR  DOUBLE PRECISION,
    SO_VENDA_QTD    DOUBLE PRECISION,
    SO_MESEXT       DATE
);

CREATE TABLE TAB_TEMP (
    TMP_ID         INTEGER,
    TMP_CLIENTE    INTEGER,
    TMP_INDUSTRIA  INTEGER,
    TMP_VENDEDOR   INTEGER,
    TMP_VALOR      NUMERIC(15,2),
    TMP_DATA       DATE,
    TMP_QUANT      NUMERIC(8,2),
    TMP_GERAL      NUMERIC(15,2),
    TMP_PROID      VARCHAR(25),
    TMP_CONVERSAO  VARCHAR(25),
    TMP_DESCRICAO  VARCHAR(50),
    TMP_SOMAQTD    DOUBLE PRECISION,
    TMP_SOMATOTAL  DOUBLE PRECISION,
    TMP_TEXTO      VARCHAR(1000)
);

CREATE TABLE TELEMKT (
    TELE_ID        INTEGER NOT NULL,
    TELE_CLIENTE   INTEGER NOT NULL,
    TELE_OBSGERAL  BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    TELE_OBSCLI    VARCHAR(800),
    GID            VARCHAR(38)
);

CREATE TABLE TRANSPORTADORA (
    CODIGO     INTEGER NOT NULL,
    NOME       VARCHAR(60),
    ENDERECO   VARCHAR(45),
    BAIRRO     VARCHAR(25),
    CIDADE     VARCHAR(25),
    CEP        VARCHAR(11),
    UF         VARCHAR(2),
    CONTATO    VARCHAR(20),
    EMAIL      VARCHAR(50),
    TELEFONE1  VARCHAR(15),
    TELEFONE2  VARCHAR(15),
    FAX        VARCHAR(15),
    CNPJ       VARCHAR(18),
    IEST       VARCHAR(15),
    GID        VARCHAR(38)
);

CREATE TABLE USER_BARRA_F (
    OPCAO      INTEGER NOT NULL,
    GRUPO      VARCHAR(4) NOT NULL,
    PORSENHA   VARCHAR(1),
    INVISIVEL  VARCHAR(1)
);

CREATE TABLE USER_GRUPOS (
    GRUPO      VARCHAR(4) NOT NULL,
    DESCRICAO  VARCHAR(20)
);

CREATE TABLE USER_MENU_SUPERIOR (
    OPCAO      INTEGER NOT NULL,
    GRUPO      VARCHAR(4) NOT NULL,
    INDICE     INTEGER,
    PORSENHA   BOOLEAN,
    INVISIVEL  BOOLEAN,
    INCLUIR    BOOLEAN,
    MODIFICAR  BOOLEAN,
    EXCLUIR    BOOLEAN,
    DESCRICAO  VARCHAR(40)
);

CREATE TABLE USER_NOMES (
    CODIGO     INTEGER NOT NULL,
    NOME       VARCHAR(20) NOT NULL,
    SOBRENOME  VARCHAR(20) NOT NULL,
    SENHA      VARCHAR(20),
    GRUPO      VARCHAR(4),
    IMAGEM     BLOB SUB_TYPE BINARY SEGMENT SIZE 80,
    MASTER     BOOLEAN,
    USUARIO    VARCHAR(20),
    GERENCIA   BOOLEAN
);

CREATE TABLE VEND_METAS (
    MET_ANO        INTEGER NOT NULL,
    MET_INDUSTRIA  INTEGER,
    MET_VENDEDOR   INTEGER NOT NULL,
    MET_JAN        DOUBLE PRECISION,
    MET_FEV        DOUBLE PRECISION,
    MET_MAR        DOUBLE PRECISION,
    MET_ABR        DOUBLE PRECISION,
    MET_MAI        DOUBLE PRECISION,
    MET_JUN        DOUBLE PRECISION,
    MET_JUL        DOUBLE PRECISION,
    MET_AGO        DOUBLE PRECISION,
    MET_SET        DOUBLE PRECISION,
    MET_OUT        DOUBLE PRECISION,
    MET_NOV        DOUBLE PRECISION,
    MET_DEZ        DOUBLE PRECISION
);

CREATE TABLE VENDEDOR_IND (
    VIN_INDUSTRIA  SMALLINT NOT NULL,
    VIN_CODIGO     INTEGER NOT NULL,
    VIN_PERCOM     DOUBLE PRECISION,
    GID            VARCHAR(38)
);

CREATE TABLE VENDEDOR_REG (
    VIN_REGIAO  SMALLINT NOT NULL,
    VIN_CODIGO  INTEGER NOT NULL,
    GID         VARCHAR(38)
);

CREATE TABLE VENDEDORES (
    VEN_CODIGO       INTEGER NOT NULL,
    VEN_NOME         VARCHAR(45),
    VEN_ENDERECO     VARCHAR(50),
    VEN_BAIRRO       VARCHAR(25),
    VEN_CIDADE       VARCHAR(25),
    VEN_CEP          VARCHAR(11),
    VEN_UF           VARCHAR(2),
    VEN_FONE1        VARCHAR(20),
    VEN_FONE2        VARCHAR(20),
    VEN_OBS          VARCHAR(400),
    VEN_CPF          VARCHAR(14),
    VEN_COMISSAO     DOUBLE PRECISION,
    VEN_EMAIL        VARCHAR(60),
    VEN_NOMEUSU      VARCHAR(50),
    VEN_ANIVERSARIO  VARCHAR(6),
    VEN_RG           VARCHAR(30),
    VEN_CTPS         VARCHAR(30),
    VEN_FILIACAO     VARCHAR(100),
    VEN_PIS          VARCHAR(20),
    VEN_FILHOS       INTEGER,
    VEN_CODUSU       INTEGER,
    VEN_IMAGEM       VARCHAR(200),
    GID              VARCHAR(38)
);



/******************************************************************************/
/****                             Primary keys                             ****/
/******************************************************************************/

ALTER TABLE AGENDA ADD CONSTRAINT PK_AGENDA PRIMARY KEY (AGE_LANCTO);
ALTER TABLE AREA_ATU ADD CONSTRAINT PK_AREA_ATU PRIMARY KEY (ATU_ID);
ALTER TABLE ATUA_CLI ADD CONSTRAINT PK_ATUA_CLI PRIMARY KEY (ATU_IDCLI, ATU_ATUAID);
ALTER TABLE BANDEIRA ADD CONSTRAINT PK_BANDEIRA PRIMARY KEY (CODIGO);
ALTER TABLE CAD_PROD ADD CONSTRAINT PK_CAD_PROD PRIMARY KEY (PRO_ID);
ALTER TABLE CAD_TABELASPRE ADD CONSTRAINT PK_CAD_TABELASPRE PRIMARY KEY (ITAB_IDPROD, ITAB_TABELA);
ALTER TABLE CAIXA ADD CONSTRAINT PK_CAIXA PRIMARY KEY (CAI_LANCAMENTO);
ALTER TABLE CCUSTOS ADD CONSTRAINT PK_CCUSTOS PRIMARY KEY (CC_ID);
ALTER TABLE CIDADES ADD CONSTRAINT PK_CIDADES PRIMARY KEY (CODIGO);
ALTER TABLE CIDADES_REGIOES ADD CONSTRAINT PK_CIDADES_REGIOES PRIMARY KEY (REG_ID, CID_ID);
ALTER TABLE CLIENTES ADD CONSTRAINT PK_CLIENTES PRIMARY KEY (CLI_CODIGO);
ALTER TABLE CLI_ANIV ADD CONSTRAINT PK_CLI_ANIV PRIMARY KEY (ANI_CLIENTE, ANI_NOME, ANI_FUNCAO);
ALTER TABLE CLI_DESCPRO ADD CONSTRAINT PK_CLI_DESCPRO PRIMARY KEY (CLI_CODIGO, CLI_FORCODIGO, CLI_GRUPO);
ALTER TABLE CLI_IND ADD CONSTRAINT PK_CLI_IND PRIMARY KEY (CLI_CODIGO, CLI_FORCODIGO);
ALTER TABLE CONTAS ADD CONSTRAINT PK_CONTAS PRIMARY KEY (CON_CODIGO);
ALTER TABLE CONTASPGREC ADD CONSTRAINT PK_CONTASPGREC PRIMARY KEY (LAN_DOCTO, LAN_CLIFOR, LAN_LANCTO);
ALTER TABLE CONTATO_FOR ADD CONSTRAINT PK_CONTATO_FOR PRIMARY KEY (CON_FORNEC, CON_NOME, CON_GARGO);
ALTER TABLE CRED_DEV ADD CONSTRAINT PK_CRED_DEV PRIMARY KEY (CD_CODIGO);
ALTER TABLE CRM_INTERACOES ADD CONSTRAINT PK_CRM_INTERACOES PRIMARY KEY (AGE_LANCTO);
ALTER TABLE DESCONTOS_IND ADD CONSTRAINT PK_DESCONTOS_IND PRIMARY KEY (DES_CODIND, DES_DESCONTO);
ALTER TABLE FATURA_PED ADD CONSTRAINT PK_FATURA_PED PRIMARY KEY (FAT_PEDIDO, FAT_INDUSTRIA, FAT_LANCTO);
ALTER TABLE FORMA_PAGAMENTO ADD CONSTRAINT PK_FORMA_PAGAMENTO PRIMARY KEY (CON_CODIGO);
ALTER TABLE FORNECEDORES ADD CONSTRAINT PK_FORNECEDORES PRIMARY KEY (FOR_CGC);
ALTER TABLE GRUPOS ADD CONSTRAINT PK_GRUPOS PRIMARY KEY (GRU_CODIGO);
ALTER TABLE GRUPO_DESC ADD CONSTRAINT PK_GRUPO_DESC PRIMARY KEY (GRU_CODIGO);
ALTER TABLE INDCLIENTES ADD CONSTRAINT PK_INDCLIENTES PRIMARY KEY (CLI_ID, CLI_INDID);
ALTER TABLE ITEMPROMOCLI ADD CONSTRAINT PK_ITEMPROMOCLI PRIMARY KEY (ITEM_PROCODPROD, ITEM_INDUSTRIA, ITEM_CLIID);
ALTER TABLE ITENS_PED ADD CONSTRAINT PK_ITENS_PED PRIMARY KEY (ITE_LANCTO, ITE_PEDIDO, ITE_PRODUTO, ITE_INDUSTRIA);
ALTER TABLE LOTE ADD CONSTRAINT PK_LOTE PRIMARY KEY (LOT_ID, LOT_FLAG, LOT_IDORIGEM, LOT_PLACON);
ALTER TABLE METASCLI ADD CONSTRAINT PK_METASCLI PRIMARY KEY (MET_INDUSTRIA, MET_CLIENTE, MET_MESANO);
ALTER TABLE METASIND ADD CONSTRAINT PK_METASIND PRIMARY KEY (MET_INDUSTRIA, MET_MESANO);
ALTER TABLE METAS_VEND ADD CONSTRAINT PK_METAS_VEND PRIMARY KEY (MET_ANO, MET_MES, MET_VENDEDOR, MET_INDUSTRIA);
ALTER TABLE PEDIDOS ADD CONSTRAINT PK_PEDIDOS PRIMARY KEY (PED_PEDIDO, PED_INDUSTRIA);
ALTER TABLE PRODUTOS ADD CONSTRAINT PK_PRODUTOS PRIMARY KEY (PRO_CODPROD, PRO_INDUSTRIA, PRO_CODIGO);
ALTER TABLE PRO_TEMPCURVA ADD CONSTRAINT PK_PRO_TEMPCURVA PRIMARY KEY (PRO_CODPROD);
ALTER TABLE REGIOES ADD CONSTRAINT PK_REGIOES PRIMARY KEY (REG_CODIGO);
ALTER TABLE REPL_ITENS ADD CONSTRAINT PK_REPL_ITENS PRIMARY KEY (ID);
ALTER TABLE RGBCORES ADD CONSTRAINT PK_RGBCORES PRIMARY KEY (ID);
ALTER TABLE SALDO_PGREC ADD CONSTRAINT PK_SALDO_PGREC PRIMARY KEY (SAL_DOCTO, SAL_PARCELA);
ALTER TABLE SELLOUT ADD CONSTRAINT PK_SELLOUT PRIMARY KEY (SO_ANO, SO_MES, SO_INDUSTRIA, SO_CLIENTE);
ALTER TABLE TELEMKT ADD CONSTRAINT PK_TELEMKT PRIMARY KEY (TELE_ID);
ALTER TABLE TRANSPORTADORA ADD CONSTRAINT PK_TRANSPORTADORA PRIMARY KEY (CODIGO);
ALTER TABLE USER_GRUPOS ADD CONSTRAINT PK_USER_GRUPOS PRIMARY KEY (GRUPO);
ALTER TABLE VENDEDORES ADD CONSTRAINT PK_VENDEDORES PRIMARY KEY (VEN_CODIGO);
ALTER TABLE VENDEDOR_IND ADD CONSTRAINT PK_VENDEDOR_IND PRIMARY KEY (VIN_CODIGO, VIN_INDUSTRIA);


/******************************************************************************/
/****                               Indices                                ****/
/******************************************************************************/

CREATE INDEX AGENDA_IDX1 ON AGENDA (GID);
CREATE INDEX AGENDA_IDX2 ON AGENDA (AGE_LANCTO);
CREATE DESCENDING INDEX AGENDA_IDX3 ON AGENDA (AGE_DATA);
CREATE INDEX AGENDA_IDX4 ON AGENDA (AGE_CLIENTE);
CREATE INDEX AREA_ATU_IDX1 ON AREA_ATU (GID);
CREATE INDEX ATUA_CLI_IDX1 ON ATUA_CLI (ATU_IDCLI);
CREATE INDEX ATUA_CLI_IDX2 ON ATUA_CLI (ATU_ATUAID);
CREATE INDEX ATUA_CLI_IDX3 ON ATUA_CLI (GID);
CREATE INDEX BAIXAXML_IDX1 ON BAIXAXML (NUMPED);
CREATE INDEX CAD_PROD_IDX1 ON CAD_PROD (PRO_CODIGONORMALIZADO);
CREATE INDEX CAD_TABELASPRE_IDX1 ON CAD_TABELASPRE (ITAB_IDPROD);
CREATE INDEX CAD_TABELASPRE_IDX2 ON CAD_TABELASPRE (ITAB_TABELA);
CREATE INDEX CAIXA_IDX1 ON CAIXA (CAI_DATA);
CREATE INDEX CAIXA_IDX2 ON CAIXA (CAI_CCUSTO);
CREATE INDEX CAIXA_IDX3 ON CAIXA (CAI_CONTA);
CREATE INDEX CAIXA_IDX4 ON CAIXA (CAI_CONTADEBITO);
CREATE INDEX CLIENTES_IDX1 ON CLIENTES (CLI_NOME);
CREATE INDEX CLIENTES_IDX2 ON CLIENTES (CLI_FANTASIA);
CREATE INDEX CLIENTES_IDX3 ON CLIENTES (CLI_NOMRED);
CREATE INDEX CLIENTES_IDX4 ON CLIENTES (CLI_UF);
CREATE INDEX CLIENTES_IDX5 ON CLIENTES (CLI_CODIGO);
CREATE INDEX CLIENTES_IDX6 ON CLIENTES (CLI_VENDEDOR);
CREATE INDEX CLIENTES_IDX7 ON CLIENTES (CLI_REGIAO2);
CREATE INDEX CLIENTES_IDX8 ON CLIENTES (GID);
CREATE INDEX CLI_ANIV_IDX1 ON CLI_ANIV (ANI_CLIENTE);
CREATE INDEX CLI_ANIV_IDX2 ON CLI_ANIV (ANI_NOME);
CREATE INDEX CLI_ANIV_IDX3 ON CLI_ANIV (GID);
CREATE INDEX CLI_DESCPRO_IDX1 ON CLI_DESCPRO (GID);
CREATE INDEX CLI_IND_IDX1 ON CLI_IND (CLI_CODIGO);
CREATE INDEX CLI_IND_IDX2 ON CLI_IND (GID);
CREATE INDEX CONTAS_IDX1 ON CONTAS (CON_GRAU);
CREATE INDEX CONTAS_IDX2 ON CONTAS (GID);
CREATE INDEX CONTASPGREC_IDX1 ON CONTASPGREC (LAN_CLIFOR);
CREATE INDEX CONTASPGREC_IDX2 ON CONTASPGREC (LAN_CONTA);
CREATE INDEX CONTASPGREC_IDX3 ON CONTASPGREC (GID);
CREATE INDEX CONTATO_FOR_IDX1 ON CONTATO_FOR (CON_FORNEC);
CREATE INDEX CONTATO_FOR_IDX2 ON CONTATO_FOR (GID);
CREATE INDEX CRED_DEV_IDX1 ON CRED_DEV (CD_NOME);
CREATE INDEX CRED_DEV_IDX2 ON CRED_DEV (GID);
CREATE INDEX CRM_INTERACOES_IDX1 ON CRM_INTERACOES (AGE_CLIENTE);
CREATE DESCENDING INDEX CRM_INTERACOES_IDX2 ON CRM_INTERACOES (AGE_DATA);
CREATE INDEX CRM_INTERACOES_IDX3 ON CRM_INTERACOES (AGE_INDUSTRIA);
CREATE INDEX CURVAABC_IDX1 ON CURVAABC (SEQ);
CREATE DESCENDING INDEX CURVAABC_IDX2 ON CURVAABC (QUANTIDADE);
CREATE DESCENDING INDEX CURVAABC_IDX3 ON CURVAABC (VALOR);
CREATE INDEX FATURA_PED_IDX1 ON FATURA_PED (FAT_PEDIDO);
CREATE INDEX FATURA_PED_IDX2 ON FATURA_PED (GID);
CREATE INDEX FORNECEDORES_IDX1 ON FORNECEDORES (FOR_NOME);
CREATE INDEX FORNECEDORES_IDX2 ON FORNECEDORES (FOR_NOMERED);
CREATE INDEX FORNECEDORES_IDX3 ON FORNECEDORES (FOR_CODIGO);
CREATE INDEX FORNECEDORES_IDX4 ON FORNECEDORES (GID);
CREATE INDEX GRUPOS_IDX1 ON GRUPOS (GID);
CREATE INDEX GRUPO_DESC_IDX1 ON GRUPO_DESC (GID);
CREATE INDEX INDCLIENTES_IDX1 ON INDCLIENTES (CLI_ID);
CREATE INDEX INDCLIENTES_IDX2 ON INDCLIENTES (GID);
CREATE INDEX ITEMPROMOCLI_IDX1 ON ITEMPROMOCLI (GID);
CREATE INDEX ITENS_PED_IDX1 ON ITENS_PED (ITE_CLIENTE);
CREATE INDEX ITENS_PED_IDX2 ON ITENS_PED (ITE_INDUSTRIA);
CREATE INDEX ITENS_PED_IDX3 ON ITENS_PED (ITE_PRODUTO);
CREATE INDEX ITENS_PED_IDX4 ON ITENS_PED (ITE_PEDIDO);
CREATE INDEX ITENS_PED_IDX5 ON ITENS_PED (GID);
CREATE INDEX LOTE_IDX1 ON LOTE (LOT_PLACON);
CREATE INDEX LOTE_IDX2 ON LOTE (LOT_DATA);
CREATE INDEX METASCLI_IDX1 ON METASCLI (MET_DATA);
CREATE INDEX METASIND_IDX1 ON METASIND (MET_MESANO);
CREATE INDEX METASIND_IDX2 ON METASIND (GID);
CREATE INDEX METAS_VEND_IDX1 ON METAS_VEND (MET_MES, MET_INDUSTRIA);
CREATE INDEX METAS_VEND_IDX2 ON METAS_VEND (MET_ANO);
CREATE INDEX PEDIDOS_IDX1 ON PEDIDOS (PED_PEDIDO);
CREATE INDEX PEDIDOS_IDX2 ON PEDIDOS (PED_INDUSTRIA);
CREATE INDEX PEDIDOS_IDX3 ON PEDIDOS (PED_CLIENTE);
CREATE INDEX PEDIDOS_IDX4 ON PEDIDOS (PED_DATA);
CREATE INDEX PEDIDOS_IDX5 ON PEDIDOS (GID);
CREATE DESCENDING INDEX PEDIDOS_IDX6 ON PEDIDOS (PED_DATA);
CREATE DESCENDING INDEX PEDIDOS_IDX7 ON PEDIDOS (PED_NUMERO);
CREATE INDEX PRODUTOS_IDX1 ON PRODUTOS (PRO_CODPROD);
CREATE INDEX PRODUTOS_IDX2 ON PRODUTOS (PRO_NOME);
CREATE INDEX PRODUTOS_IDX3 ON PRODUTOS (PRO_INDUSTRIA);
CREATE INDEX PRODUTOS_IDX5 ON PRODUTOS (PRO_GRUPOPRO);
CREATE INDEX PRODUTOS_IDX6 ON PRODUTOS (PRO_NOMETABELA);
CREATE INDEX PRODUTOS_IDX7 ON PRODUTOS (PRO_GRUPO);
CREATE INDEX PRODUTOS_IDX8 ON PRODUTOS (GID);
CREATE INDEX REGIOES_IDX1 ON REGIOES (REG_DESCRICAO, REG_CODIGO);
CREATE INDEX REGIOES_IDX2 ON REGIOES (GID);
CREATE INDEX REPL_ITENSDATA ON REPL_ITENS (DATA);
CREATE INDEX REPL_ITENSGID ON REPL_ITENS (GID);
CREATE INDEX REPL_ITENSID ON REPL_ITENS (ID);
CREATE INDEX REPL_ITENSTABELA ON REPL_ITENS (TABELA);
CREATE INDEX SELLOUT_IDX1 ON SELLOUT (SO_INDUSTRIA);
CREATE INDEX SELLOUT_IDX2 ON SELLOUT (SO_CLIENTE);
CREATE INDEX SELLOUT_IDX3 ON SELLOUT (SO_MES);
CREATE INDEX TAB_TEMP_IDX1 ON TAB_TEMP (TMP_CLIENTE);
CREATE INDEX TELEMKT_IDX1 ON TELEMKT (TELE_CLIENTE);
CREATE INDEX TELEMKT_IDX2 ON TELEMKT (GID);
CREATE INDEX TRANSPORTADORA_IDX1 ON TRANSPORTADORA (NOME, CODIGO);
CREATE INDEX TRANSPORTADORA_IDX2 ON TRANSPORTADORA (GID);
CREATE INDEX VENDEDORES_IDX1 ON VENDEDORES (VEN_NOME, VEN_CODIGO);
CREATE INDEX VENDEDORES_IDX2 ON VENDEDORES (GID);
CREATE INDEX VENDEDOR_IND_IDX1 ON VENDEDOR_IND (GID);


/******************************************************************************/
/****                               Triggers                               ****/
/******************************************************************************/



SET TERM ^ ;



/******************************************************************************/
/****                         Triggers for tables                          ****/
/******************************************************************************/



/* Trigger: AGENDA_BI */
CREATE TRIGGER AGENDA_BI FOR AGENDA
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.age_lancto is null or new.age_lancto < 0) then
    new.age_lancto = gen_id(gen_agenda_id,1);
end
^

/* Trigger: AREA_ATU_BD2 */
CREATE TRIGGER AREA_ATU_BD2 FOR AREA_ATU
ACTIVE BEFORE DELETE POSITION 2
AS
begin
  delete from atua_cli
  where atu_atuaid = old.atu_id;
end
^

/* Trigger: AREA_ATU_BI */
CREATE TRIGGER AREA_ATU_BI FOR AREA_ATU
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.atu_id is null or new.atu_id <= 0) then
    new.atu_id = gen_id(gen_area_atu_id,1);
end
^

/* Trigger: BANDEIRA_BI */
CREATE TRIGGER BANDEIRA_BI FOR BANDEIRA
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.codigo is null or new.codigo <= 0) then
    new.codigo = gen_id(gen_bandeira_id,1);
end
^

/* Trigger: CAD_PROD_BI */
CREATE TRIGGER CAD_PROD_BI FOR CAD_PROD
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.pro_id is null or new.pro_id <= 0) then
    new.pro_id = gen_id(gen_cad_prod_id,1);
end
^

/* Trigger: CAIXA_AD2 */
CREATE TRIGGER CAIXA_AD2 FOR CAIXA
ACTIVE AFTER DELETE POSITION 2
AS
begin
  delete from lote
  where lot_idorigem = old.cai_lancamento and lot_flag = 'CX';
end
^

/* Trigger: CAIXA_AIU0 */
CREATE TRIGGER CAIXA_AIU0 FOR CAIXA
ACTIVE AFTER INSERT OR UPDATE POSITION 0
AS
begin
 execute procedure proc_atzlote(new.cai_lancamento, 'CX', new.cai_conta, 'C');
 execute procedure proc_atzlote(new.cai_lancamento, 'CX', new.cai_contadebito, 'D');
end
^

/* Trigger: CAIXA_BI */
CREATE TRIGGER CAIXA_BI FOR CAIXA
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.cai_lancamento is null or new.cai_lancamento <= 0) then
    new.cai_lancamento = gen_id(gen_caixa_id,1);
end
^

/* Trigger: CCUSTOS_BI */
CREATE TRIGGER CCUSTOS_BI FOR CCUSTOS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.cc_id is null or new.cc_id <= 0) then
    new.cc_id = gen_id(gen_ccustos_id,1);
end
^

/* Trigger: CLIENTES_BD1 */
CREATE TRIGGER CLIENTES_BD1 FOR CLIENTES
ACTIVE BEFORE DELETE POSITION 1
AS
begin
  delete from cli_aniv     where ani_cliente = old.cli_codigo;
  delete from cli_ind      where cli_codigo  = old.cli_codigo;
  delete from atua_cli     where atu_idcli   = old.cli_codigo;
  delete from indclientes  where cli_id      = old.cli_codigo;
end
^

/* Trigger: CLIENTES_BI */
CREATE TRIGGER CLIENTES_BI FOR CLIENTES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.cli_codigo is null or new.cli_codigo <= 0 ) then
    new.cli_codigo = gen_id(gen_clientes_id,1);
end
^

/* Trigger: CLIENTES_BIU4 */
CREATE TRIGGER CLIENTES_BIU4 FOR CLIENTES
ACTIVE BEFORE INSERT OR UPDATE POSITION 4
AS
begin
  new.cli_cnpj = fn_normalizar_cnpj(new.cli_cnpj);
end
^

/* Trigger: CLI_ANIV_BI */
CREATE TRIGGER CLI_ANIV_BI FOR CLI_ANIV
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ani_lancto is null or new.ani_lancto <= 0) then
    new.ani_lancto = gen_id(gen_cli_aniv_id,1);
end
^

/* Trigger: CLI_IND_BI */
CREATE TRIGGER CLI_IND_BI FOR CLI_IND
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.cli_lancamento is null or new.cli_lancamento <= 0) then
    new.cli_lancamento = gen_id(gen_cli_ind_id,1);
end
^

/* Trigger: CONTASPGREC_AD5 */
CREATE TRIGGER CONTASPGREC_AD5 FOR CONTASPGREC
ACTIVE AFTER DELETE POSITION 5
AS
declare variable vLancto type of column contaspgrec.lan_docto;
begin
 select first 1 cta_venda from fracrecebimentos f
 where f.cta_docto = old.lan_docto
 into :vlancto;
 if (vlancto > 0) then
  delete from fracrecebimentos where cta_venda = :vlancto;
end
^

/* Trigger: CONTASPGREC_BI */
CREATE TRIGGER CONTASPGREC_BI FOR CONTASPGREC
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.lan_lancto is null or new.lan_lancto <= 0) then
    new.lan_lancto = gen_id(gen_contaspgrec_id,1);
end
^

/* Trigger: CONTASPGREC_VLNULL */
CREATE TRIGGER CONTASPGREC_VLNULL FOR CONTASPGREC
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
 if ((new.lan_valorpago is null)) then
  new.lan_valorpago = 0;
end
^

/* Trigger: CONTAS_BI */
CREATE TRIGGER CONTAS_BI FOR CONTAS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.con_codigo is null or new.con_codigo <= 0) then
    new.con_codigo = gen_id(gen_contas_id,1);
end
^

/* Trigger: CONTATO_FOR_BI */
CREATE TRIGGER CONTATO_FOR_BI FOR CONTATO_FOR
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.con_codigo is null or new.con_codigo <= 0) then
    new.con_codigo = gen_id(gen_contato_for_id,1);
end
^

/* Trigger: CRED_DEV_BI */
CREATE TRIGGER CRED_DEV_BI FOR CRED_DEV
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.cd_codigo is null or new.cd_codigo <= 0) then
    new.cd_codigo = gen_id(gen_cred_dev_id,1);
end
^

/* Trigger: CRM_BI */
CREATE TRIGGER CRM_BI FOR CRM
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.tele_id is null or new.tele_id <= 0) then
    new.tele_id = gen_id(gen_crm_id,1);
end
^

/* Trigger: CRM_INTERACOES_BI */
CREATE TRIGGER CRM_INTERACOES_BI FOR CRM_INTERACOES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.age_lancto is null or new.age_lancto <= 0) then
    new.age_lancto = gen_id(gen_crm_interacoes_id,1);
end
^

/* Trigger: CURVAABC_BI */
CREATE TRIGGER CURVAABC_BI FOR CURVAABC
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.seq is null or new.seq <= 0) then
    new.seq = gen_id(gen_curvaabc_id,1);
end
^

/* Trigger: DESCONTOS_IND_BI */
CREATE TRIGGER DESCONTOS_IND_BI FOR DESCONTOS_IND
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.des_id is null or new.des_id <= 0) then
    new.des_id = gen_id(gen_descontos_ind_id,1);
end
^

/* Trigger: FATURA_PED_BI */
CREATE TRIGGER FATURA_PED_BI FOR FATURA_PED
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.fat_lancto is null or new.fat_lancto <= 0) then
    new.fat_lancto = gen_id(gen_fatura_ped_id,1);
end
^

/* Trigger: FORMA_PAGAMENTO_BI */
CREATE TRIGGER FORMA_PAGAMENTO_BI FOR FORMA_PAGAMENTO
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.con_codigo is null or new.con_codigo <= 0) then
    new.con_codigo = gen_id(gen_forma_pagamento_id,1);
end
^

/* Trigger: FORNECEDORES_BI */
CREATE TRIGGER FORNECEDORES_BI FOR FORNECEDORES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.for_codigo is null or new.for_codigo <= 0) then
    new.for_codigo = gen_id(gen_fornecedores_id,1);
end
^

/* Trigger: FORNECEDORES_BIU3 */
CREATE TRIGGER FORNECEDORES_BIU3 FOR FORNECEDORES
ACTIVE BEFORE INSERT OR UPDATE POSITION 3
AS
begin
  new.for_cgc = fn_normalizar_cnpj(new.for_cgc);
end
^

/* Trigger: FRACRECEBIMENTOS_AD1 */
CREATE TRIGGER FRACRECEBIMENTOS_AD1 FOR FRACRECEBIMENTOS
ACTIVE BEFORE DELETE POSITION 2
AS
begin
 if (old.cta_usacaixa = 'S') then
  begin
    delete from caixa
    where cai_idorigem = old.cta_id and cai_flag = 'PR';
  end
 if (old.cta_usacaixa = 'N') then
  begin
    delete from lote
    where lot_idorigem = old.cta_id and lot_flag = 'PR';
  end
end
^

/* Trigger: FRACRECEBIMENTOS_AI1 */
CREATE TRIGGER FRACRECEBIMENTOS_AI1 FOR FRACRECEBIMENTOS
ACTIVE AFTER INSERT POSITION 4
AS
declare variable vnomecli varchar(60);
declare variable vusacaixa varchar(1);
begin
  select lan_clifornome from contaspgrec c
  where c.lan_lancto = new.cta_id
  into :vnomecli;

  select f.con_usa_caixa
  from forma_pagamento f
  where f.con_codigo = new.cta_idforma
  into :vusacaixa;

  if (vusacaixa = 'S') then
   begin
      execute procedure movcaixa(new.cta_data, new.cta_debcre, new.cta_valorpago, new.cta_operador,
                                 'Ref. baixa parcela ' || new.cta_id || ' - ' || new.cta_parcela||' do favorecido: '||:vnomecli,
                                 :vusacaixa, new.cta_conta, new.cta_contadebito, new.cta_contacx, new.cta_id, 'PR');
   end

 if (vusacaixa = 'N') then
  begin
   execute procedure proc_atzlote(new.cta_id, 'PR', new.cta_conta, 'C');
   execute procedure proc_atzlote(new.cta_id, 'PR', new.cta_contadebito, 'D');
  end
end
^

/* Trigger: FRACRECEBIMENTOS_BI */
CREATE TRIGGER FRACRECEBIMENTOS_BI FOR FRACRECEBIMENTOS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.cta_id is null or new.cta_id <= 0) then
    new.cta_id = gen_id(gen_fracrecebimentos_id,1);
end
^

/* Trigger: GRUPOS_BD0 */
CREATE TRIGGER GRUPOS_BD0 FOR GRUPOS
ACTIVE BEFORE DELETE POSITION 0
AS
begin
  delete from user_menu_superior
  where grupo = old.gru_codigo;
end
^

/* Trigger: GRUPOS_BI */
CREATE TRIGGER GRUPOS_BI FOR GRUPOS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.gru_codigo is null or new.gru_codigo <= 0) then
    new.gru_codigo = gen_id(gen_grupos_id,1);
end
^

/* Trigger: GRUPO_DESC_BI */
CREATE TRIGGER GRUPO_DESC_BI FOR GRUPO_DESC
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.gru_codigo is null or new.gru_codigo <= 0) then
    new.gru_codigo = gen_id(gen_grupo_desc_id,1);
end
^

/* Trigger: ITENS_PED_BI */
CREATE TRIGGER ITENS_PED_BI FOR ITENS_PED
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ite_lancto is null or new.ite_lancto <= 0) then
    new.ite_lancto = gen_id(gen_itens_ped_id,1);
end
^

/* Trigger: LOTE_BI */
CREATE TRIGGER LOTE_BI FOR LOTE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.lot_id is null or new.lot_id <= 0) then
    new.lot_id = gen_id(gen_lote_id,1);
end
^

/* Trigger: PARAMETROS_BI */
CREATE TRIGGER PARAMETROS_BI FOR PARAMETROS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.codigo is null or new.codigo <= 0) then
    new.codigo = gen_id(gen_parametros_id,1);
end
^

/* Trigger: PEDIDOS_BD3 */
CREATE TRIGGER PEDIDOS_BD3 FOR PEDIDOS
ACTIVE BEFORE DELETE POSITION 3
AS
declare variable vpedido type of column pedidos.ped_industria;
begin

  if (vpedido > 0) then
  delete from itens_ped
  where ite_pedido = old.ped_pedido and ite_industria = old.ped_industria;

  if (vpedido > 0) then
  delete from fatura_ped
  where fat_pedido = :vpedido;

end
^

/* Trigger: PEDIDOS_BI */
CREATE TRIGGER PEDIDOS_BI FOR PEDIDOS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ped_numero is null or new.ped_numero <= 0) then
    new.ped_numero = gen_id(gen_pedidos_id,1);
end
^

/* Trigger: PEDIDOS_BU4 */
CREATE TRIGGER PEDIDOS_BU4 FOR PEDIDOS
ACTIVE BEFORE UPDATE POSITION 4
AS
begin
 if (new.ped_situacao = 'P') then
  begin
      if (old.ped_data <> current_date and old.ped_situacao = 'C') then
       new.ped_data = current_date;
  end
end
^

/* Trigger: PRODUTOS_AIU5 */
CREATE TRIGGER PRODUTOS_AIU5 FOR PRODUTOS
ACTIVE AFTER INSERT POSITION 5
AS
begin
        insert into cad_prod
               (pro_industria, pro_codprod, pro_codigooriginal,
                pro_nome, pro_codbarras,
                pro_grupo, pro_setor, pro_embalagem, pro_peso,
                pro_conversao, pro_ncm, pro_aplicacao, pro_aplicacao2, pro_linha,
                pro_linhaleve, pro_linhapesada, pro_linhaagricola,
                pro_linhautilitarios, pro_codigonormalizado, pro_produtolancamento,
                pro_datalancamento, pro_status)
        values (new.pro_industria, new.pro_codprod, new.pro_codoriginal, new.pro_nome,
                new.pro_codbarras, new.pro_grupo, new.pro_setor, new.pro_embalagem,
                new.ite_peso, new.ite_conversao, new.pro_ncm, new.pro_aplicacao,
                new.pro_aplicacao2, new.pro_linha, new.pro_linhaleve, new.pro_linhapesada,
                new.pro_linhaagricola, new.pro_linhautilitarios, fn_normalizar_codigo(new.pro_codprod),
                true, current_date, true);
end
^

/* Trigger: PRODUTOS_BI */
CREATE TRIGGER PRODUTOS_BI FOR PRODUTOS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.pro_codigo is null or new.pro_codigo <= 0) then
    new.pro_codigo = gen_id(gen_produtos_id,1);
end
^

/* Trigger: PRODUTOS_BI3 */
CREATE TRIGGER PRODUTOS_BI3 FOR PRODUTOS
ACTIVE BEFORE INSERT POSITION 3
AS
begin
if (new.ite_codigo2 is null) then
 new.ite_codigo2 = new.pro_codprod;
end
^

/* Trigger: REGIOES_BI */
CREATE TRIGGER REGIOES_BI FOR REGIOES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.reg_codigo is null or new.reg_codigo <= 0) then
    new.reg_codigo = gen_id(gen_regioes_id,1);
end
^

/* Trigger: REPL_AREAATU_GID */
CREATE TRIGGER REPL_AREAATU_GID FOR AREA_ATU
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_AREAATU_REG */
CREATE TRIGGER REPL_AREAATU_REG FOR AREA_ATU
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('AREA_ATU',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('AREA_ATU',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('AREA_ATU',old.gid,'D', old.atu_id);
  end
end
^

/* Trigger: REPL_ATUACLI_GID */
CREATE TRIGGER REPL_ATUACLI_GID FOR ATUA_CLI
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_ATUALI_REG */
CREATE TRIGGER REPL_ATUALI_REG FOR ATUA_CLI
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('ATUA_CLI',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('ATUA_CLI',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo, industria, produto)
            values('ATUA_CLI',old.gid,'D', old.atu_idcli, old.atu_atuaid);
  end
end
^

/* Trigger: REPL_CLIANIV_GID */
CREATE TRIGGER REPL_CLIANIV_GID FOR CLI_ANIV
ACTIVE BEFORE INSERT OR UPDATE POSITION 2
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_CLIANIV_REG */
CREATE TRIGGER REPL_CLIANIV_REG FOR CLI_ANIV
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 3
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CLI_ANIV',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CLI_ANIV',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,chave1,chave2)
            values('CLI_ANIV',old.gid,'D',old.ani_cliente,old.ani_nome);
  end

end
^

/* Trigger: REPL_CLIENTES_GID */
CREATE TRIGGER REPL_CLIENTES_GID FOR CLIENTES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_CLIENTES_REG */
CREATE TRIGGER REPL_CLIENTES_REG FOR CLIENTES
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CLIENTES',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CLIENTES',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('CLIENTES',old.gid,'D', old.cli_codigo);
  end
end
^

/* Trigger: REPL_CLIIND_GID */
CREATE TRIGGER REPL_CLIIND_GID FOR CLI_IND
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_CLIIND_REG */
CREATE TRIGGER REPL_CLIIND_REG FOR CLI_IND
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CLI_IND',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CLI_IND',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria, produto)
            values('CLI_IND',old.gid,'D', old.cli_codigo, old.cli_forcodigo);
  end
end
^

/* Trigger: REPL_CLI_DESCPRO_GID */
CREATE TRIGGER REPL_CLI_DESCPRO_GID FOR CLI_DESCPRO
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  /* Trigger text */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_CLI_DESCPRO_REG */
CREATE TRIGGER REPL_CLI_DESCPRO_REG FOR CLI_DESCPRO
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CLI_DESCPRO',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CLI_DESCPRO',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo, pedido, industria, produto)
            values('CLI_DESCPRO',old.gid,'D', old.cli_codigo, old.cli_forcodigo, old.cli_grupo);
  end
end
^

/* Trigger: REPL_CONTASPGREC_GID */
CREATE TRIGGER REPL_CONTASPGREC_GID FOR CONTASPGREC
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_CONTASPGREC_REG */
CREATE TRIGGER REPL_CONTASPGREC_REG FOR CONTASPGREC
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CONTASPGREC',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CONTASPGREC',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,produto)
            values('CONTASPGREC',old.gid,'D',old.lan_docto);
  end
end
^

/* Trigger: REPL_CONTAS_GID */
CREATE TRIGGER REPL_CONTAS_GID FOR CONTAS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_CONTAS_REG */
CREATE TRIGGER REPL_CONTAS_REG FOR CONTAS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CONTAS',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CONTAS',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('CONTAS',old.gid,'D', old.con_codigo);
  end

end
^

/* Trigger: REPL_CONTATOFOR_REG */
CREATE TRIGGER REPL_CONTATOFOR_REG FOR CONTATO_FOR
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CONTATO_FOR',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CONTATO_FOR',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria,chave1,chave2)
            values('CONTATO_FOR',old.gid,'D',old.con_fornec,old.con_nome,old.con_gargo);
  end
end
^

/* Trigger: REPL_CONTFOR_GID */
CREATE TRIGGER REPL_CONTFOR_GID FOR CONTATO_FOR
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_CREDDEV_REG */
CREATE TRIGGER REPL_CREDDEV_REG FOR CRED_DEV
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CRED_DEV',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CRED_DEV',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('CRED_DEV',old.gid,'D', old.cd_codigo);
  end
end
^

/* Trigger: REPL_CREDEV_GID */
CREATE TRIGGER REPL_CREDEV_GID FOR CRED_DEV
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */ /*$$IBE$$ 
  if ((new.gid is null)) then
     new.cd_gid =  UUID_TO_CHAR( gen_uuid() );

 $$IBE$$*/ POST_EVENT '$$IBE$$';
end
^

/* Trigger: REPL_CRM_GID */
CREATE TRIGGER REPL_CRM_GID FOR CRM
ACTIVE BEFORE INSERT OR UPDATE POSITION 2
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_CRM_INTERACOES_GID */
CREATE TRIGGER REPL_CRM_INTERACOES_GID FOR CRM_INTERACOES
ACTIVE BEFORE INSERT OR UPDATE POSITION 2
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_CRM_INTERACOES_REG */
CREATE TRIGGER REPL_CRM_INTERACOES_REG FOR CRM_INTERACOES
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 3
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CRM_INTERACOES',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CRM_INTERACOES',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('CRM_INTERACOES',old.gid,'D', old.AGE_LANCTO);
  end
end
^

/* Trigger: REPL_CRM_REG */
CREATE TRIGGER REPL_CRM_REG FOR CRM
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 3
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('CRM',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('CRM',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('CRM',old.gid,'D', old.TELE_id);
  end
end
^

/* Trigger: REPL_FATURAPED_GID */
CREATE TRIGGER REPL_FATURAPED_GID FOR FATURA_PED
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_FATURAPED_REG */
CREATE TRIGGER REPL_FATURAPED_REG FOR FATURA_PED
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('FATURA_PED',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('FATURA_PED',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,pedido, industria, produto)
            values('FATURA_PED',old.gid,'D', old.fat_pedido, old.fat_industria, old.fat_nf);
  end
end
^

/* Trigger: REPL_FORNEC_GID */
CREATE TRIGGER REPL_FORNEC_GID FOR FORNECEDORES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_FORNEC_REG */
CREATE TRIGGER REPL_FORNEC_REG FOR FORNECEDORES
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('FORNECEDORES',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('FORNECEDORES',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo, industria)
            values('FORNECEDORES',old.gid,'D', old.for_codigo);
  end
end
^

/* Trigger: REPL_GRUPODESC_GID */
CREATE TRIGGER REPL_GRUPODESC_GID FOR GRUPO_DESC
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_GRUPODESC_REG */
CREATE TRIGGER REPL_GRUPODESC_REG FOR GRUPO_DESC
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('GRUPO_DESC',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('GRUPO_DESC',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('GRUPO_DESC',old.gid,'D', old.gru_codigo);
  end
end
^

/* Trigger: REPL_GRUPOS_GID */
CREATE TRIGGER REPL_GRUPOS_GID FOR GRUPOS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_GRUPOS_REG */
CREATE TRIGGER REPL_GRUPOS_REG FOR GRUPOS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('GRUPOS',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('GRUPOS',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('GRUPOS',old.gid,'D',old.gru_codigo);
  end
end
^

/* Trigger: REPL_INDCLIENTES_GID */
CREATE TRIGGER REPL_INDCLIENTES_GID FOR INDCLIENTES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_INDCLIENTES_REG */
CREATE TRIGGER REPL_INDCLIENTES_REG FOR INDCLIENTES
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('INDCLIENTES',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('INDCLIENTES',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,chave1,chave2)
            values('INDCLIENTES',old.gid,'D',old.cli_id,old.cli_indid);
  end
end
^

/* Trigger: REPL_ITEMPROMOCLI_REG */
CREATE TRIGGER REPL_ITEMPROMOCLI_REG FOR ITEMPROMOCLI
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('ITEMPROMOCLI',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('ITEMPROMOCLI',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo)
            values('ITEMPROMOCLI',old.gid,'D');
  end
end
^

/* Trigger: REPL_ITEMPROMO_GID */
CREATE TRIGGER REPL_ITEMPROMO_GID FOR ITEMPROMOCLI
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_ITENSPED_GID */
CREATE TRIGGER REPL_ITENSPED_GID FOR ITENS_PED
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_ITENSPED_REG */
CREATE TRIGGER REPL_ITENSPED_REG FOR ITENS_PED
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 2
AS
begin /*$$IBE$$ 
  in autonomous transaction do
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('ITENS_PED',new.ite_gid,'I');
   if (updating) then
    begin
     update or insert into repl_itens (id,tabela,gid,tipo,data, pedido, industria)
            values(gen_id(repl_itens_gen_id,1),'ITENS_PED',new.ite_gid,'U', current_date, old.ite_pedido, old.ite_industria)
            matching(gid);
    end
   if (deleting) then
    begin
     update or insert into repl_itens (id,tabela, gid,tipo, pedido, industria, produto)
            values(gen_id(repl_itens_gen_id,1),'ITENS_PED',old.ite_gid,'D', old.ite_pedido, old.ite_industria, old.ite_produto)
            matching(gid);
    end
  end
 $$IBE$$*/ POST_EVENT '$$IBE$$';
end
^

/* Trigger: REPL_ITENS_ID */
CREATE TRIGGER REPL_ITENS_ID FOR REPL_ITENS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  new.id = gen_id(REPL_ITENS_GEN_ID,1); 
  new.session_id = rdb$get_context('SYSTEM','SESSION_ID'); 
  new.data = cast('now' as date); 
end
^

/* Trigger: REPL_METASIND_GID */
CREATE TRIGGER REPL_METASIND_GID FOR METASIND
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_METASIND_REG */
CREATE TRIGGER REPL_METASIND_REG FOR METASIND
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('METASIND',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('METASIND',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria,produto)
            values('METASIND',old.gid,'D',old.met_industria,old.met_mesano);
  end
end
^

/* Trigger: REPL_PEDIDOS_GID */
CREATE TRIGGER REPL_PEDIDOS_GID FOR PEDIDOS
ACTIVE BEFORE INSERT OR UPDATE POSITION 5
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_PEDIDOS_REG */
CREATE TRIGGER REPL_PEDIDOS_REG FOR PEDIDOS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 2
AS
begin
  /* Replicacao Storeware */
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
     values                 ('PEDIDOS',new.gid,'I');
   if (updating) then
    begin
      update or insert into repl_itens (id, tabela, gid, tipo, data, pedido, industria)
      values(gen_id(repl_itens_gen_id,1),'PEDIDOS',new.gid,'U',current_date, old.ped_pedido, old.ped_industria)
      matching(gid);

--      update or insert into  itens_ped (ite_pedido, ite_industria,gid) values (new.ped_pedido, new.ped_industria, new.gid)
--      matching(ite_pedido, ite_industria);
    end
   if (deleting) then
     insert into repl_itens (tabela, gid, tipo, pedido, industria)
            values('PEDIDOS',old.gid,'D', old.ped_pedido, old.ped_industria);
  end
end
^

/* Trigger: REPL_PRODUTOS_GID */
CREATE TRIGGER REPL_PRODUTOS_GID FOR PRODUTOS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_PRODUTOS_REG */
CREATE TRIGGER REPL_PRODUTOS_REG FOR PRODUTOS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('PRODUTOS',new.gid,'I');
   if (updating) then
    begin
     update or insert into repl_itens (id,tabela,gid,tipo)
     values(gen_id(repl_itens_gen_id,1),'PRODUTOS',new.gid,'U')
     matching(gid);
    end
  end
end
^

/* Trigger: REPL_REGIOES_GID */
CREATE TRIGGER REPL_REGIOES_GID FOR REGIOES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_REGIOES_REG */
CREATE TRIGGER REPL_REGIOES_REG FOR REGIOES
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('REGIOES',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('REGIOES',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('REGIOES',old.gid,'D',old.reg_codigo);
  end
end
^

/* Trigger: REPL_TELEMKT_GID */
CREATE TRIGGER REPL_TELEMKT_GID FOR AGENDA
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_TELEMKT_REG */
CREATE TRIGGER REPL_TELEMKT_REG FOR AGENDA
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin /*$$IBE$$ 
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('AGENDA',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('AGENDA',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('AGENDA',old.gid,'D',old.age_lancto);
  end
 $$IBE$$*/ POST_EVENT '$$IBE$$';
end
^

/* Trigger: REPL_TELE_GID */
CREATE TRIGGER REPL_TELE_GID FOR TELEMKT
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
begin
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_TELE_REG */
CREATE TRIGGER REPL_TELE_REG FOR TELEMKT
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 1
AS
begin /*$$IBE$$ 
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('TELEMKT',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('TELEMKT',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('TELEMKT',old.gid,'D',old.tele_id);
  end
 $$IBE$$*/ POST_EVENT '$$IBE$$';
end
^

/* Trigger: REPL_TRANSP_GID */
CREATE TRIGGER REPL_TRANSP_GID FOR TRANSPORTADORA
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_TRANSP_REG */
CREATE TRIGGER REPL_TRANSP_REG FOR TRANSPORTADORA
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('TRANSPORTADORA',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('TRANSPORTADORA',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('TRANSPORTADORA',old.gid,'D',old.codigo);
  end
end
^

/* Trigger: REPL_VENDEDORIND_GID */
CREATE TRIGGER REPL_VENDEDORIND_GID FOR VENDEDOR_IND
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );
end
^

/* Trigger: REPL_VENDEDORIND_REG */
CREATE TRIGGER REPL_VENDEDORIND_REG FOR VENDEDOR_IND
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('VENDEDOR_IND',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('VENDEDOR_IND',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria,chave1)
            values('VENDEDOR_IND',old.gid,'D',old.vin_industria,old.vin_codigo);
  end
end
^

/* Trigger: REPL_VENDEDOR_GID */
CREATE TRIGGER REPL_VENDEDOR_GID FOR VENDEDORES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
/* Trigger Utilizado para Replicacao */
  if ((new.gid is null)) then
     new.gid =  UUID_TO_CHAR( gen_uuid() );

end
^

/* Trigger: REPL_VENDEDOR_REG */
CREATE TRIGGER REPL_VENDEDOR_REG FOR VENDEDORES
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  in autonomous transaction do 
  begin
   if (inserting) then
     insert into repl_itens (tabela,gid,tipo)
            values('VENDEDORES',new.gid,'I');
   if (updating) then
     insert into repl_itens (tabela,gid,tipo)
            values('VENDEDORES',new.gid,'U');
   if (deleting) then
     insert into repl_itens (tabela,gid,tipo,industria)
            values('VENDEDORES',old.gid,'D',old.ven_codigo);
  end
end
^

/* Trigger: RGBCORES_BI */
CREATE TRIGGER RGBCORES_BI FOR RGBCORES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_rgbcores_id,1);
end
^

/* Trigger: SALDO_PGREC_BI */
CREATE TRIGGER SALDO_PGREC_BI FOR SALDO_PGREC
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.sal_id is null or new.sal_id <=0) then
    new.sal_id = gen_id(gen_saldo_pgrec_id,1);
end
^

/* Trigger: TELEMKT_BI */
CREATE TRIGGER TELEMKT_BI FOR TELEMKT
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.tele_id is null or new.tele_id <= 0) then
    new.tele_id = gen_id(gen_telemkt_id,1);
end
^

/* Trigger: TRANSPORTADORA_BI */
CREATE TRIGGER TRANSPORTADORA_BI FOR TRANSPORTADORA
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.codigo is null or new.codigo <= 0) then
    new.codigo = gen_id(gen_transportadora_id,1);
end
^

/* Trigger: USER_GRUPOS_BD0 */
CREATE TRIGGER USER_GRUPOS_BD0 FOR USER_GRUPOS
ACTIVE BEFORE DELETE POSITION 0
AS
begin
  delete
  from user_menu_superior
  where grupo = old.grupo;
end
^

/* Trigger: USER_NOMES_BI */
CREATE TRIGGER USER_NOMES_BI FOR USER_NOMES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.codigo is null or new.codigo <= 0) then
    new.codigo = gen_id(gen_user_nomes_id,1);
end
^

/* Trigger: USER_NOMES_BI1 */
CREATE TRIGGER USER_NOMES_BI1 FOR USER_NOMES
ACTIVE BEFORE INSERT POSITION 1
AS
begin
  if (new.gerencia is null) then
  new.gerencia = false;
end
^

/* Trigger: VENDEDORES_BI */
CREATE TRIGGER VENDEDORES_BI FOR VENDEDORES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ven_codigo is null or new.ven_codigo <= 0) then
    new.ven_codigo = gen_id(gen_vendedores_id,1);
end
^
SET TERM ; ^



/******************************************************************************/
/****                          Stored procedures                           ****/
/******************************************************************************/



SET TERM ^ ;

ALTER PROCEDURE EXCLUIRRECEB (
    VNUMLANCTO INTEGER,
    VUSARECEB VARCHAR(1))
AS
begin
  if (:vusareceb = 'S') then
  begin
     delete from contaspgrec
     where lan_LANCTO = :vnumlancto;
  end
end^


ALTER PROCEDURE MOVCAIXA (
    DIA DATE,
    OPERACAO VARCHAR(1),
    VALOR DOUBLE PRECISION,
    OPER VARCHAR(20),
    HISTOR BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    USACAIXA VARCHAR(1),
    CONTACRE INTEGER,
    CONTADEB INTEGER,
    CCUSTO INTEGER,
    IDORIGEM INTEGER,
    FLAG CHAR(2))
AS
begin
 if (usacaixa = 'S') then
  insert into caixa  (cai_data, cai_dc, cai_valor, cai_operador, cai_historico, cai_conta, cai_contadebito, cai_ccusto, cai_idorigem, cai_flag)
                      values
                     (:dia, :operacao, :valor, :oper, :histor, :contacre, :contadeb, :ccusto, :idorigem, :flag);
end^


ALTER PROCEDURE PROC_AJUSTASEQ (
    IPEDIDO VARCHAR(10),
    IIND INTEGER)
AS
declare variable VPEDIDO varchar(10);
declare variable VLANCTO varchar(25);
declare variable VAJUSTE integer;
begin
 vajuste = 0;
 for
  select i.ite_pedido, ite_lancto
  from itens_ped i
  where ite_pedido = :ipedido and ite_industria = :iind
  order by ite_lancto
  into :vpedido, :vlancto
  do
  begin
   vajuste = vajuste + 1;
   update itens_ped set ite_seq = :vajuste
   where ite_pedido = :ipedido and ite_lancto = :vlancto;
  end
end^


ALTER PROCEDURE PROC_AREAATU (
    IPESQ VARCHAR(60))
RETURNS (
    ID INTEGER,
    DESCRICAO VARCHAR(60))
AS
begin
 if (ipesq is null) then ipesq = '';
 if (char_length(ipesq) = 0) then ipesq = '';

 if (char_length(ipesq) = 0) then
  begin
   for
    select a.atu_id, a.atu_descricao
    from area_atu a
    order by a.atu_descricao
    into :id, :descricao
   do
   suspend;
  end

 if (char_length(ipesq) > 0) then
  begin
   ipesq = Upper(ipesq);
   for
    select a.atu_id, a.atu_descricao
    from area_atu a
    where Upper(a.atu_descricao) like '%'||:ipesq||'%'
    order by a.atu_descricao
    into :id, :descricao
   do
   suspend;
  end
end^


ALTER PROCEDURE PROC_ATV_POR_OPER
RETURNS (
    OGERAL INTEGER,
    OMES INTEGER,
    ODIA INTEGER,
    OOPERADOR VARCHAR(25))
AS
begin
 for
    select
        tele.age_operador,
        count(tele.age_operador) as total_ligacoes_geral,
        count(case when cast(tele.age_data as date) >= dateadd(day, 1 - extract(day from current_date), current_date)
                   and cast(tele.age_data as date) < dateadd(month, 1, dateadd(day, 1 - extract(day from current_date), current_date))
                   then 1 end) as ligacoes_mes_atual,
        count(case when cast(tele.age_data as date) = current_date
                   then 1 end) as ligacoes_dia_atual
    from
        crm_interacoes tele
    group by
        tele.age_operador
    order by
        tele.age_operador
    into :ooperador, :ogeral, :omes, :odia
  do
  suspend;
end^


ALTER PROCEDURE PROC_ATZCODORI (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
declare variable VORIG varchar(15);
declare variable VPRODUTO varchar(25);
declare variable VEMBUCH varchar(25);
begin
 for
  select it.ite_produto, it.ite_embuch, substring(p.ite_conversao from 1 for 15)
         from itens_ped it
         join produtos p on it.ite_produto = p.pro_codprod and p.pro_industria = :iindustria and p.pro_nometabela = :itabela
         where ite_pedido = :ipedido and ite_industria = :iindustria
         order by 1
         into :vproduto, :vembuch, :vorig
  do
  begin
    -- atualiza tabela itens_ped
    update itens_ped set ite_embuch = :vorig
    where ite_produto = :vproduto and ite_embuch = :vembuch and ite_pedido = :ipedido;
  end
end^


ALTER PROCEDURE PROC_ATZDESCADD (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
declare variable VADD numeric(6,2);
declare variable VPRODUTO varchar(25);
declare variable VEMBUCH varchar(25);
declare variable VADD2 numeric(6,2);
begin
 for
  select it.ite_produto, it.ite_embuch, coalesce(p.pro_descadic, 0), coalesce(p.pro_descadic2, 0)
         from itens_ped it
         join produtos p on it.ite_produto = p.pro_codprod and p.pro_industria = :iindustria and p.pro_nometabela = :itabela
         where ite_pedido = :ipedido and ite_industria = :iindustria
         order by 1
         into :vproduto, :vembuch, :vadd, :vadd2
  do
  begin
    -- atualiza tabela itens_ped
    update itens_ped set ite_des10 = :vadd, ite_des11 = :vadd2
    where ite_produto = :vproduto and ite_embuch = :vembuch and ite_pedido = :ipedido;
  end
end^


ALTER PROCEDURE PROC_ATZGRUPO (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
declare variable VDESC1 numeric(6,2);
declare variable VDESC2 numeric(6,2);
declare variable VDESC3 numeric(6,2);
declare variable VDESC4 numeric(6,2);
declare variable VDESC5 numeric(6,2);
declare variable VDESC6 numeric(6,2);
declare variable VDESC7 numeric(6,2);
declare variable VDESC8 numeric(6,2);
declare variable VDESC9 numeric(6,2);
declare variable VDESP1 numeric(6,2);
declare variable VDESP2 numeric(6,2);
declare variable VDESP3 numeric(6,2);
declare variable VDESP4 numeric(6,2);
declare variable VDESP5 numeric(6,2);
declare variable VDESP6 numeric(6,2);
declare variable VDESP7 numeric(6,2);
declare variable VDESP8 numeric(6,2);
declare variable VDESP9 numeric(6,2);
declare variable VPRODUTO varchar(25);
declare variable VEMBUCH varchar(25);
declare variable VGRUPODES integer;
declare variable VGRUPOPRO integer;
declare variable VCLIENTE integer;
declare variable VCLIIND integer;
begin
 vdesc1 = 0;
 vdesc2 = 0;
 vdesc3 = 0;
 vdesc4 = 0;
 vdesc5 = 0;
 vdesc6 = 0;
 vdesc7 = 0;
 vdesc8 = 0;
 vdesc9 = 0;

 select p1.ped_tabela, p1.ped_cliente,
        coalesce(p1.ped_pri,0), coalesce(p1.ped_seg,0), coalesce(p1.ped_ter,0),
        coalesce(p1.ped_qua,0), coalesce(p1.ped_qui,0), coalesce(p1.ped_sex,0),
        coalesce(p1.ped_set,0), coalesce(p1.ped_oit,0), coalesce(p1.ped_nov,0),
        coalesce(d.cli_codigo,0)
 from pedidos p1
 left join cli_ind d on p1.ped_cliente = d.cli_codigo and p1.ped_industria = d.cli_forcodigo
 where p1.ped_pedido = :ipedido and p1.ped_industria = :iindustria
 into :itabela, :vcliente, :vdesp1, :vdesp2, :vdesp3, :vdesp4, :vdesp5, :vdesp6,
      :vdesp7, :vdesp8, :vdesp9, :vcliind;

 vdesc1 = vdesp1; --desconto do pedido
 vdesc2 = vdesp2;
 vdesc3 = vdesp3;
 vdesc4 = vdesp4;
 vdesc5 = vdesp5;
 vdesc6 = vdesp6;
 vdesc7 = vdesp7;
 vdesc8 = vdesp8;
 vdesc9 = vdesp9;

 for
  select it.ite_produto, it.ite_embuch, coalesce(p.pro_grupopro, 0) grpro, coalesce(p.pro_grupo, 0) grdesc
         from itens_ped it
         join produtos p on it.ite_produto = p.pro_codprod and p.pro_industria = :iindustria
         where ite_pedido = :ipedido and
               ite_industria = :iindustria and
               p.pro_nometabela = :itabela
         order by 1
         into :vproduto, :vembuch, :vgrupopro, :vgrupodes
  do
  begin

    if (vgrupodes > 0) then  -- busca primeiramente por grupo de descontos
    begin
     select coalesce(g1.gru_desc1, 0), coalesce(g1.gru_desc2, 0), coalesce(g1.gru_desc3, 0),
            coalesce(g1.gru_desc4, 0), coalesce(g1.gru_desc5, 0), coalesce(g1.gru_desc6, 0),
            coalesce(g1.gru_desc7, 0), coalesce(g1.gru_desc8, 0), coalesce(g1.gru_desc9, 0)
     from grupo_desc g1
     where g1.gru_codigo = :vgrupodes
     into :vdesc1,:vdesc2,:vdesc3,:vdesc4,:vdesc5,:vdesc6,:vdesc7,:vdesc8,:vdesc9;
    end


    if (vcliind > 0) then  -- desconto do cliente na industria (cli_ind)
     begin
      select coalesce(ci.cli_desc1, 0), coalesce(ci.cli_desc2, 0), coalesce(ci.cli_desc3, 0),
             coalesce(ci.cli_desc4, 0), coalesce(ci.cli_desc5, 0), coalesce(ci.cli_desc6, 0),
             coalesce(ci.cli_desc7, 0), coalesce(ci.cli_desc8, 0), coalesce(ci.cli_desc9, 0)
      from cli_ind ci
      where ci.cli_codigo = :vcliente and
            ci.cli_forcodigo = :iindustria
      into :vdesc1,:vdesc2,:vdesc3,:vdesc4,:vdesc5,:vdesc6,:vdesc7,:vdesc8,:vdesc9;
    end


    if (vgrupopro > 0) then -- desconto por grupo de produtos tem prioridade
    begin
     select coalesce(g2.cli_desc1, 0), coalesce(g2.cli_desc2, 0), coalesce(g2.cli_desc3, 0),
            coalesce(g2.cli_desc4, 0), coalesce(g2.cli_desc5, 0), coalesce(g2.cli_desc6, 0),
            coalesce(g2.cli_desc7, 0), coalesce(g2.cli_desc8, 0), coalesce(g2.cli_desc9, 0)
     from cli_descpro g2
     where g2.cli_grupo = :vgrupopro and
           g2.cli_codigo = :vcliente and
           g2.cli_forcodigo = :iindustria
     into :vdesc1,:vdesc2,:vdesc3,:vdesc4,:vdesc5,:vdesc6,:vdesc7,:vdesc8,:vdesc9;
    end

    -- atualiza tabela itens_ped
    if ((vdesc1+vdesc2+vdesc3) > 0) then
     begin
      update itens_ped set ite_des1 = :vdesc1, ite_des2 = :vdesc2, ite_des3 = :vdesc3, ite_des4 = :vdesc4,
                           ite_des5 = :vdesc5, ite_des6 = :vdesc6, ite_des7 = :vdesc7, ite_des8 = :vdesc8,
                           ite_des9 = :vdesc9
      where ite_produto = :vproduto and ite_embuch = :vembuch and ite_pedido = :ipedido;
    end
   vdesc1 = vdesp1; --desconto do pedido
   vdesc2 = vdesp2;
   vdesc3 = vdesp3;
   vdesc4 = vdesp4;
   vdesc5 = vdesp5;
   vdesc6 = vdesp6;
   vdesc7 = vdesp7;
   vdesc8 = vdesp8;
   vdesc9 = vdesp9;
   vgrupodes = 0;
   vgrupopro = 0;
  end
end^


ALTER PROCEDURE PROC_ATZIPI (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
declare variable VIPI numeric(6,2);
declare variable VPRODUTO varchar(25);
declare variable VEMBUCH varchar(25);
begin
 for
  select it.ite_produto, it.ite_embuch, coalesce(p.pro_ipi, 0)
         from itens_ped it
         join produtos p on it.ite_produto = p.pro_codprod and p.pro_industria = :iindustria and p.pro_nometabela = :itabela
         where ite_pedido = :ipedido and ite_industria = :iindustria
         order by 1
         into :vproduto, :vembuch, :vipi
  do
  begin
    -- atualiza tabela itens_ped
    update itens_ped set ite_ipi = :vipi
    where ite_produto = :vproduto and ite_embuch = :vembuch and ite_pedido = :ipedido;
  end
end^


ALTER PROCEDURE PROC_ATZLOTE (
    IID INTEGER,
    IFLAG CHAR(2),
    IPLACON INTEGER,
    IDC CHAR(1))
AS
begin
  if (iflag = 'CX') then -- origem no caixa
   begin
     merge into lote lt
     using (select cx.cai_lancamento, cx.cai_data, cx.cai_dc, cx.cai_historico, cx.cai_valor, cx.cai_ccusto
            from caixa cx
            where cx.cai_lancamento = :iid) cx
     on lt.lot_idorigem = cx.cai_lancamento and lt.lot_placon = :iplacon and lt.lot_flag = 'CX'

     when not matched then
       insert (lot_flag, lot_idorigem, lot_debcre, lot_placon, lot_valor, lot_historico, lot_ccusto, lot_data)
       values ('CX', cx.cai_lancamento, :idc, :iplacon, cx.cai_valor, cx.cai_historico, cx.cai_ccusto, cx.cai_data)

     when matched then
       update set lot_flag = 'CX', lot_idorigem = cx.cai_lancamento, lot_debcre = :idc, lot_placon = :iplacon,
                   lot_valor = cx.cai_valor, lot_historico = cx.cai_historico, lot_ccusto = cx.cai_ccusto, lot_data = cx.cai_data;
   end

  if (iflag = 'PR') then -- origem no contas a pagar/receber
   begin
     merge into lote lt
     using (select f.cta_id, f.cta_data, f.cta_descpagamento, f.cta_valorpago, c.lan_conta, f.cta_contacx
            from fracrecebimentos f
            join contaspgrec c on f.cta_docto = c.lan_docto and f.cta_parcela = c.lan_parcela
            where f.cta_id = :iid) f
     on lt.lot_idorigem = f.cta_id and lt.lot_placon = :iplacon and lt.lot_flag = 'PR'

     when not matched then
       insert (lot_flag, lot_idorigem, lot_debcre, lot_placon, lot_valor, lot_historico, lot_ccusto, lot_data)
       values ('PR', f.cta_id, :idc, :iplacon, f.cta_valorpago, f.cta_descpagamento, f.cta_contacx, f.cta_data)

     when matched then
       update set lot_flag = 'PR', lot_idorigem = f.cta_id, lot_debcre = :idc, lot_placon = :iplacon,
                   lot_valor = f.cta_valorpago, lot_historico = f.cta_descpagamento, lot_ccusto = f.cta_contacx, lot_data = f.cta_data;
   end

end^


ALTER PROCEDURE PROC_ATZMULTIPLOS (
    IINDUSTRIA INTEGER,
    IPEDIDO VARCHAR(10))
AS
declare variable MULTIPLO double precision;
declare variable MULTIPLOPED double precision;
declare variable AJUSTE double precision;
declare variable RESTO double precision;
declare variable VTABELA varchar(20);
declare variable VPRODUTO varchar(25);
declare variable VEMBUCH varchar(25);
begin
  select p.ped_tabela
  from pedidos p
  where p.ped_pedido = :ipedido and p.ped_industria = :iindustria
  into :vtabela;

  resto  = 0;
  ajuste = 0;
  for
  select ite_quant, ite_produto, ite_embuch
         from itens_ped it
         where ite_pedido = :ipedido and ite_industria = :iindustria
         order by 1
         into :multiploped, :vproduto, :vembuch
  do
  begin
      select first 1 p.pro_embalagem
      from produtos p
      where (p.pro_codprod = :vproduto or p.ite_codigo2 = :vproduto) and
            p.pro_nometabela = :vtabela and p.pro_industria = :iindustria
      into :multiplo;

      if (multiplo > 0) then
        begin
           ajuste = :multiploped;
           if (multiploped <= multiplo)  then ajuste = :multiplo;
           if (multiploped > multiplo) then
            begin
              resto = multiploped / multiplo;
              if ((resto - trunc(resto, 0)) > 0) then
               begin
                 resto  = trunc(resto) + 1;
                 ajuste = multiplo * resto;
               end
            end
        end
        -- atualiza os itens do pedido
        update itens_ped set ite_quant = :ajuste, ite_exportado = 'M'
        where ite_produto = :vproduto and ite_embuch = :vembuch and ite_pedido = :ipedido;
  end

end^


ALTER PROCEDURE PROC_ATZTBNOVA (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
declare variable VDESC1 numeric(6,2);
declare variable VDESC2 numeric(6,2);
declare variable VDESC3 numeric(6,2);
declare variable VDESC4 numeric(6,2);
declare variable VDESC5 numeric(6,2);
declare variable VDESC6 numeric(6,2);
declare variable VDESC7 numeric(6,2);
declare variable VDESC8 numeric(6,2);
declare variable VDESC9 numeric(6,2);
declare variable PRECO1 double precision;
declare variable PRECO2 double precision;
declare variable PRECO3 double precision;
declare variable VCLIENTE integer;
declare variable VPRECOUNI double precision;
declare variable EHPROMO char(10);
declare variable VPRODUTO varchar(25);
declare variable VVALIDADE date;
declare variable VVALORCLI double precision;
begin
 for
  select ite_produto, ite_cliente, coalesce(p.pro_valornormal, 0), coalesce(p.pro_valorpromo, 0), coalesce(p.pro_preco3, 0),
         it.ite_des1, it.ite_des2, it.ite_des3, it.ite_des4, it.ite_des5, it.ite_des6, it.ite_des7, it.ite_des8, it.ite_des9
         from itens_ped it
         join produtos p on it.ite_produto = p.pro_codprod and p.pro_industria = :iindustria and p.pro_nometabela = :itabela
         where ite_pedido = :ipedido and ite_industria = :iindustria
         order by 1
         into :vproduto,:vcliente,:preco1,:preco2,:preco3,:vdesc1,:vdesc2,:vdesc3,:vdesc4,:vdesc5,:vdesc6,:vdesc7,:vdesc8,:vdesc9
  do
  begin
    vprecouni = :preco1;
    ehpromo   = '1';

    if (preco2 > 0) then  -- item com preco liquido
    begin
     vdesc1 = 0;
     vdesc2 = 0;
     vdesc3 = 0;
     vdesc4 = 0;
     vdesc5 = 0;
     vdesc6 = 0;
     vdesc7 = 0;
     vdesc8 = 0;
     vdesc9 = 0;
     vprecouni = :preco2;
     ehpromo   = '2';
    end

    if (preco2 = 0 and preco3 > 0) then  -- item com preco 3
    begin
     vprecouni = :preco3;
     ehpromo   = '1';
    end

    select item_validade, coalesce(item_valor, 0) -- verifica se o cliente tem desconto especial
    from itempromocli i
    join clientes c on i.item_cliid = c.cli_codigo
    where item_procodprod = :vproduto and item_tabela = :itabela and item_cliid = :vcliente and item_industria= :iindustria
    into :vvalidade, :vvalorcli;
    if (current_date < :vvalidade) then
      vprecouni = :vvalorcli;

    -- atualiza tabela itens_ped
    update itens_ped set ite_puni = :vprecouni, ite_cotacao = :ehpromo,
                         ite_des1 = :vdesc1, ite_des2 = :vdesc2, ite_des3 = :vdesc3, ite_des4 = :vdesc4,
                         ite_des5 = :vdesc5, ite_des6 = :vdesc6, ite_des7 = :vdesc7, ite_des8 = :vdesc8,  ite_des9 = :vdesc9
    where ite_produto = :vproduto and ite_pedido = :ipedido;
  end
end^


ALTER PROCEDURE PROC_ATZTOTAIS (
    IINDUSTRIA INTEGER,
    IPEDIDO VARCHAR(10),
    ICLIESPECIAL CHAR(1),
    ISEPARAPORGRUPO CHAR(1),
    IREPETEITEM BOOLEAN)
AS
declare variable UNIBRUTO double precision;
declare variable UNILIQ double precision;
declare variable APRODUTO varchar(25);
declare variable AQUANT double precision;
declare variable AUNI double precision;
declare variable ADESCADD numeric(6,2);
declare variable ADES1 numeric(6,2);
declare variable ADES2 numeric(6,2);
declare variable ADES3 numeric(6,2);
declare variable ADES4 numeric(6,2);
declare variable ADES5 numeric(6,2);
declare variable ADES6 numeric(6,2);
declare variable ADES7 numeric(6,2);
declare variable ADES8 numeric(6,2);
declare variable ADES9 numeric(6,2);
declare variable ADES10 numeric(6,2);
declare variable ADES11 numeric(6,2);
declare variable VPERIPI double precision;
declare variable VPERST double precision;
declare variable VEMBALAGEM integer;
declare variable VNOMEPRO varchar(100);
declare variable VTABELA varchar(20);
declare variable VGRUPOPRO integer;
declare variable VNOMEGRUPO varchar(50);
declare variable XRESTO double precision;
declare variable XEXPORTADO char(1);
declare variable ANOMEPRO varchar(100);
declare variable AVALCOMIPI double precision;
declare variable AVALCOMST double precision;
declare variable VVAL17 double precision;
declare variable VTEXTODESCONTO varchar(200);
declare variable VTOTBRU2 double precision;
declare variable VLIQ2 double precision;
declare variable VTOTCOMIPI double precision;
declare variable VSUFRAMA varchar(15);
declare variable VEHPROMO char(1);
declare variable VPRECO1 double precision;
declare variable VPRECO2 double precision;
declare variable EXISTECAD varchar(25);
declare variable VLANCTO integer;
declare variable VTROUBLE boolean;
declare variable VPEDCLIENTE varchar(25);
declare variable ITE_NUMPEDCLI varchar(25);
begin
  select p.ped_tabela, c.cli_suframa, p.ped_cliind
  from pedidos p
  join clientes c on c.cli_codigo = p.ped_cliente
  where p.ped_pedido = :ipedido and p.ped_industria = :iindustria
  into :vtabela, :vsuframa, :vpedcliente;

  vtotbru2 = 0;
  vliq2    = 0;
  vtotcomipi = 0;

  for
  select ite_produto, ite_quant, coalesce(ite_puni,0), ite_descadic,
         coalesce(ite_des1, 0) ite_des1, coalesce(ite_des2, 0) ite_des2, coalesce(ite_des3, 0) ite_des3,
         coalesce(ite_des4, 0) ite_des4, coalesce(ite_des5, 0) ite_des5, coalesce(ite_des6, 0) ite_des6,
         coalesce(ite_des7, 0) ite_des7, coalesce(ite_des8, 0) ite_des8, coalesce(ite_des9, 0) ite_des9,
         coalesce(ite_des10, 0) ite_des10, coalesce(ite_des11, 0) ite_des11,
         left(it.ite_nomeprod, 100), coalesce(it.ite_cotacao, '1'), it.ite_lancto, coalesce(it.ite_numpedcli, '')
         from itens_ped it
         where ite_pedido = :ipedido and ite_industria = :iindustria
         order by it.ite_lancto
         into :aproduto, :aquant, :auni, :adescadd, :ades1,
              :ades2, :ades3, :ades4, :ades5,:ades6, :ades7, :ades8, :ades9, :ades10, :ades11,
              :anomepro, :vehpromo, :vlancto, :ite_numpedcli
  do
  begin
        -- pesquisa o produto na tabela
        vpreco1 = 0;
        vpreco2 = 0;
        vtrouble = false;

        select first 1 p.pro_embalagem, p.pro_nome, p.pro_ipi, p.pro_st, coalesce(p.pro_grupopro, 0) grupopro,
               g.gru_nome, p.pro_valornormal, p.pro_valorpromo, p.pro_codprod
        from produtos p
        left join grupos g on p.pro_grupopro = g.gru_codigo
        where (p.ite_codigo2 = :aproduto or p.pro_codprod = :aproduto) and
              p.pro_nometabela = :vtabela and p.pro_industria = :iindustria
        into :vembalagem, :vnomepro, :vperipi, :vperst, :vgrupopro, :vnomegrupo, :vpreco1, :vpreco2, :existecad;

        if (character_length(existecad) > 0) then  --se existe produto cadastrado na tabela
         begin
            if (:auni = 0) then  -- se o pedido veio sem pre?o
             begin
               if (vpreco2 > 0 and vehpromo = '2') then
                begin
                 auni = vpreco2;
                 vehpromo = '2';
                 ades1 = 0;
                 ades2 = 0;
                 ades3 = 0;
                 ades4 = 0;
                 ades5 = 0;
                 ades6 = 0;
                 ades7 = 0;
                 ades8 = 0;
                 ades9 = 0;
                 ades10 = 0;
                 ades11 = 0;
                 adescadd = 0;
                end
              if (vpreco1 > 0 and vehpromo = '1') then
                auni = vpreco1;
             end
            unibruto = :auni;
            uniliq = :auni;
         end -- do verifica se item existe
        if (existecad is null ) then
          vtrouble = true;
    
        if (vehpromo <> '2') then
         begin
            if (ades1 > 0) then
            uniliq = uniliq - (uniliq * ades1/100);
            if (ades2 > 0) then
            uniliq = uniliq - (uniliq * ades2/100);
            if (ades3 > 0) then
            uniliq = uniliq - (uniliq * ades3/100);
            if (ades4 > 0) then
            uniliq = uniliq - (uniliq * ades4/100);
            if (ades5 > 0) then
            uniliq = uniliq - (uniliq * ades5/100);
            if (ades6 > 0) then
            uniliq = uniliq - (uniliq * ades6/100);
            if (ades7 > 0) then
            uniliq = uniliq - (uniliq * ades7/100);
            if (ades8 > 0) then
            uniliq = uniliq - (uniliq * ades8/100);
            if (ades9 > 0) then
            uniliq = uniliq - (uniliq * ades9/100);
            if (ades10 > 0) then
            uniliq = uniliq - (uniliq * ades10/100);
            if (ades11 > 0) then
            uniliq = uniliq - (uniliq * ades11/100);
            if (adescadd > 0) then -- coeficiente
            uniliq = unibruto * adescadd;
         end
        -- ** --
        xexportado = 'N'; -- normal
        if (vembalagem > 0) then
        begin
         xresto = :aquant;
         xresto = xresto / vembalagem;
         if (xresto - trunc(xresto) > 0) then
          xexportado = 'Q'; --quebrado
        end

        --verifica se o item tem algum pre?o cadastrado na tabela
        if (character_length(anomepro) = 0) then
         anomepro = '*'||vnomepro;
    
    
        --nome do produto
        if (anomepro is null) then
        anomepro = vnomepro;
        if (anomepro = ' ') then
        anomepro = vnomepro;
        if (anomepro = 'Descricao do item') then
        anomepro = vnomepro;
        if (anomepro = 'SEM DESCRICAO') then
        anomepro = vnomepro;
        -- IPI e ST
        vval17     = uniliq;
        avalcomipi = vval17;
        vperipi = coalesce(vperipi,0);
        vperst  = coalesce(vperst,0);

        if (char_length(trim(vsuframa)) > 4) then
        vperipi = 0;

        if (icliespecial = 'S') then
        vperst = 0;

        if (vperipi > 0) then
        avalcomipi = (vval17 + (vVal17 * (vperipi / 100)));

        if (vperst > 0 and vperipi > 0) then
        avalcomst = (avalcomipi + (avalcomipi * (vperst / 100)));
        if (vperst > 0 and vperipi = 0) then
        avalcomst = (vval17 + (vval17 * (vperst / 100)));
        if (vperst = 0 and vperipi > 0) then
        avalcomst  = avalcomipi;
        if (vperst = 0 and vperipi = 0) then
        avalcomst  = avalcomipi;

        -- descontos
        vtextodesconto = '';
        if (ades1 > 0) then
        vtextodesconto = ades1||'%';
        if (ades2 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades2||'%';
        if (ades3 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades3||'%';
        if (ades4 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades4||'%';
        if (ades5 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades5||'%';
        if (ades6 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades6||'%';
        if (ades7 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades7||'%';
        if (ades8 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades8||'%';
        if (ades9 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades9||'%';
        if (ades10 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades10||'%';
        if (ades11 > 0) then
        vtextodesconto = vtextodesconto||'+'||ades11||'%';
        if (adescadd > 0) then
        vtextodesconto = vtextodesconto||' Fator: '||adescadd||'%';
        if (ades1 = 0 and vtextodesconto = '') then
        vtextodesconto = 'ITENS COM PRECO LIQUIDO';
        if (vehpromo = '2') then
        vtextodesconto = 'ITENS EM PROMOCAO';
        if (vgrupopro > 0 and :iseparaporgrupo = 'S') then
        vtextodesconto = left(vtextodesconto||'   '||'   Grupo: '||vnomegrupo, 200);
--            if ((ades1+ades2) = 0) then
--              if (vehpromo <> '2') then
--                vtextodesconto = 'ITENS COM PRECO LIQUIDO';

        if (character_length(ite_numpedcli) = 0) then
         ite_numpedcli = coalesce(:vpedcliente, '');

        vtotbru2   = vtotbru2 + (aquant * unibruto);
        vliq2      = vliq2 + (aquant * uniliq);
        vtotcomipi = vtotcomipi + (aquant * (:avalcomst));


        -- atualiza os itens do pedido
        if (irepeteitem = true) then   -- repete itens
         begin
            update itens_ped set  ite_ipi = :vperipi, ite_st = :vperst, ite_valcomipi = :avalcomipi, ite_valcomst = :avalcomst,
                                  ite_puniliqcomimposto = :avalcomst,
                                  ite_puniliq = :uniliq, ite_totliquido = (:aquant * :uniliq),
                                  ite_totbruto = (:aquant * :unibruto),
                                  ite_descontos = :vtextodesconto, ite_nomeprod = :anomepro, ite_exportado = :xexportado,
                                  ite_puni = :auni, ite_cotacao = :vehpromo,
                                  ite_des1 = :ades1, ite_des2 = :ades2, ite_des3 = :ades3, ite_des4 = :ades4,
                                  ite_des5 = :ades5, ite_des6 = :ades6, ite_des7 = :ades7, ite_des8 = :ades8,
                                  ite_des9 = :ades9, ite_des10 = :ades10, ite_des11 = :ades11,
                                  ite_descadic = :adescadd, ite_status = iif(:vtrouble=true, 'S', 'N'),
                                  ite_numpedcli = :ite_numpedcli
            where ite_produto   = :aproduto and
                  ite_pedido    = :ipedido and
                  ite_industria = :iindustria and
                  ite_lancto    = :vlancto;
        end
       if (irepeteitem = false) then  -- NAO repete itens
        begin
            update itens_ped set  ite_ipi = :vperipi, ite_st = :vperst, ite_valcomipi = :avalcomipi, ite_valcomst = :avalcomst,
                                  ite_puniliqcomimposto =  :avalcomst,
                                  ite_puniliq = :uniliq, ite_totliquido = (:aquant * :uniliq),
                                  ite_totbruto = (:aquant * :unibruto),
                                  ite_descontos = :vtextodesconto, ite_nomeprod = :anomepro, ite_exportado = :xexportado,
                                  ite_puni = :auni, ite_cotacao = :vehpromo,
                                  ite_des1 = :ades1, ite_des2 = :ades2, ite_des3 = :ades3, ite_des4 = :ades4,
                                  ite_des5 = :ades5, ite_des6 = :ades6, ite_des7 = :ades7, ite_des8 = :ades8,
                                  ite_des9 = :ades9, ite_des10 = :ades10, ite_des11 = :ades11,
                                  ite_descadic = :adescadd, ite_status = iif(:vtrouble=true, 'S', 'N'),
                                  ite_numpedcli = :ite_numpedcli
            where ite_produto   = :aproduto and
                  ite_pedido    = :ipedido and
                  ite_industria = :iindustria;
        end
  end
  -- atualiza os totais do pedido
  update pedidos set ped_totbruto = :vtotbru2, ped_totliq = :vliq2, ped_totalipi = :vtotcomipi
  where ped_pedido = :ipedido and ped_industria = :iindustria;
end^


ALTER PROCEDURE PROC_ATZTOTAIS2 (
    IINDUSTRIA INTEGER,
    IPEDIDO VARCHAR(10),
    ICHAR CHAR(1),
    IADD CHAR(4))
AS
declare variable APRODUTO varchar(25);
declare variable ALISTA varchar(100);
declare variable ALANCTO integer;
declare variable VTABELA varchar(20);
declare variable ACODIGO varchar(20);
declare variable AENCONTRADO varchar(20);
-- essa funcao ? para tentar achar o codigo no meio dos outros
begin
 select p.ped_tabela
 from pedidos p
 where p.ped_pedido = :ipedido and p.ped_industria = :iindustria
 into :vtabela;

 for
  select ite_lancto, ite_produto, it.ite_produto||:ichar
  from itens_ped it
  where ite_pedido = :ipedido and ite_industria = :iindustria
  order by 1
  into :alancto, :aproduto, :alista
  do
  begin
   for
    select ss.texto
    from sp_splitstring(upper(:alista), :ichar) ss
    into :acodigo
    do
    begin
     select first 1 p.ite_codigo2, p.pro_codprod
     from produtos p
     where p.pro_industria = :iindustria and
           p.pro_nometabela = :vtabela and
           upper(p.ite_codigo2) containing upper(:acodigo) or
           upper(p.ite_codigo2) containing upper(trim(:iadd)||:acodigo)
     group by 1,2
     into :aencontrado, :aproduto;

     if (character_length(:aencontrado) > 1) then
      begin
       update itens_ped set ite_produto = :aproduto
       where ite_lancto = :alancto;
      end
    end
    aencontrado = '';
  end
end^


ALTER PROCEDURE PROC_ATZVLRNORMAL (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20),
    EHPROMO CHAR(1))
AS
declare variable VVALOR double precision;
declare variable VPRODUTO varchar(25);
begin
 if (ehpromo = '1') then -- preco normal
  begin
     for
      select ite_produto, coalesce(p.pro_valornormal, 0)
             from itens_ped it
             join produtos p on it.ite_produto = p.pro_codprod and p.pro_industria = :iindustria
             where ite_pedido = :ipedido and ite_industria = :iindustria and p.pro_nometabela = :itabela
             order by 1
             into :vproduto,  :vvalor
      do
      begin
        -- atualiza tabela itens_ped
        update itens_ped set ite_puni = :vvalor, ite_cotacao = :ehpromo
        where ite_produto = :vproduto and ite_pedido = :ipedido;
      end
  end
  else
  begin
     for
       select ite_produto, coalesce(p.pro_valorpromo, 0)
       from itens_ped it
       join produtos p on it.ite_produto = p.pro_codprod and p.pro_industria = :iindustria
       where ite_pedido = :ipedido and ite_industria = :iindustria and p.pro_nometabela = :itabela
       order by 1
       into :vproduto, :vvalor
      do
      begin
       -- atualiza tabela itens_ped
       update itens_ped set ite_puni = :vvalor, ite_cotacao = :ehpromo
       where ite_produto = :vproduto and ite_pedido = :ipedido;
      end
  end
end^


ALTER PROCEDURE PROC_BAIXAFATURADOS (
    IFOR INTEGER,
    IPEDIDO VARCHAR(10))
AS
declare variable VTOTPED double precision;
declare variable VSOMAFAT double precision;
begin
  select sum(f.fat_valorfat)
  from fatura_ped f
  where f.fat_pedido = :ipedido and f.fat_industria = :ifor
  into :vsomafat;

  select p.ped_totliq
  from pedidos p
  where p.ped_pedido = :ipedido and p.ped_industria = :ifor
  into :vtotped;

  if (vsomafat >= vtotped) then
   begin
    update pedidos set ped_situacao = 'F'
    where ped_industria = :ifor and ped_pedido = :ipedido;
   end
end^


ALTER PROCEDURE PROC_BUSCADADOSCLI (
    ICLIENTE INTEGER,
    IFOR INTEGER)
RETURNS (
    OCOMPRADOR VARCHAR(55),
    OEMAILCOMPRADOR VARCHAR(60),
    OTRANSP INTEGER,
    ODESC1 DOUBLE PRECISION,
    ODESC2 DOUBLE PRECISION,
    ODESC3 DOUBLE PRECISION,
    ODESC4 DOUBLE PRECISION,
    ODESC5 DOUBLE PRECISION,
    ODESC6 DOUBLE PRECISION,
    ODESC7 DOUBLE PRECISION,
    ODESC8 DOUBLE PRECISION,
    ODESC9 DOUBLE PRECISION,
    ODESC10 DOUBLE PRECISION,
    OPRAZO VARCHAR(20),
    OTABELA VARCHAR(20),
    OIPI DOUBLE PRECISION,
    ONOMRED VARCHAR(30),
    OVENDEDOR INTEGER,
    OSUFRAMA VARCHAR(15),
    OREDELOJA VARCHAR(35),
    OOBSPEDIDO VARCHAR(300),
    OFRETE CHAR(1))
AS
declare variable VFDESC1 double precision;
declare variable VFDESC2 double precision;
declare variable VFDESC3 double precision;
declare variable VFDESC4 double precision;
declare variable VFDESC5 double precision;
declare variable VFDESC6 double precision;
declare variable VFDESC7 double precision;
declare variable VFDESC8 double precision;
declare variable VFDESC9 double precision;
declare variable VFDESC10 double precision;
declare variable VCDESC1 double precision;
declare variable VCDESC2 double precision;
declare variable VCDESC3 double precision;
declare variable VCDESC4 double precision;
declare variable VCDESC5 double precision;
declare variable VCDESC6 double precision;
declare variable VCDESC7 double precision;
declare variable VCDESC8 double precision;
declare variable VCDESC9 double precision;
declare variable VCDESC10 double precision;
declare variable VCOMPRADOR varchar(50);
begin
  -- industria
  select
  coalesce(f.for_des1, 0), coalesce(f.for_des2, 0), coalesce(f.for_des3, 0), coalesce(f.for_des4, 0),
  coalesce(f.for_des5, 0), coalesce(f.for_des6, 0), coalesce(f.for_des7, 0), coalesce(f.for_des8, 0),
  coalesce(f.for_des9, 0), coalesce(f.for_des10, 0)
  from fornecedores f
  where f.for_codigo = :ifor
  into :vfdesc1, :vfdesc2, :vfdesc3, :vfdesc4, :vfdesc5, :vfdesc6, :vfdesc7, :vfdesc8, :vfdesc9, :vfdesc10;

  --cliente
  select
  c.cli_nomred, c.cli_vendedor, c.cli_suframa, c.cli_redeloja, c.cli_obspedido
  from clientes c
  where c.cli_codigo = :icliente
  into
  :onomred, :ovendedor, :osuframa, :oredeloja, :oobspedido;

  --dados do particular do cliente
  select
  first 1 c.ani_nome, c.ani_email
  from cli_aniv c
  where c.ani_cliente = :icliente and
        c.ani_funcao like '%'||'COMPRA'||'%'
  into :ocomprador, :oemailcomprador;

  select i.cli_transportadora,
         coalesce(i.cli_desc1, 0), coalesce(i.cli_desc2, 0), coalesce(i.cli_desc3, 0),
         coalesce(i.cli_desc4, 0), coalesce(i.cli_desc5, 0), coalesce(i.cli_desc6, 0),
         coalesce(i.cli_desc7, 0), coalesce(i.cli_desc8, 0), coalesce(i.cli_desc9,  0),
         coalesce(i.cli_desc10, 0),
         i.cli_prazopg, i.cli_tabela, coalesce(i.cli_ipi, 0), i.cli_comprador,
         i.cli_obsparticular, i.cli_frete
  from cli_ind  i
  where i.cli_forcodigo = :ifor and i.cli_codigo = :icliente
  into :otransp, :vcdesc1, :vcdesc2, :vcdesc3, :vcdesc4, :vcdesc5,
       :vcdesc6, :vcdesc7, :vcdesc8, :vcdesc9, :vcdesc10, :oprazo,
       :otabela, :oipi, :vcomprador, :oobspedido, :ofrete;

  if (vcdesc1 = 0 or vcdesc1 is null) then
   begin
    odesc1  = vfdesc1;
    odesc2  = vfdesc2;
    odesc3  = vfdesc3;
    odesc4  = vfdesc4;
    odesc5  = vfdesc5;
    odesc6  = vfdesc6;
    odesc7  = vfdesc7;
    odesc8  = vfdesc8;
    odesc9  = vfdesc9;
    odesc10 = vfdesc10;
   end
   else
   begin
    odesc1  = vcdesc1;
    odesc2  = vcdesc2;
    odesc3  = vcdesc3;
    odesc4  = vcdesc4;
    odesc5  = vcdesc5;
    odesc6  = vcdesc6;
    odesc7  = vcdesc7;
    odesc8  = vcdesc8;
    odesc9  = vcdesc9;
    odesc10 = vcdesc10;
   end
   if (character_length(vcomprador) > 0) then
   ocomprador = vcomprador;

   suspend;
end^


ALTER PROCEDURE PROC_BUSCANUMPED
RETURNS (
    OID INTEGER)
AS
declare variable VPEDIDO varchar(10);
declare variable VCD integer;
begin
  select gen_id(gen_pedidos_id, 1) as numped from rdb$database
  into :vcd;

  for
   select ped_pedido from pedidos
   where ped_numero = :vcd
   into :vpedido
  do
  if (not vpedido is null) then
  begin
   select gen_id(gen_pedidos_id, 1) as numped from rdb$database
   into :vcd;
  end

  oid = vcd;
  suspend;
end^


ALTER PROCEDURE PROC_CCUSTO (
    IPESQ VARCHAR(50))
RETURNS (
    ID INTEGER,
    NOME VARCHAR(45))
AS
begin
  if (char_length(ipesq) = 0) then
   begin
    for
      select g.cc_id, g.cc_descricao
      from ccustos g
      order by 2
      into :id, :nome
    do
    suspend;
   end
  if (char_length(ipesq) > 0) then
   begin
    for
      select g.cc_id, g.cc_descricao
      from ccustos g
      where g.cc_descricao containing :ipesq
      order by 2
      into :id, :nome
    do
    suspend;
   end
end^


ALTER PROCEDURE PROC_CLIAREAATU (
    ICLIENTE INTEGER)
RETURNS (
    ATU_IDCLI INTEGER,
    ATU_ATUAID INTEGER,
    CLI_NOMRED VARCHAR(30),
    ATU_DESCRICAO VARCHAR(60))
AS
begin
 for
    select atu_idcli, atu_atuaid, cli_nomred, atu_descricao 
    from atua_cli a
    left join clientes c on a.atu_idcli = c.cli_codigo
    left join area_atu u on a.atu_atuaid = u.atu_id
    where a.atu_idcli = :icliente
    order by a.atu_idcli
    into :atu_idcli, :atu_atuaid, :cli_nomred, :atu_descricao
  do
  suspend;
end^


ALTER PROCEDURE PROC_CLIDESCPRO (
    ICLIENTE INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_FORCODIGO INTEGER,
    CLI_GRUPO INTEGER,
    CLI_DESC1 DOUBLE PRECISION,
    CLI_DESC2 DOUBLE PRECISION,
    CLI_DESC3 DOUBLE PRECISION,
    CLI_DESC4 DOUBLE PRECISION,
    CLI_DESC5 DOUBLE PRECISION,
    CLI_DESC6 DOUBLE PRECISION,
    CLI_DESC7 DOUBLE PRECISION,
    CLI_DESC8 DOUBLE PRECISION,
    CLI_DESC9 DOUBLE PRECISION,
    FOR_NOME VARCHAR(15),
    GRU_NOME VARCHAR(50))
AS
begin
  for
    select cli_codigo, cli_forcodigo, cli_grupo, cli_desc1, cli_desc2, cli_desc3, cli_desc4, 
    cli_desc5, cli_desc6, cli_desc7, cli_desc8, cli_desc9, for_nomered, gru_nome
    from cli_descpro d
    left join fornecedores f on d.cli_forcodigo = f.for_codigo
    left join grupos       g on d.cli_grupo     = g.gru_codigo
    where d.cli_codigo = :icliente
    order by cli_grupo, gru_nome
    into :cli_codigo, :cli_forcodigo, :cli_grupo, :cli_desc1, :cli_desc2, :cli_desc3, :cli_desc4,
         :cli_desc5, :cli_desc6, :cli_desc7, :cli_desc8, :cli_desc9, :for_nome, :gru_nome
  do
  suspend;
end^


ALTER PROCEDURE PROC_CLIENTES (
    IPESQUISA VARCHAR(60),
    IVEND INTEGER,
    IFLAG CHAR(1))
RETURNS (
    ID INTEGER,
    CNPJ VARCHAR(18),
    REDUZIDO VARCHAR(30),
    RAZAO VARCHAR(75),
    TELEFONE VARCHAR(20),
    FAX VARCHAR(200),
    CELULAR VARCHAR(20),
    CIDADE VARCHAR(25),
    ESTADO VARCHAR(2),
    VENDEDOR INTEGER,
    SITUACAO VARCHAR(1),
    REGIAO VARCHAR(50))
AS
begin
 if (ivend > 0 and character_length(ipesquisa) = 0) then -- informou o vendedor e nao a pesquisa
 begin
  for
   select cli_codigo, cli_cnpj, cli_nomred, cli_nome, cli_fone1, c.cli_email, cli_fone3,
   cli_cidade, cli_uf, cli_vendedor, cli_tipopes, r.reg_descricao
   from clientes c
   left join regioes r on c.cli_regiao2 = r.reg_codigo
   where c.cli_vendedor = :ivend and c.cli_tipopes = :iflag
   order by c.cli_tipopes, c.cli_nomred
   into :id, :cnpj, :reduzido, :razao, :telefone, :fax, :celular, :cidade, :estado, :vendedor, :situacao, :regiao
   do
   suspend;
 end

 if (ivend = 0 and character_length(ipesquisa) = 0) then -- nao informou o vendedor e nao a pesquisa
 begin
  for
   select cli_codigo, cli_cnpj, cli_nomred, cli_nome, cli_fone1, c.cli_email, cli_fone3,
   cli_cidade, cli_uf, cli_vendedor, cli_tipopes, r.reg_descricao
   from clientes c
   left join regioes r on c.cli_regiao2 = r.reg_codigo
   where c.cli_tipopes = :iflag
   order by c.cli_tipopes, c.cli_nomred
   into :id, :cnpj, :reduzido, :razao, :telefone, :fax, :celular, :cidade, :estado, :vendedor, :situacao, :regiao
   do
   suspend;
 end
 if (ivend > 0 and character_length(ipesquisa) > 0) then -- informou o vendedor e a pesquisa
 begin
  for
   select cli_codigo, cli_cnpj, cli_nomred, cli_nome, cli_fone1, c.cli_email, cli_fone3,
   cli_cidade, cli_uf, cli_vendedor, cli_tipopes, r.reg_descricao
   from clientes c
   left join regioes r on c.cli_regiao2 = r.reg_codigo
   where c.cli_vendedor = :ivend and (c.cli_nome containing :ipesquisa or c.cli_nomred containing :ipesquisa or c.cli_cnpj containing :ipesquisa) and c.cli_tipopes = :iflag
   order by c.cli_tipopes, c.cli_nomred
   into :id, :cnpj, :reduzido, :razao, :telefone, :fax, :celular, :cidade, :estado, :vendedor, :situacao, :regiao
   do
   suspend;
 end

 if (ivend = 0 and character_length(ipesquisa) > 0) then -- informou o vendedor e a pesquisa
 begin
  for
   select cli_codigo, cli_cnpj, cli_nomred, cli_nome, cli_fone1, cli_fone2, cli_fone3,
   cli_cidade, cli_uf, cli_vendedor, cli_tipopes, r.reg_descricao
   from clientes c
   left join regioes r on c.cli_regiao2 = r.reg_codigo
   where (c.cli_nome containing :ipesquisa or c.cli_nomred containing :ipesquisa or c.cli_cnpj containing :ipesquisa) and c.cli_tipopes = :iflag
   order by c.cli_tipopes, c.cli_nomred
   into :id, :cnpj, :reduzido, :razao, :telefone, :fax, :celular, :cidade, :estado, :vendedor, :situacao, :regiao
   do
   suspend;
 end
end^


ALTER PROCEDURE PROC_CLIENTESINATIVOS (
    IIND INTEGER,
    IVEND1 INTEGER,
    IDIAS INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_NOME VARCHAR(75),
    CLI_FONE1 VARCHAR(20),
    CLI_CIDADE VARCHAR(25),
    VEN_NOME VARCHAR(30),
    ULTCOMPRA DATE)
AS
declare variable IVEND2 integer;
begin
  ivend2 = ivend1;
  if (ivend1 = 0) then
   begin
    ivend1 = 1;
    ivend2 = 999;
   end
  for
    with inatividade
    as (select p.ped_cliente, max(p.ped_data) ultcompra
        from pedidos p
        where p.ped_industria = :iind and
        p.ped_situacao in ('P','F')
        group by 1
        having max(p.ped_data) <= (current_date - :idias)
        order by 1
        )
    
    select distinct
           c.cli_codigo,
           c.cli_nomred,
           c.cli_fone1,
           c.cli_cidade,
           v.ven_nome,
           i.ultcompra
    from clientes c
    join inatividade i on c.cli_codigo = i.ped_cliente
    join vendedores v  on v.ven_codigo  = c.cli_vendedor
    where c.cli_vendedor between :ivend1 and :ivend2 and
          c.cli_tipopes = 'A'
    order by 5, 2
    into :cli_codigo, :cli_nome, :cli_fone1, :cli_cidade, :ven_nome, :ultcompra
   do
   suspend;
end^


ALTER PROCEDURE PROC_CLIFOR (
    IPESQ VARCHAR(40),
    IFLAG CHAR(1))
RETURNS (
    NOME VARCHAR(60),
    ID INTEGER)
AS
begin
 if (char_length(ipesq) = 0) then
  begin
        for
          select c.cd_codigo, c.cd_nome
          from cred_dev c
          where c.cd_tipo = :iflag
          order by 2
          into :id, :nome
        do
        suspend;
  end

 if (char_length(ipesq) > 0) then
  begin
        for
          select c.cd_codigo, c.cd_nome
          from cred_dev c
          where c.cd_tipo = :iflag
                and c.cd_nome containing :ipesq
          order by 2
          into :id, :nome
        do
        suspend;
  end
end^


ALTER PROCEDURE PROC_CLINUNCACOMPROU (
    IIND INTEGER,
    IPROD VARCHAR(25))
RETURNS (
    CLI_NOMRED VARCHAR(30))
AS
begin
 for
    with i as (select p.ped_cliente from itens_ped x
               join pedidos p on x.ite_pedido = p.ped_pedido
               where x.ite_industria = :iind and
               x.ite_produto   = :iprod      and
               p.ped_situacao in ('P','F')
               group by 1)
    
    select c.cli_nomred 
    from clientes c
    left join i on c.cli_codigo = i.ped_cliente
    where c.cli_tipopes = 'A' and i.ped_cliente is null
    order by 1
    into :cli_nomred
 do
 suspend;
end^


ALTER PROCEDURE PROC_CLIPORAREAATU (
    IFOR INTEGER,
    IFLAG CHAR(1))
RETURNS (
    ATU_IDCLI INTEGER,
    CLI_NOMRED VARCHAR(30),
    CLI_EMAIL VARCHAR(200),
    CLI_IMP CHAR(1))
AS
begin
if (iflag = 'E') then --efetivo (pedidos realidados)
 begin
     for
        with xArea as (select atu_id from area_atu i
                       where atu_sel = 'S')
        
        select distinct atu_idcli, cli_nomred, lower(c.cli_email), c.cli_imp
        from atua_cli a
        join xArea    x on x.atu_id      = a.atu_atuaid
        join clientes c on a.atu_idcli   = c.cli_codigo
        join pedidos  p on p.ped_cliente = c.cli_codigo
        where p.ped_industria = :ifor
        order by 1
        into :atu_idcli, :cli_nomred, :cli_email, :cli_imp
      do
      suspend;
 end
if (iflag = 'P') then --previsao (industria cliente pode comprar)
 begin
     for
        with xArea as (select atu_id from area_atu i
                       where atu_sel = 'S')
        
        select distinct atu_idcli, cli_nomred, lower(c.cli_email), c.cli_imp
        from atua_cli a
        join xArea    x on x.atu_id      = a.atu_atuaid
        join clientes c on a.atu_idcli   = c.cli_codigo
        join indclientes i on a.atu_idcli = i.cli_id
        order by 1
        into :atu_idcli, :cli_nomred, :cli_email, :cli_imp
      do
      suspend;
 end
end^


ALTER PROCEDURE PROC_CLIPORINDUSTRIA (
    IFOR INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_NOMRED VARCHAR(30),
    CLI_NOME VARCHAR(75),
    CLI_CIDADE VARCHAR(25),
    CLI_IMP VARCHAR(1),
    CLI_EMAIL VARCHAR(200))
AS
begin
 for
    with xCli as (select p.ped_cliente
          from pedidos p
          where p.ped_industria = :ifor and
          p.ped_situacao in ('P','F')
          group by 1)
    select c.cli_codigo, c.cli_nomred, c.cli_nome, c.cli_cidade, c.cli_imp, lower(c.cli_email)
    from clientes c
    join xCli p1 on p1.ped_cliente = c.cli_codigo
    where char_length(c.cli_email) > 0
    order by 2
    into :cli_codigo, :cli_nomred, cli_nome, cli_cidade, cli_imp, cli_email
 do
 suspend;
end^


ALTER PROCEDURE PROC_CLIPROPECCAO (
    IIND INTEGER)
RETURNS (
    CLI_NOMRED VARCHAR(50),
    CLI_EMAIL VARCHAR(200),
    CLI_IMP CHAR(1))
AS
begin
 for
    select c.cli_nomred, c.cli_imp, lower(c.cli_email) cli_email
    from indclientes i
    join clientes c on i.cli_id = c.cli_codigo
    where i.cli_indid = :iind
    order by cli_codigo
    into :cli_nomred, :cli_imp, :cli_email
 do
  suspend;
end^


ALTER PROCEDURE PROC_CLIRED (
    IVEND INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_NOMRED VARCHAR(30),
    CLI_NOME VARCHAR(75),
    CLI_CIDADE VARCHAR(25),
    CLI_IMP VARCHAR(1),
    CLI_EMAIL VARCHAR(200),
    CLI_CNPJ VARCHAR(18))
AS
begin
 if (ivend = 0) then
 begin
  for
   select c.cli_codigo, c.cli_nomred, c.cli_nome, c.cli_cidade, c.cli_imp,
          lower(c.cli_email), c.cli_cnpj
   from clientes c
   where c.cli_tipopes = 'A'
   order by c.cli_nomred
   into :cli_codigo, :cli_nomred, :cli_nome, :cli_cidade, :cli_imp, :cli_email, :cli_cnpj
  do
  suspend;
 end
 if (ivend > 0) then
 begin
  for
   select c.cli_codigo, c.cli_nomred, c.cli_nome, c.cli_cidade, c.cli_imp,
          lower(c.cli_email), c.cli_cnpj
   from clientes c
   where c.cli_tipopes = 'A' and c.cli_vendedor = :ivend
   order by c.cli_nomred
   into :cli_codigo, :cli_nomred, :cli_nome, :cli_cidade, :cli_imp, :cli_email, :cli_cnpj
  do
  suspend;
 end
end^


ALTER PROCEDURE PROC_CLITELEMKT (
    IVEND INTEGER)
RETURNS (
    CLIID INTEGER,
    NOMERED VARCHAR(30),
    RAZAO VARCHAR(75),
    ULTDATA DATE,
    STATUS CHAR(1))
AS
declare variable IVEND2 integer;
begin
 if (ivend = 0) then
  begin
   ivend = 1;
   ivend2 = 999;
  end
  else
  ivend2 = ivend;
 for
   select distinct
    c.cli_codigo,
    c.cli_nomred,
    c.cli_nome,
    max(a.age_data) over(partition by a.age_cliente) dia,
    min(a.age_status) over(partition by a.age_cliente) status
    from clientes c
    left join agenda a on c.cli_codigo = a.age_cliente
    where c.cli_vendedor between :ivend and :ivend2 and
          c.cli_tipopes = 'A'
    order by 2
    into :cliid, :nomered, :razao, :ultdata, :status
  do
  suspend;
end^


ALTER PROCEDURE PROC_COMISSAO_SOMA (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    IVALFAT DOUBLE PRECISION)
RETURNS (
    OVALOR DOUBLE PRECISION,
    OPERCENT DOUBLE PRECISION,
    OPORGRUPO BOOLEAN,
    VFREIO DOUBLE PRECISION,
    VOUTRO DOUBLE PRECISION)
AS
declare variable VPERCOM double precision;
declare variable VPERCOM2 double precision;
declare variable VVALLIQ double precision;
declare variable VVAL1 double precision;
declare variable VVAL2 double precision;
declare variable VTOTCUICA double precision;
declare variable VTOTNORMAL double precision;
declare variable VGRUPO integer;
declare variable VPERCOMISS double precision;
declare variable VPEDIDO varchar(10);
begin
  vval1 = 0;
  vval2 = 0;
  vpercom = 0;
  vpercom2 = 0;
  vtotcuica = 0;
  vtotnormal = 0;
  oporgrupo = false;
  vpercomiss = 0;

  if (iindustria = 6) then
   begin
     for
      with aProd as (select distinct
                     p.pro_codprod, coalesce(g.gru_percomiss, 0) gru_percomiss, g.gru_codigo
                     from produtos p
                     left join grupos g on p.pro_grupopro = g.gru_codigo
                     where p.pro_industria = :iindustria)

      select it.ite_totliquido, coalesce(v.vin_percom, 0), coalesce(p1.gru_percomiss, 0), p1.gru_codigo
      from itens_ped it
      join pedidos pd on it.ite_pedido = pd.ped_pedido
      join aProd   p1 on it.ite_produto = p1.pro_codprod
      left join vendedor_ind v on pd.ped_vendedor = v.vin_codigo and pd.ped_industria = v.vin_industria
      where ite_pedido = :ipedido and
            ite_industria = :iindustria
      order by it.ite_seq
      into :vvalliq, :vpercom, :vpercom2, :vgrupo
      do
      begin
        -- calculo da comissao
         vpercom = 2;
         if (vgrupo in (18,19,70,105,107,130)) then
           begin
            vpercomiss = 1;
            oporgrupo  = true;
            vtotcuica  = vtotcuica + vvalliq;
           end
           else
           vtotnormal = vtotnormal + vvalliq;
         vval1  = vtotcuica * (vpercomiss/100);
         vval2  = (ivalfat - vtotcuica);
         vval2  = vval2 * (vpercom/100);
         ovalor = (vval1 + vval2);
         ovalor = cast(ovalor as numeric(15,2));

         if (oporgrupo = true) then
         opercent = coalesce(vpercom2,0);
         else
         opercent = coalesce(vpercom,0);
     end
     vfreio = coalesce(vtotcuica,0);
     voutro = coalesce((ivalfat - vtotcuica),0);
     suspend;
   end

  if (iindustria <> 6) then
   begin
      for
        select distinct
        pd.ped_pedido,
        sum(it.ite_totliquido) over (partition by pd.ped_pedido),
        coalesce(v.vin_percom,0)
        from pedidos pd
        join itens_ped it on it.ite_pedido = pd.ped_pedido
        left join vendedor_ind v on pd.ped_vendedor = v.vin_codigo
        where pd.ped_pedido = :ipedido and
              pd.ped_industria = :iindustria and
              v.vin_industria = :iindustria
        order by it.ite_seq
        into :vpedido, :vvalliq, :vpercom
      do
      begin
       -- calculo da comissao
       oporgrupo = false;
       vfreio = 0;
       voutro = 0;
       vval1  = vvalliq * (vpercom/100);
       ovalor = vval1;
       ovalor = cast(ovalor as numeric(15,2));
       opercent = coalesce(vpercom, 0);
       suspend;
     end
  end
end^


ALTER PROCEDURE PROC_COMISSAOVENDEDOR (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    IVALFAT DOUBLE PRECISION,
    ITABELA VARCHAR(20))
RETURNS (
    OVALOR DOUBLE PRECISION,
    OPERCENT DOUBLE PRECISION,
    OPORGRUPO BOOLEAN)
AS
declare variable VPERCOM double precision;
declare variable VPERCOM2 double precision;
declare variable VVALLIQ double precision;
declare variable VVAL1 double precision;
declare variable VVAL2 double precision;
declare variable VTOTCUICA double precision;
begin
  vval1 = 0;
  vval2 = 0;
  vpercom = 0;
  vpercom2 = 0;
  vtotcuica = 0;
  oporgrupo = false;
 for
  select it.ite_totliquido, coalesce(v.vin_percom, 0), coalesce(g.gru_percomiss, 0)
         from itens_ped it
         join pedidos pd on it.ite_pedido = pd.ped_pedido
         join produtos p on it.ite_produto = p.pro_codprod and p.pro_industria = :iindustria and p.pro_nometabela = :itabela
         left join grupos g on p.pro_grupopro = g.gru_codigo
         left join vendedor_ind v on pd.ped_vendedor = v.vin_codigo and pd.ped_industria = v.vin_industria
         where ite_pedido = :ipedido and ite_industria = :iindustria
         order by it.ite_seq
         into :vvalliq, :vpercom, :vpercom2
  do
  begin
    -- calculo da comissao
    vpercom  = (vpercom / 100);
    vpercom2 = (vpercom2 / 100);

    if (vpercom2 > 0) then
     begin
      oporgrupo = true;
      vtotcuica = vtotcuica + vvalliq;
      vval1 = vval1 + (vvalliq * vpercom2);
     end
  end
    vval2  = (ivalfat - vtotcuica) * vpercom;    -- retira do valor informato o total das cuicas para aplicar o % normal
    ovalor = vval1 + vval2;
    ovalor = coalesce(ovalor, 0);
    opercent = vpercom2;
    suspend;
end^


ALTER PROCEDURE PROC_COMPARATIVO2CLI (
    IDATA1 DATE,
    IDATA2 DATE,
    IFOR INTEGER,
    IREFERENCIA INTEGER,
    IALVO INTEGER,
    IFLAG INTEGER)
RETURNS (
    CODIGO VARCHAR(25),
    DESCRICAO VARCHAR(100),
    REF DOUBLE PRECISION,
    ALVO DOUBLE PRECISION)
AS
begin
 delete from pro_tempcurva where pro_id > 0;

 merge into pro_tempcurva t
 using (select d.pro_codprod,
               max(d.pro_nome) pro_nome,
               max(d.pro_codigo) pro_codigo,
               max(d.pro_grupopro) pro_grupopro,
               sum(d.pro_preliq) preco
               from produtos d
               where d.pro_industria = :ifor
               group by 1
               order by 1
        ) d
 on t.pro_codprod = d.pro_codprod
 when not matched then insert (pro_id, pro_descricao, pro_codprod, pro_grupopro)
                       values (d.pro_codigo, d.pro_nome,  d.pro_codprod, d.pro_grupopro);

 if (iflag = 0) then
   begin
    for
        with xRef as ( select i.ite_produto, sum(i.ite_quant) as quant
                       from itens_ped i
                       join pedidos p on i.ite_pedido = p.ped_pedido
                       where p.ped_industria = :ifor and
                             p.ped_cliente = :ireferencia and
                             p.ped_data between :idata1 and :idata2 and
                             p.ped_situacao in ('P', 'F')
                       group by 1
                       order by 1),
             xAlvo as (select i.ite_produto, sum(i.ite_quant) as quant
                       from itens_ped i
                       join pedidos p on i.ite_pedido = p.ped_pedido
                       where p.ped_industria = :ifor and
                             p.ped_cliente = :ialvo and
                             p.ped_data between :idata1 and :idata2 and
                             p.ped_situacao in ('P', 'F')
                       group by 1
                       order by 1)

        select distinct p1.pro_codprod,
               p1.pro_descricao,
               x1.quant ref,
               coalesce(x2.quant,0) alvo
        from pro_tempcurva p1
        join xRef x1 on p1.pro_codprod = x1.ite_produto
        left join xAlvo x2 on x1.ite_produto = x2.ite_produto
        where coalesce(x2.quant, 0) = 0

        order by 1
        into :codigo, :descricao, :ref, :alvo
    do
    suspend;
   end

 if (iflag = 1) then -- ref comprou e alvo tbm
  begin
    for
        with xRef as ( select i.ite_produto, sum(i.ite_quant) as quant
                       from itens_ped i
                       join pedidos p on i.ite_pedido = p.ped_pedido
                       where p.ped_industria = :ifor and
                             p.ped_cliente = :ireferencia and
                             p.ped_data between :idata1 and :idata2 and
                             p.ped_situacao in ('P', 'F')
                       group by 1
                       order by 1),
             xAlvo as (select i.ite_produto, sum(i.ite_quant) as quant
                       from itens_ped i
                       join pedidos p on i.ite_pedido = p.ped_pedido
                       where p.ped_industria = :ifor and
                             p.ped_cliente = :ialvo and
                             p.ped_data between :idata1 and :idata2 and
                             p.ped_situacao in ('P', 'F')
                       group by 1
                       order by 1)

        
        select distinct p1.pro_codprod,
               p1.pro_descricao,
               coalesce(x1.quant, 0),
               coalesce(x2.quant,0)
        from pro_tempcurva p1
        join xRef x1  on p1.pro_codprod = x1.ite_produto
        join xAlvo x2 on p1.pro_codprod = x2.ite_produto
        order by 1
        into :codigo, :descricao, :ref, :alvo
    do
    suspend;
  end
end^


ALTER PROCEDURE PROC_COMPARATIVO2GRP (
    IDATA1 DATE,
    IDATA2 DATE,
    IFOR INTEGER,
    IREFERENCIA INTEGER,
    IALVO INTEGER,
    IFLAG INTEGER)
RETURNS (
    CODIGO VARCHAR(25),
    DESCRICAO VARCHAR(100),
    REF DOUBLE PRECISION,
    ALVO DOUBLE PRECISION)
AS
declare variable GRPREF varchar(35);
declare variable GRPALVO varchar(35);
begin
 delete from pro_tempcurva where pro_id > 0;

 select c.cli_redeloja
 from clientes c
 where c.cli_codigo = :ireferencia
 into :grpref;

 select c.cli_redeloja
 from clientes c
 where c.cli_codigo = :ialvo
 into :grpalvo;

 merge into pro_tempcurva t
 using (select d.pro_codprod,
               max(d.pro_nome) pro_nome,
               max(d.pro_codigo) pro_codigo,
               max(d.pro_grupopro) pro_grupopro,
               sum(d.pro_preliq) preco
               from produtos d
               where d.pro_industria = :ifor
               group by 1
               order by 1
        ) d
 on t.pro_codprod = d.pro_codprod
 when not matched then insert (pro_id, pro_descricao, pro_codprod, pro_grupopro)
                       values (d.pro_codigo, d.pro_nome,  d.pro_codprod, d.pro_grupopro);

 if (iflag = 0) then
   begin
    for
        with xRef as ( select i.ite_produto, sum(i.ite_quant) as quant
                       from itens_ped i
                       join pedidos p on i.ite_pedido = p.ped_pedido
                       join clientes c on p.ped_cliente = c.cli_codigo
                       where p.ped_industria = :ifor and
                             c.cli_redeloja = :grpref and
                             p.ped_data between :idata1 and :idata2 and
                             p.ped_situacao in ('P', 'F')
                       group by 1
                       order by 1),
             xAlvo as (select i.ite_produto, sum(i.ite_quant) as quant
                       from itens_ped i
                       join pedidos p on i.ite_pedido = p.ped_pedido
                       join clientes c on p.ped_cliente = c.cli_codigo
                       where p.ped_industria = :ifor and
                             c.cli_redeloja = :grpalvo and
                             p.ped_data between :idata1 and :idata2 and
                             p.ped_situacao in ('P', 'F')
                       group by 1
                       order by 1)

        select distinct p1.pro_codprod,
               p1.pro_descricao,
               x1.quant ref,
               coalesce(x2.quant,0) alvo
        from pro_tempcurva p1
        join xRef x1 on p1.pro_codprod = x1.ite_produto
        left join xAlvo x2 on x1.ite_produto = x2.ite_produto
        where coalesce(x2.quant, 0) = 0

        order by 1
        into :codigo, :descricao, :ref, :alvo
    do
    suspend;
   end

 if (iflag = 1) then -- ref comprou e alvo tbm
  begin
    for
        with xRef as ( select i.ite_produto, sum(i.ite_quant) as quant
                       from itens_ped i
                       join pedidos p on i.ite_pedido = p.ped_pedido
                       join clientes c on p.ped_cliente = c.cli_codigo
                       where p.ped_industria = :ifor and
                             c.cli_redeloja = :grpref and
                             p.ped_data between :idata1 and :idata2 and
                             p.ped_situacao in ('P', 'F')
                       group by 1
                       order by 1),
             xAlvo as (select i.ite_produto, sum(i.ite_quant) as quant
                       from itens_ped i
                       join pedidos p on i.ite_pedido = p.ped_pedido
                       join clientes c on p.ped_cliente = c.cli_codigo
                       where p.ped_industria = :ifor and
                             c.cli_redeloja = :grpalvo and
                             p.ped_data between :idata1 and :idata2 and
                             p.ped_situacao in ('P', 'F')
                       group by 1
                       order by 1)

        
        select distinct p1.pro_codprod,
               p1.pro_descricao,
               coalesce(x1.quant, 0),
               coalesce(x2.quant,0)
        from pro_tempcurva p1
        join xRef x1  on p1.pro_codprod = x1.ite_produto
        join xAlvo x2 on p1.pro_codprod = x2.ite_produto
        order by 1
        into :codigo, :descricao, :ref, :alvo
    do
    suspend;
  end
end^


ALTER PROCEDURE PROC_CONDPAG (
    IPESQ VARCHAR(40))
RETURNS (
    ID INTEGER,
    DESCRICAO VARCHAR(30),
    PARCELAS INTEGER,
    BANDEIRA VARCHAR(50))
AS
begin
  if (char_length(ipesq) = 0) then
   begin
    for
     select f.con_codigo id, f.con_descricao, f.con_parcelas, b.descricao
     from forma_pagamento f
     left join bandeira b on f.con_bandeira = b.codigo
     order by f.con_descricao
     into :id, :descricao, :parcelas, :bandeira
    do
    suspend;
   end
  if (char_length(ipesq) > 0) then
   begin
    for
     select f.con_codigo id, f.con_descricao, f.con_parcelas, b.descricao
     from forma_pagamento f
     left join bandeira b on f.con_bandeira = b.codigo
     where f.con_descricao containing :ipesq
     order by f.con_descricao
     into :id, :descricao, :parcelas, :bandeira
    do
    suspend;
   end
end^


ALTER PROCEDURE PROC_CONTATOFOR (
    IFOR INTEGER)
RETURNS (
    CON_FORNEC INTEGER,
    CON_NOME VARCHAR(45),
    CON_GARGO VARCHAR(25),
    CON_FONE VARCHAR(15),
    CON_CELULAR VARCHAR(15),
    CON_EMAIL VARCHAR(60),
    CON_DTNASC DATE,
    CON_CODIGO INTEGER)
AS
begin
 for
   select con_fornec, con_nome, con_gargo, con_fone, con_celular, con_email, con_dtnasc, con_codigo
   from contato_for
   where con_fornec = :ifor
   into :con_fornec, :con_nome, :con_gargo, :con_fone, :con_celular, :con_email, :con_dtnasc, :con_codigo
  do
  suspend;
end^


ALTER PROCEDURE PROC_CONTATOSCLI (
    IIDCLIENTE INTEGER)
RETURNS (
    ANI_CLIENTE INTEGER,
    ANI_NOME VARCHAR(55),
    ANI_FUNCAO VARCHAR(35),
    ANI_DIAANIV SMALLINT,
    ANI_MES SMALLINT,
    ANI_FONE VARCHAR(15),
    ANI_EMAIL VARCHAR(80),
    ANI_NIVER DATE,
    ANI_OBS VARCHAR(600),
    ANI_LANCTO INTEGER)
AS
begin
  for
    select ani_cliente, ani_nome, ani_funcao, ani_diaaniv, ani_mes, ani_fone, ani_email, ani_niver, ani_obs, ani_lancto
    from cli_aniv a
    where ani_cliente = :iidcliente
    order by 1
   into :ani_cliente, :ani_nome, :ani_funcao, :ani_diaaniv, :ani_mes, :ani_fone, :ani_email, :ani_niver, :ani_obs, :ani_lancto
  do
  suspend;
end^


ALTER PROCEDURE PROC_CREDDEV (
    IPESQUISA VARCHAR(60),
    IFLAG CHAR(1))
RETURNS (
    ID INTEGER,
    CD_TIPO VARCHAR(1),
    CD_NOME VARCHAR(50),
    CD_TIPOEXT VARCHAR(10))
AS
begin
 if (char_length(ipesquisa) = 0) then
  begin
   for
    select cd_codigo, cd_tipo, cd_nome,
    decode(cd_tipo,
           'C', 'Credor',
           'D', 'Devedor ')
    from Cred_Dev
    where cd_tipo = :iflag
    into :ID, :cd_tipo, :cd_nome, :cd_tipoext
   do
   suspend;
  end

 if (char_length(ipesquisa) > 0) then
  begin
   for
    select cd_codigo, cd_tipo, cd_nome,
    decode(cd_tipo,
           'C', 'Credor',
           'D', 'Devedor ')
    from Cred_Dev
    where cd_tipo = :iflag and
          cd_nome like '%'||:ipesquisa||'%'
    into :ID, :cd_tipo, :cd_nome, :cd_tipoext
   do
   suspend;
  end

end^


ALTER PROCEDURE PROC_DADOSIND (
    ICLIENTE INTEGER)
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_FORCODIGO INTEGER,
    CLI_DESC1 DOUBLE PRECISION,
    CLI_DESC2 DOUBLE PRECISION,
    CLI_DESC3 DOUBLE PRECISION,
    CLI_DESC4 DOUBLE PRECISION,
    CLI_DESC5 DOUBLE PRECISION,
    CLI_DESC6 DOUBLE PRECISION,
    CLI_DESC7 DOUBLE PRECISION,
    CLI_DESC8 DOUBLE PRECISION,
    CLI_DESC9 DOUBLE PRECISION,
    CLI_DESC10 DOUBLE PRECISION,
    CLI_TRANSPORTADORA INTEGER,
    CLI_PRAZOPG VARCHAR(20),
    CLI_IPI INTEGER,
    FOR_NOMERED VARCHAR(15),
    NOME VARCHAR(60),
    CLI_TABELA VARCHAR(20),
    CLI_CODCLIIND VARCHAR(15),
    CLI_OBSPARTICULAR VARCHAR(600))
AS
begin
 for
    select cli_codigo, cli_forcodigo, cli_desc1, cli_desc2, cli_desc3, cli_desc4, cli_desc5, cli_desc6,
           cli_desc7, cli_desc8, cli_desc9, cli_desc10, cli_transportadora, cli_prazopg, cli_ipi, for_nomered, 
           nome, cli_tabela, cli_codcliind, cli_obsparticular
    from cli_ind t
    left join fornecedores f on t.cli_forcodigo = f.for_codigo
    left join transportadora r on t.cli_transportadora = r.codigo
    where t.cli_codigo = :icliente
    order by for_nome

    into :cli_codigo, :cli_forcodigo, :cli_desc1, :cli_desc2, :cli_desc3, :cli_desc4, :cli_desc5, :cli_desc6,
         :cli_desc7, :cli_desc8, :cli_desc9, :cli_desc10, :cli_transportadora, :cli_prazopg, :cli_ipi, :for_nomered,
         :nome, :cli_tabela, :cli_codcliind, :cli_obsparticular
 do
    suspend;
end^


ALTER PROCEDURE PROC_DESCADDQTD (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20))
AS
declare variable VADD numeric(6,2);
declare variable VPRODUTO varchar(25);
declare variable VEMBUCH varchar(25);
declare variable VPESO integer;
begin
 for
  select it.ite_produto, it.ite_embuch, coalesce(p.pro_descadic2, 0), coalesce(p.ite_peso, 0)
         from itens_ped it
         join produtos p on it.ite_produto = p.pro_codprod and p.pro_industria = :iindustria and p.pro_nometabela = :itabela
         where ite_pedido = :ipedido and ite_industria = :iindustria
         order by 1
         into :vproduto, :vembuch, :vadd, :vpeso
  do
  begin
    -- atualiza tabela itens_ped
    if (vadd > 0 and vpeso > 0) then
    begin
      update itens_ped set ite_des10 = :vadd
      where ite_produto = :vproduto and ite_embuch = :vembuch and ite_pedido = :ipedido;
    end
  end
end^


ALTER PROCEDURE PROC_DESCONTOIND (
    IFOR INTEGER)
RETURNS (
    DES_ID INTEGER,
    DES_CODIND INTEGER,
    DES_VALINI DOUBLE PRECISION,
    DES_VALFIM DOUBLE PRECISION,
    DES_DESCONTO INTEGER,
    GRU_DESC1 DOUBLE PRECISION,
    GRU_DESC2 DOUBLE PRECISION,
    GRU_DESC3 DOUBLE PRECISION,
    GRU_DESC4 DOUBLE PRECISION,
    GRU_DESC5 DOUBLE PRECISION,
    GRU_DESC6 DOUBLE PRECISION,
    GRU_DESC7 DOUBLE PRECISION,
    GRU_DESC8 DOUBLE PRECISION,
    GRU_DESC9 DOUBLE PRECISION)
AS
begin
  for
   select d.des_id, d.des_codind, d.des_valini, d.des_valfim, d.des_desconto,
   g.gru_desc1, g.gru_desc2, g.gru_desc3, g.gru_desc4, g.gru_desc5, g.gru_desc6, g.gru_desc7, g.gru_desc8, g.gru_desc9
   from descontos_ind d
   join grupo_desc    g on d.des_desconto = g.gru_codigo
   where d.des_codind = :ifor
   order by 1
   into :des_id, :des_codind, :des_valini, :des_valfim, :des_desconto,
        :gru_desc1, :gru_desc2, :gru_desc3, :gru_desc4, :gru_desc5,
        :gru_desc6, :gru_desc7, :gru_desc8, :gru_desc9
  do
  suspend;
end^


ALTER PROCEDURE PROC_DESCPADRAO (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER)
AS
declare variable VDESC1 numeric(6,2);
declare variable VDESC2 numeric(6,2);
declare variable VDESC3 numeric(6,2);
declare variable VDESC4 numeric(6,2);
declare variable VDESC5 numeric(6,2);
declare variable VDESC6 numeric(6,2);
declare variable VDESC7 numeric(6,2);
declare variable VDESC8 numeric(6,2);
declare variable VDESC9 numeric(6,2);
begin
  select p.ped_pri, p.ped_seg, p.ped_ter, p.ped_qua, p.ped_qui, p.ped_sex, p.ped_set, p.ped_oit, p.ped_nov
  from pedidos p
  where p.ped_pedido = :ipedido and p.ped_industria = :iindustria
  into :vdesc1,:vdesc2,:vdesc3,:vdesc4,:vdesc5,:vdesc6,:vdesc7,:vdesc8,:vdesc9;

  -- atualiza tabela itens_ped

  update itens_ped set ite_des1 = :vdesc1, ite_des2 = :vdesc2, ite_des3 = :vdesc3, ite_des4 = :vdesc4,
                       ite_des5 = :vdesc5, ite_des6 = :vdesc6, ite_des7 = :vdesc7, ite_des8 = :vdesc8,  ite_des9 = :vdesc9
  where ite_pedido = :ipedido and ite_industria = :iindustria and ite_cotacao <> '2';
end^


ALTER PROCEDURE PROC_DESCPADRAO2 (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER)
AS
declare variable VDESC1 numeric(6,2);
declare variable VDESC2 numeric(6,2);
declare variable VDESC3 numeric(6,2);
declare variable VDESC4 numeric(6,2);
declare variable VDESC5 numeric(6,2);
declare variable VDESC6 numeric(6,2);
declare variable VDESC7 numeric(6,2);
declare variable VDESC8 numeric(6,2);
declare variable VDESC9 numeric(6,2);
begin
  select p.ped_pri, p.ped_seg, p.ped_ter, p.ped_qua, p.ped_qui, p.ped_sex, p.ped_set, p.ped_oit, p.ped_nov
  from pedidos p
  where p.ped_pedido = :ipedido and p.ped_industria = :iindustria
  into :vdesc1,:vdesc2,:vdesc3,:vdesc4,:vdesc5,:vdesc6,:vdesc7,:vdesc8,:vdesc9;

  -- atualiza tabela itens_ped

  update itens_ped set ite_des1 = :vdesc1, ite_des2 = :vdesc2, ite_des3 = :vdesc3, ite_des4 = :vdesc4,
                       ite_des5 = :vdesc5, ite_des6 = :vdesc6, ite_des7 = :vdesc7, ite_des8 = :vdesc8,  ite_des9 = :vdesc9
  where ite_pedido = :ipedido and ite_industria = :iindustria;
end^


ALTER PROCEDURE PROC_ESPELHARPED (
    IPEDORI VARCHAR(10),
    IPEDNEW VARCHAR(10),
    IFOR INTEGER)
AS
declare variable IPEDIDO varchar(10);
declare variable INUMPED integer;
declare variable IDATA date;
declare variable IINDUSTRIA integer;
declare variable ICLIENTE integer;
declare variable ITRANSP integer;
declare variable IVENDEDOR integer;
declare variable ITABELA varchar(20);
declare variable ICONDPAG varchar(100);
declare variable ISITUACAO varchar(1);
declare variable ITIPOFRETE varchar(1);
declare variable IEXPORTADO varchar(1);
declare variable IPRI double precision;
declare variable ISEG double precision;
declare variable ITER double precision;
declare variable IQUA double precision;
declare variable IQUI double precision;
declare variable ISEX double precision;
declare variable ISET double precision;
declare variable IOIT double precision;
declare variable INOV double precision;
declare variable IDEZ double precision;
declare variable VPEDIDO varchar(10);
declare variable VDATA date;
declare variable VPRODUTO varchar(25);
declare variable VQTD double precision;
declare variable VUNI double precision;
declare variable VUNILIQ double precision;
declare variable VIPI double precision;
declare variable VDESCADIC integer;
declare variable VDES1 double precision;
declare variable VDES2 double precision;
declare variable VDES3 double precision;
declare variable VDES4 double precision;
declare variable VDES5 double precision;
declare variable VDES6 double precision;
declare variable VDES7 double precision;
declare variable VDES8 double precision;
declare variable VDES9 double precision;
declare variable VDES10 double precision;
declare variable VDES11 double precision;
declare variable VEMBUCH varchar(15);
declare variable VEXPORTADO char(1);
declare variable VSEQ integer;
declare variable VNOMEPROD varchar(100);
begin
 in autonomous transaction do
  begin
    for
     select p.ped_pedido, p.ped_numero, p.ped_data, p.ped_industria, p.ped_cliente,
            p.ped_transp, p.ped_vendedor, p.ped_tabela, p.ped_condpag, p.ped_situacao,
            p.ped_tipofrete, p.ped_exportado, p.ped_pri, p.ped_seg, p.ped_ter, p.ped_qua, 
            p.ped_qui, p.ped_sex, p.ped_set, p.ped_oit, p.ped_nov, p.ped_dez
     from pedidos p
     where p.ped_pedido = :ipedori and p.ped_industria = :ifor
     into  :ipedido, :inumped, :idata, :iindustria, :icliente,
           :itransp, :ivendedor, :itabela, :icondpag, :isituacao,
           :itipofrete, :iexportado, :ipri, :iseg, :iter, :iqua, :iqui, :isex, :iset, :ioit, :inov, :idez
     do
      begin
         insert into pedidos (ped_pedido, ped_numero, ped_data, ped_industria, ped_cliente,
                ped_transp, ped_vendedor, ped_tabela, ped_condpag, ped_situacao,
                ped_tipofrete, ped_exportado, ped_pri, ped_seg, ped_ter, ped_qua, 
                ped_qui, ped_sex, ped_set, ped_oit, ped_nov, ped_dez)
         values (:ipednew, :inumped, :idata, :ifor, :icliente,
               :itransp, :ivendedor, :itabela, :icondpag, :isituacao,
               :itipofrete, :iexportado, :ipri, :iseg, :iter, :iqua,
               :iqui, :isex, :iset, :ioit, :inov, :idez);
      end -- do pedido

   for
     select i.ite_pedido, i.ite_data, i.ite_produto, i.ite_quant, i.ite_puni, i.ite_puniliq, i.ite_ipi,
            i.ite_descadic, i.ite_des1, i.ite_des2, i.ite_des3, i.ite_des4, i.ite_des5, i.ite_des6,
            i.ite_des7, i.ite_des8, i.ite_des9, i.ite_des10, i.ite_des11, i.ite_embuch,
            i.ite_exportado, i.ite_seq, i.ite_nomeprod
     from itens_ped i
     where i.ite_pedido = :ipedori and i.ite_industria = :ifor
     into :vpedido, :vdata, :vproduto, :vqtd, :vuni, :vuniliq, :vipi,
          :vdescadic, :vdes1, :vdes2, :vdes3, :vdes4, :vdes5, :vdes6,
          :vdes7, :vdes8, :vdes9, :vdes10, :vdes11, :vembuch,
          :vexportado, :vseq, :vnomeprod
   do
   begin
     insert into itens_ped (ite_pedido, ite_data, ite_produto, ite_quant, ite_puni, ite_puniliq, ite_ipi,
            ite_descadic, ite_des1, ite_des2, ite_des3, ite_des4, ite_des5, ite_des6,
            ite_des7, ite_des8, ite_des9, ite_des10, ite_des11, ite_embuch,
            ite_exportado, ite_seq, ite_nomeprod, ite_industria)
     values (:ipednew, :vdata, :vproduto, :vqtd, :vuni, :vuniliq, :vipi,
            :vdescadic, :vdes1, :vdes2, :vdes3, :vdes4, :vdes5, :vdes6,
            :vdes7, :vdes8, :vdes9, :vdes10, :vdes11, :vembuch,
            :vexportado, :vseq, left(:vnomeprod,50), :ifor);
   end
  end --do transaction
end^


ALTER PROCEDURE PROC_EXCLUIRPEDIDO (
    IPED VARCHAR(10),
    IFOR INTEGER,
    IFLAG CHAR(1))
AS
begin
  if (iflag = 'T') then -- apenas ocultar o pedido
   begin
    in autonomous transaction do
     begin
       update pedidos set ped_situacao = 'E'
       where ped_pedido = :iped and ped_industria = :ifor;
     end
   end

  if(iflag = 'D') then -- definitivo
   begin
    in autonomous transaction do
     begin
       delete from itens_ped
       where ite_pedido = :iped and ite_industria = :ifor;
     end

    in autonomous transaction do
     begin
       delete from fatura_ped
       where fat_pedido = :iped and fat_industria = :ifor;
     end

    in autonomous transaction do
     begin
       delete from pedidos
       where ped_pedido = :iped and ped_industria = :ifor;
     end
   end
end^


ALTER PROCEDURE PROC_EXCLUIRPROD (
    IIND INTEGER,
    ITAB VARCHAR(25),
    ICODPROD INTEGER)
AS
begin
 if (icodprod > 0) then
  begin
    delete from produtos
    where pro_industria  = :iind and
          pro_nometabela = :itab and
          pro_codigo    = :icodprod;
  end
  else
  begin
    delete from produtos
    where pro_industria  = :iind and
          pro_nometabela = :itab;
  end
end^


ALTER PROCEDURE PROC_FORRED (
    IVEND INTEGER)
RETURNS (
    FOR_CODIGO INTEGER,
    FOR_NOMERED VARCHAR(15),
    FOR_NOME VARCHAR(75),
    FOR_TIPOFRETE CHAR(1))
AS
declare variable VSQL varchar(600);
declare variable VLB char(2);
begin
 vlb  = ascii_char(13)||ascii_char(10);
 vSql = '';
 if (ivend = 0) then ivend = 9999; /* todas as industrias independente do vendedor */

 if (ivend < 9999) then
 begin
   vsql = 'select f.for_codigo, f.for_nomered, f.for_nome, f.for_tipofrete '
   ||vlb||'from fornecedores f '
   ||vlb||'join vendedor_ind v on f.for_codigo = v.vin_industria '
   ||vlb||'where f.for_tipo2 = ''A'' and v.vin_codigo = :xvend '
   ||vlb||'order by f.for_codigo ';
 end
 if (ivend = 9999) then
 begin
   vsql = 'select f.for_codigo, f.for_nomered, f.for_nome, f.for_tipofrete '
   ||vlb||'from fornecedores f '
   ||vlb||'where f.for_tipo2 = ''A'' and f.for_codigo < :xvend '
   ||vlb||'order by f.for_codigo ';
 end

 for
   execute statement (vSql) (xvend := :ivend)
   into :for_codigo, :for_nomered, :for_nome, :for_tipofrete
 do
  suspend;
end^


ALTER PROCEDURE PROC_FORVENDASCLI (
    IFOR INTEGER)
RETURNS (
    CLI_NOMRED VARCHAR(30),
    DATA DATE,
    TOTAL DOUBLE PRECISION,
    CLI_FONE1 VARCHAR(20),
    PED_INDUSTRIA INTEGER)
AS
begin
 for
    select c.cli_nomred, max(p.ped_data) Data, sum(p.ped_totliq) Total, c.cli_fone1, p.ped_industria
    from pedidos p
    left join clientes c on p.ped_cliente = c.cli_codigo
    where p.ped_industria = :ifor and p.ped_situacao in ('P','F')
    group by cli_nomred, cli_fone1, p.ped_industria
    order by total desc
    into :cli_nomred, :data, :total, :cli_fone1, :ped_industria
 do
 suspend;
end^


ALTER PROCEDURE PROC_FUNCIONARIOS (
    IPESQUISA VARCHAR(60))
RETURNS (
    ID INTEGER,
    NOME VARCHAR(45),
    NOMEUSU VARCHAR(50),
    FONE VARCHAR(20))
AS
begin
 if (char_length(ipesquisa) > 0) then
  begin
   for
       select v.ven_codigo, v.ven_nome, v.ven_fone1, u.nome
       from vendedores v
       left join user_nomes u on v.ven_codusu = u.codigo
       where v.ven_nome like '%'||:ipesquisa||'%'
       order by 2
       into :id, :nome, :fone, :nomeusu
   do
   suspend;
  end

 if (char_length(ipesquisa) = 0) then
  begin
   for
       select v.ven_codigo, v.ven_nome, v.ven_fone1, u.nome
       from vendedores v
       left join user_nomes u on v.ven_codusu = u.codigo
       order by 2
       into :id, :nome, :fone, :nomeusu
   do
   suspend;
  end
end^


ALTER PROCEDURE PROC_GRAFTELECLIIND (
    XDT1 DATE,
    XDT2 DATE,
    XIND INTEGER,
    XCLI INTEGER)
RETURNS (
    OMES INTEGER,
    OMESANO VARCHAR(10),
    OTOTAL DOUBLE PRECISION)
AS
begin
  for
    select
      extract(month from p.ped_data) Mes,
      extract(year from p.ped_data)||'/'||extract(month from p.ped_data)  as MesAno,
      sum(p.ped_totliq) total
    from pedidos p
    where p.ped_data between :xdt1 and :xdt2 and
          p.ped_situacao <> 'C' and
          p.ped_industria = :xind and
          p.ped_cliente = :xcli
    group by 1, 2
    order by 1
    into :omes, :omesano, :ototal
  do
  suspend;
end^


ALTER PROCEDURE PROC_GRAFVENDAS (
    XDT1 DATE,
    XDT2 DATE,
    XIND INTEGER)
RETURNS (
    OTOTAL DOUBLE PRECISION,
    OMESEXT DATE,
    OMES CHAR(3))
AS
begin
  for
    select
      cast((extract(year from p.ped_data)||'/'||extract(month from p.ped_data)|| '/28') as date),
      sum(p.ped_totliq) total,
      case extract(month from p.ped_data)
      when 1 then 'Jan'
      when 2 then 'Fev'
      when 3 then 'Mar'
      when 4 then 'Abr'
      when 5 then 'Mai'
      when 6 then 'Jun'
      when 7 then 'Jul'
      when 8 then 'Ago'
      when 9 then 'Set'
      when 10 then 'Out'
      when 11 then 'Nov'
      when 12 then 'Dez' end

    from pedidos p
    where p.ped_data between :xdt1 and :xdt2 and
          p.ped_situacao <> 'C' and
          p.ped_industria = :xInd
    group by 1,3
    order by 1
    into :omesext, :ototal, :omes
  do
    suspend;
end^


ALTER PROCEDURE PROC_GRAFVENDASCLI (
    XDT1 DATE,
    XDT2 DATE,
    XIND INTEGER,
    XCLI INTEGER)
RETURNS (
    OMESANO DATE,
    OTOTAL DOUBLE PRECISION,
    OMES CHAR(3))
AS
begin
  for
    select
      cast((extract(year from p.ped_data)||'/'||extract(month from p.ped_data)|| '/28') as date),
      sum(p.ped_totliq) total,
      case extract(month from p.ped_data)
      when 1 then 'Jan'
      when 2 then 'Fev'
      when 3 then 'Mar'
      when 4 then 'Abr'
      when 5 then 'Mai'
      when 6 then 'Jun'
      when 7 then 'Jul'
      when 8 then 'Ago'
      when 9 then 'Set'
      when 10 then 'Out'
      when 11 then 'Nov'
      when 12 then 'Dez' end

    from pedidos p
    where p.ped_data between :xdt1 and :xdt2 and
          p.ped_situacao <> 'C' and
          p.ped_industria = :xInd and
          p.ped_cliente = :xcli
    group by 1, 3
    order by 1
    into :omesano, :ototal, :omes
  do
  suspend;
end^


ALTER PROCEDURE PROC_GRUPODESCONTO
RETURNS (
    ID INTEGER,
    DESC1 DOUBLE PRECISION,
    DESC2 DOUBLE PRECISION,
    DESC3 DOUBLE PRECISION,
    DESC4 DOUBLE PRECISION,
    DESC5 DOUBLE PRECISION,
    DESC6 DOUBLE PRECISION,
    DESC7 DOUBLE PRECISION,
    DESC8 DOUBLE PRECISION,
    DESC9 DOUBLE PRECISION,
    DESC10 DOUBLE PRECISION)
AS
begin
 for
    select gru_codigo, gru_desc1, gru_desc2, gru_desc3, gru_desc4, gru_desc5, gru_desc6, gru_desc7, gru_desc8, gru_desc9, gru_desc10
    from grupo_desc
    order by 1
    into :id, :desc1, :desc2, :desc3, :desc4, :desc5, :desc6, :desc7, :desc8, :desc9, :desc10
 do
 suspend;
end^


ALTER PROCEDURE PROC_GRUPOPROD (
    IPESQ VARCHAR(60))
RETURNS (
    ID INTEGER,
    NOME VARCHAR(50),
    PERCOM DOUBLE PRECISION)
AS
begin
 if (ipesq is null) then ipesq = '';
 if (char_length(ipesq) = 0) then ipesq = '';

 if (char_length(ipesq) = 0) then
  begin
   for
    select g.gru_codigo, g.gru_nome, g.gru_percomiss
    from grupos g
    order by gru_nome
    into :id, :nome, :percom
   do
   suspend;
  end

 if (char_length(ipesq) > 0) then
  begin
   ipesq = Upper(ipesq);
   for
    select g.gru_codigo, g.gru_nome, g.gru_percomiss
    from grupos g
    where Upper(g.gru_nome) like '%'||:ipesq||'%'
    order by gru_nome
    into :id, :nome, :percom
   do
   suspend;
  end

end^


ALTER PROCEDURE PROC_HISTCLIENTESPRODUTOS (
    IIND INTEGER,
    IPROD VARCHAR(25))
RETURNS (
    ITE_PRODUTO VARCHAR(25),
    CLI_NOMRED VARCHAR(30),
    ULTCOMPRA DATE)
AS
begin
 for
    select i.ite_produto, c.cli_nomred, max(i.ite_data) ultcompra
    from itens_ped i
    join clientes c on i.ite_cliente = c.cli_codigo
    join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
    where ite_produto = :iprod and
          i.ite_industria = :iind and
          p.ped_situacao in ('P', 'F')
    group by 1,2
    order by 2
    into :ite_produto, :cli_nomred, :ultcompra
 do
  suspend;
end^


ALTER PROCEDURE PROC_HISTCOMPRACLI (
    IDATA1 DATE,
    IDATA2 DATE,
    IFLAG CHAR(1),
    ICLIENTE INTEGER)
RETURNS (
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    DIA DATE,
    TOTAL DOUBLE PRECISION)
AS
begin
  if (iflag = 'V') then  --valor
   begin
    for
        select
               f.for_nomered,
               c.cli_nomred,
               max(p.ped_data),
               sum(p.ped_totliq)
        from pedidos p
        join fornecedores f   on p.ped_industria =  f.for_codigo
        join clientes c       on p.ped_cliente   = c.cli_codigo
        where p.ped_data between :idata1 and :idata2 and
              p.ped_situacao in ('P','F') and
              p.ped_cliente = :icliente
        group by 1,2
        order by 1
        into :for_nomered, :cli_nomred, :dia, :total
    do
    suspend;
   end

  if (iflag = 'Q') then --quantidade
   begin
    for
        select f.for_nomered,
               c.cli_nomred,
               max(p.ped_data),
               sum(i.ite_quant)
        from pedidos p
        join itens_ped i      on p.ped_pedido    = i.ite_pedido and p.ped_industria = i.ite_industria
        join fornecedores f   on p.ped_industria = f.for_codigo
        join clientes c       on p.ped_cliente   = c.cli_codigo
        where p.ped_data between :idata1 and :idata2 and
              p.ped_situacao in ('P','F')and
              p.ped_cliente = :icliente
        group by 1,2
        order by 1
        into :for_nomered, :cli_nomred, :dia, :total
    do
    suspend;
   end
  if (iflag = 'D') then --dt ultima compra
   begin
    for
      with vendas_rank as (
       select p.ped_industria,
              p.ped_cliente,
              p.ped_data  ult_compra,
              p.ped_totliq,
              row_number() over (partition by p.ped_industria, p.ped_cliente order by p.ped_data desc) as rn
       from pedidos p
       where p.ped_data between :idata1 and :idata2 and
             p.ped_situacao in ('P','F') )


       select f.for_nomered,
              c.cli_nomred,
              vr.ult_compra,
              vr.ped_totliq
       from clientes c
       left join vendas_rank vr on c.cli_codigo = vr.ped_cliente and vr.rn = 1
       join fornecedores f   on vr.ped_industria = f.for_codigo
       where vr.ped_totliq > 0 and
             c.cli_codigo = :icliente
       order by 1,2
       into :for_nomered, :cli_nomred, :dia, :total
    do
    suspend;
   end
end^


ALTER PROCEDURE PROC_HISTVENDAITEM (
    IPROD VARCHAR(25),
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    MES INTEGER,
    ITE_PRODUTO VARCHAR(25),
    TOTAL DOUBLE PRECISION,
    MESANO DATE)
AS
begin
  for
    select extract( month from p.ped_data) mes, i.ite_produto,
           sum(i.ite_quant) total,
           cast( extract( year from p.ped_data)||'/'|| extract( month from p.ped_data)||'/'||'28' as date)  mesano

    from itens_ped i

    left join pedidos p on i.ite_pedido = p.ped_pedido

    where p.ped_situacao in ('P','F') and
          i.ite_produto   = :iprod and
          p.ped_industria = :iind and
          p.ped_data between :idata1 and :idata2

    group by extract(year from p.ped_data), extract(month from p.ped_data), i.ite_produto
    order by extract(year from p.ped_data), extract(month from p.ped_data), i.ite_produto

    into :mes, :ite_produto, :total, :mesano

  do
  suspend;
end^


ALTER PROCEDURE PROC_IMPRIMEITEPED (
    IPED VARCHAR(10),
    IFOR INTEGER,
    ITAB VARCHAR(20))
RETURNS (
    ITE_PRODUTO TYPE OF COLUMN ITENS_PED.ITE_PRODUTO,
    ITE_EMBUCH TYPE OF COLUMN ITENS_PED.ITE_EMBUCH,
    ITE_QUANT TYPE OF COLUMN ITENS_PED.ITE_QUANT,
    ITE_PUNI TYPE OF COLUMN ITENS_PED.ITE_PUNI,
    ITE_PUNILIQ TYPE OF COLUMN ITENS_PED.ITE_PUNILIQ,
    ITE_IPI TYPE OF COLUMN ITENS_PED.ITE_IPI,
    ITE_TOTLIQUIDO TYPE OF COLUMN ITENS_PED.ITE_TOTLIQUIDO,
    ITE_NOMEPROD TYPE OF COLUMN ITENS_PED.ITE_NOMEPROD,
    ITE_DESCONTOS TYPE OF COLUMN ITENS_PED.ITE_DESCONTOS,
    PRO_CODORIGINAL TYPE OF COLUMN PRODUTOS.PRO_CODORIGINAL,
    ITE_SEQ TYPE OF COLUMN ITENS_PED.ITE_SEQ,
    ITE_TOTBRUTO TYPE OF COLUMN ITENS_PED.ITE_TOTBRUTO,
    ITE_VALCOMIPI TYPE OF COLUMN ITENS_PED.ITE_VALCOMIPI,
    PRO_APLICACAO2 TYPE OF COLUMN PRODUTOS.PRO_APLICACAO2,
    ITE_CONVERSAO TYPE OF COLUMN PRODUTOS.ITE_CONVERSAO,
    ITE_PESO TYPE OF COLUMN PRODUTOS.ITE_PESO,
    ITE_ST TYPE OF COLUMN ITENS_PED.ITE_ST,
    ITE_VALCOMST TYPE OF COLUMN ITENS_PED.ITE_VALCOMST,
    ITE_LANCTO INTEGER,
    PRO_EMBALAGEM INTEGER,
    ITE_PUNILIQCOMIMPOSTO DOUBLE PRECISION,
    ITE_NUMPEDCLI VARCHAR(25))
AS
begin
  for
   select ite_produto, ite_embuch, ite_quant, ite_puni, ite_puniliq, ite_ipi,
          ite_totliquido, ite_nomeprod, ite_descontos, pro_codoriginal,
          ite_seq, ite_totbruto, ite_valcomipi, pro_aplicacao2, ite_conversao, ite_peso,
          ite_st, ite_valcomst, ite_lancto, p.pro_embalagem, ite_puniliqcomimposto,
          ite_numpedcli
          from itens_ped i
          left join produtos p  on (i.ite_produto = p.pro_codprod and i.ite_industria = p.pro_industria and p.pro_nometabela = :itab)
          where ite_pedido = :iped and ite_industria = :ifor
          into
          :ite_produto, :ite_embuch, :ite_quant, :ite_puni, :ite_puniliq, :ite_ipi,
          :ite_totliquido, :ite_nomeprod, :ite_descontos, :pro_codoriginal,
          :ite_seq, :ite_totbruto, :ite_valcomipi, :pro_aplicacao2, :ite_conversao, :ite_peso,
          :ite_st, :ite_valcomst, :ite_lancto, :pro_embalagem, :ite_puniliqcomimposto, :ite_numpedcli
   do
   suspend;
end^


ALTER PROCEDURE PROC_IMPRIMEPED (
    IFOR INTEGER,
    IPED VARCHAR(10))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    PED_CLIENTE INTEGER,
    PED_INDUSTRIA INTEGER,
    PED_VENDEDOR INTEGER,
    PED_TOTLIQ DOUBLE PRECISION,
    PED_TOTBRUTO DOUBLE PRECISION,
    PED_OBS VARCHAR(600),
    PED_CONDPAG VARCHAR(100),
    PED_TRANSP INTEGER,
    PED_TIPOFRETE VARCHAR(1),
    PED_TOTALIPI DOUBLE PRECISION,
    PED_OBSFORA VARCHAR(600),
    PED_CLIIND VARCHAR(15),
    PED_SITUACAO VARCHAR(1),
    PED_COMPRADOR VARCHAR(30),
    PED_EMAILCOMP VARCHAR(60),
    PED_TABELA VARCHAR(20),
    CLI_NOME VARCHAR(75),
    CLI_ENDERECO VARCHAR(200),
    CLI_BAIRRO VARCHAR(100),
    CLI_CEP VARCHAR(11),
    CLI_UF VARCHAR(2),
    CLI_CIDADE VARCHAR(25),
    CLI_CNPJ VARCHAR(18),
    CLI_INSCRICAO VARCHAR(18),
    CLI_FONE1 VARCHAR(20),
    CLI_FONE2 VARCHAR(20),
    CLI_FONE3 VARCHAR(20),
    CLI_EMAIL VARCHAR(200),
    CLI_PTOREF VARCHAR(250),
    CLI_ENDCOB VARCHAR(45),
    CLI_BAICOB VARCHAR(25),
    CLI_CIDCOB VARCHAR(25),
    CLI_CEPCOB VARCHAR(11),
    CLI_UFCOB VARCHAR(2),
    CLI_EMAILNFE VARCHAR(60),
    CLI_SUFRAMA VARCHAR(15),
    CLI_CAIXAPOSTAL VARCHAR(20),
    CLI_COMPENDERECO VARCHAR(50),
    CLI_EMAILFINANC VARCHAR(60),
    CLI_NOMRED VARCHAR(30),
    NOME VARCHAR(60),
    ENDERECO VARCHAR(45),
    BAIRRO VARCHAR(25),
    CIDADE VARCHAR(25),
    CEP VARCHAR(11),
    UF VARCHAR(2),
    CNPJ VARCHAR(18),
    IEST VARCHAR(15),
    TELEFONE1 VARCHAR(15),
    EMAIL VARCHAR(50),
    FOR_NOME VARCHAR(75),
    FOR_EMAIL VARCHAR(120),
    FOR_LOCIMAGEM VARCHAR(50),
    FOR_CODREP INTEGER,
    VEN_NOME VARCHAR(45),
    VEN_FONE1 VARCHAR(20),
    SITUACAO VARCHAR(10),
    TIPOFRETE VARCHAR(10),
    CLI_OBSPEDIDO VARCHAR(600),
    CLI_OBSPARTICULAR VARCHAR(600),
    FOR_NOMERED VARCHAR(15))
AS
begin

 for
    select ped_pedido, ped_data, ped_cliente, ped_industria, ped_vendedor, ped_totliq, ped_totbruto, 
           ped_obs, ped_condpag, ped_transp, ped_tipofrete, ped_totalipi, ped_obsfora, ped_cliind, ped_situacao,
           ped_comprador, ped_tabela,
    
    
           cli_nome, cli_endereco, cli_bairro, cli_cep, cli_uf, cli_cidade, cli_cnpj, cli_inscricao, cli_fone1, 
           cli_fone2, cli_fone3, cli_email, cli_ptoref, cli_endcob, cli_baicob,  
           cli_cidcob, cli_cepcob, cli_ufcob, cli_emailnfe, cli_suframa, cli_caixapostal, cli_compendereco, cli_emailfinanc, 
           cli_nomred,
    
           nome, endereco, bairro, cidade, cep, uf, cnpj, iest,  telefone1, email,
    
           for_nome, for_email, for_locimagem, for_codrep,
    
           ven_nome, ven_fone1,      
    
           decode(ped_situacao,
                  'P', 'Pedido'
                  'C', 'Cota??o'
                  'F', 'Pedido'),

           decode(ped_tipofrete,
                  'F', 'FOB',
                  'S', 'CIF'),
           c.cli_obspedido, i.cli_obsparticular, f.for_nomered
    
    
    from pedidos p
    join clientes       c on p.ped_cliente   = c.cli_codigo
    join fornecedores   f on p.ped_industria = f.for_codigo
    join vendedores     v on p.ped_vendedor  = v.ven_codigo
    left join cli_ind   i on c.cli_codigo    = i.cli_codigo and p.ped_industria = i.cli_forcodigo
    left join transportadora t on p.ped_transp    = t.codigo
    where p.ped_pedido = :iped and p.ped_industria = :ifor
    order by ped_pedido
    into
    :ped_pedido, :ped_data, :ped_cliente, :ped_industria, :ped_vendedor, :ped_totliq, :ped_totbruto,
    :ped_obs, :ped_condpag, :ped_transp, :ped_tipofrete, :ped_totalipi, :ped_obsfora, :ped_cliind, :ped_situacao,
    :ped_comprador, :ped_tabela,
    :cli_nome, :cli_endereco, :cli_bairro, :cli_cep, :cli_uf, :cli_cidade, :cli_cnpj, :cli_inscricao, :cli_fone1,
    :cli_fone2, :cli_fone3, :cli_email, :cli_ptoref, :cli_endcob, :cli_baicob,
    :cli_cidcob, :cli_cepcob, :cli_ufcob, :cli_emailnfe, :cli_suframa, :cli_caixapostal, :cli_compendereco, :cli_emailfinanc,
    :cli_nomred,
    :nome, :endereco, :bairro, :cidade, :cep, :uf, :cnpj, :iest, :telefone1, :email,
    :for_nome, :for_email, :for_locimagem, :for_codrep,
    :ven_nome, :ven_fone1,
    :situacao, :tipofrete, :cli_obspedido, :cli_obsparticular, :for_nomered
 do
  select
  first 1 ca.ani_email
  from cli_aniv ca
  where ca.ani_cliente = :ped_cliente and
        ca.ani_nome = :ped_comprador
  into :ped_emailcomp;

 suspend;
end^


ALTER PROCEDURE PROC_INDCLIPODECOMPRAR (
    ICLIENTE INTEGER)
RETURNS (
    CLI_ID INTEGER,
    CLI_INDID INTEGER,
    FOR_NOMERED VARCHAR(15))
AS
begin
  for
    select cli_id, cli_indid, for_nomered
    from IndClientes i
    left join fornecedores f on i.cli_indid = f.for_codigo
    where i.cli_id = :icliente
    into :cli_id, :cli_indid, :for_nomered
  do
  suspend;
end^


ALTER PROCEDURE PROC_INDUSTRIAS (
    IPESQUISA VARCHAR(60),
    IVEND INTEGER,
    IFLAG CHAR(1))
RETURNS (
    ID INTEGER,
    CNPJ VARCHAR(18),
    REDUZIDO VARCHAR(15),
    RAZAO VARCHAR(75),
    TELEFONE VARCHAR(25),
    TELEFONE2 VARCHAR(25),
    SITUACAO VARCHAR(1))
AS
declare variable IVEND2 integer;
begin
 ivend2 = 9999;
 if (ivend > 0) then ivend2 = ivend;


 if (iflag = 'A') then -- ativos
  begin
   if (char_length(ipesquisa) = 0) then
    begin
     for
         select f.for_codigo, f.for_cgc, f.for_nomered, f.for_nome, f.for_fone, f.for_fone2, f.for_tipo2
         from fornecedores f
         where f.for_tipo2 = :iflag
         order by for_tipo2, for_nomered
         into :id, :cnpj, :reduzido, :razao, :telefone, :telefone2, :situacao
     do
     suspend;
    end
   if (char_length(ipesquisa) > 0) then
    begin
      for
         select f.for_codigo, f.for_cgc, f.for_nomered, f.for_nome, f.for_fone, f.for_fone2, f.for_tipo2
         from fornecedores f
         where  f.for_nomered containing :ipesquisa and
                f.for_tipo2 = :iflag
         order by for_tipo2, for_nomered
         into :id, :cnpj, :reduzido, :razao, :telefone, :telefone2, :situacao
      do
      suspend;
    end
  end
 if (iflag = 'I') then -- inativos
  begin
   if (char_length(ipesquisa) = 0) then
    begin
     for
         select f.for_codigo, f.for_cgc, f.for_nomered, f.for_nome, f.for_fone, f.for_fone2, f.for_tipo2
         from fornecedores f
         order by for_tipo2, for_nomered
         into :id, :cnpj, :reduzido, :razao, :telefone, :telefone2, :situacao
     do
     suspend;
    end
   if (char_length(ipesquisa) > 0) then
    begin
      for
         select f.for_codigo, f.for_cgc, f.for_nomered, f.for_nome, f.for_fone, f.for_fone2, f.for_tipo2
         from fornecedores f
--         left join vendedor_ind v on f.for_codigo = v.vin_industria and v.vin_codigo between :ivend and :ivend2
         where  f.for_nome containing :ipesquisa
         order by for_tipo2, for_nomered
         into :id, :cnpj, :reduzido, :razao, :telefone, :telefone2, :situacao
      do
      suspend;
    end
  end


end^


ALTER PROCEDURE PROC_ITEMUNICACOMPRA (
    IFOR INTEGER,
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    PRODUTO VARCHAR(25),
    CLIENTE VARCHAR(30),
    QUANT INTEGER,
    DIA DATE)
AS
begin
 for
    select
      i.ite_produto,
      c.cli_nomred,
      max(p.ped_data) dia,
      sum(i.ite_quant) quant
      from itens_ped i
      join pedidos p on i.ite_pedido = p.ped_pedido
      join clientes c on p.ped_cliente = c.cli_codigo
    where p.ped_industria = :ifor and
          p.ped_data between :idata1 and :idata2 and
          p.ped_situacao in ('P', 'F')
    group by 1, 2
    having count(i.ite_produto) = 1
    order by c.cli_nomred, i.ite_produto
    into :produto, :cliente, :dia, :quant
  do
  suspend;
end^


ALTER PROCEDURE PROC_ITENSCRM (
    ICLI INTEGER,
    IFOR INTEGER)
RETURNS (
    AGE_LANCTO INTEGER,
    AGE_DATA DATE,
    AGE_CLIENTE INTEGER,
    AGE_HORARIO VARCHAR(5),
    AGE_STATUS VARCHAR(1),
    AGE_OBS VARCHAR(1800),
    AGE_INDUSTRIA INTEGER,
    AGE_TELEFONE VARCHAR(35),
    AGE_CONTATO VARCHAR(35),
    AGE_OPERADOR VARCHAR(25),
    FOR_NOMERED VARCHAR(15),
    AGE_TOPICO VARCHAR(25),
    STATUSEXT VARCHAR(20),
    AGE_TIPOINTERACAO CHAR(1),
    INTERACAO VARCHAR(20))
AS
begin
 if (ifor > 0) then
  begin
      for
        select a.age_lancto, a.age_data, a.age_cliente, a.age_horario, a.age_status,
               a.age_assunto, a.age_industria, a.age_telefone, a.age_contato, a.age_operador,
               f.for_nomered, a.age_topico, age_tipointeracao,
               decode(a.age_status,
               'A', 'Em aberto',
               'E', 'Em andamento',
               'F', 'Finalizado'),
               decode(a.age_tipointeracao,
               'L', 'Via telefone',
               'V', 'Visita',
               'E', 'E-mail',
               'M', 'Mensagem por app',
               'R', 'Reuni?o',
               'O', 'Outros')
        from crm_interacoes a
        left join fornecedores f on a.age_industria = f.for_codigo
        where age_cliente = :icli and
              age_industria = :ifor
        order by age_data desc
        into :age_lancto, :age_data, :age_cliente, :age_horario, :age_status,
             :age_obs, :age_industria, :age_telefone, :age_contato, :age_operador,
             :for_nomered, :age_topico, :age_tipointeracao, :statusext, :interacao
      do
      suspend;
  end
 if (ifor = 0) then
  begin
      for
        select a.age_lancto, a.age_data, a.age_cliente, a.age_horario, a.age_status,
               a.age_assunto, a.age_industria, a.age_telefone, a.age_contato, a.age_operador,
               f.for_nomered, a.age_topico, age_tipointeracao,
               decode(a.age_status,
               'A', 'Em aberto',
               'E', 'Em andamento',
               'F', 'Finalizado'),
               decode(a.age_tipointeracao,
               'L', 'Via telefone',
               'V', 'Visita',
               'E', 'E-mail',
               'M', 'Mensagem por app',
               'R', 'Reuni?o',
               'O', 'Outros')
        from crm_interacoes a
        left join fornecedores f on a.age_industria = f.for_codigo
        where age_cliente = :icli
        order by age_data desc
        into :age_lancto, :age_data, :age_cliente, :age_horario, :age_status,
             :age_obs, :age_industria, :age_telefone, :age_contato, :age_operador,
             :for_nomered, :age_topico, :age_tipointeracao, :statusext, :interacao
      do
      suspend;
  end

end^


ALTER PROCEDURE PROC_ITENSNUNCACOMPRADOS (
    ICLIENTE INTEGER,
    IINDUSTRIA INTEGER,
    ICATEG VARCHAR(1))
RETURNS (
    PRO_CODPROD VARCHAR(25),
    PRO_LINHA VARCHAR(800),
    PRO_NOME VARCHAR(100))
AS
begin
 if (icateg = 'I') then
  begin
   for
      with qCompras as (select i.ite_produto
                        from itens_ped i
                        join pedidos pe on i.ite_pedido = pe.ped_pedido and
                                           i.ite_industria = pe.ped_industria
                        where pe.ped_industria = :iindustria and
                              pe.ped_cliente = :icliente and
                              pe.ped_situacao in ('P', 'F')
                        group by 1)

      select distinct
             p.pro_codprod,
             p.pro_aplicacao2,
             p.pro_nome
      from produtos p
      left join qCompras a on p.pro_codprod  = a.ite_produto
      where p.pro_industria = :iindustria and
            a.ite_produto is null
      order by 1
      into :pro_codprod, pro_linha, :pro_nome
   do
   suspend;
  end
 if (icateg <> 'I') then
  begin
   for
      with qCompras as (select i.ite_produto
                        from itens_ped i
                        join pedidos pe on i.ite_pedido = pe.ped_pedido and
                                           i.ite_industria = pe.ped_industria
                        where pe.ped_industria = :iindustria and
                              pe.ped_cliente = :icliente and
                              pe.ped_situacao in ('P', 'F')
                        group by 1)

      select distinct
             p.pro_codprod,
             p.pro_aplicacao2,
             p.pro_nome
      from produtos p
      left join qCompras a on p.pro_codprod  = a.ite_produto
      where p.pro_industria = :iindustria and
            a.ite_produto is null and
            p.pro_setor = :icateg
      order by 1
      into :pro_codprod, pro_linha, :pro_nome
   do
   suspend;
  end
end^


ALTER PROCEDURE PROC_ITENSPRIMEIRACOMPRA (
    IINDUSTRIA INTEGER,
    ICLIENTE INTEGER,
    IPEDIDO VARCHAR(10))
RETURNS (
    OPRODUTO VARCHAR(6000))
AS
begin
  for
    select LIST(x.ite_produto, ',')
    from itens_ped x
    where x.ite_pedido = :ipedido and
          x.ite_produto not in
            (select a.ite_produto
             from itens_ped a
             where a.ite_industria = :iindustria and
                   a.ite_cliente = :icliente and
                   a.ite_pedido <> x.ite_pedido
             group by 1)
     into :oproduto
   do
   suspend;
 end^


ALTER PROCEDURE PROC_ITENSPROMOCLI (
    IPROD VARCHAR(25),
    ITABELA VARCHAR(25))
RETURNS (
    ITEM_CODPROD VARCHAR(25),
    ITEM_VALIDADE DATE,
    ITEM_VALOR DOUBLE PRECISION,
    CLI_NOMRED VARCHAR(30))
AS
begin
 for
    select i.item_procodprod, i.item_validade, i.item_valor, c.cli_nomred
    from itempromocli i
    join clientes c on i.item_cliid = c.cli_codigo
    where i.item_procodprod = :iprod and
          i.item_tabela = :itabela
    order by 1
    into :item_codprod, item_validade, item_valor, cli_nomred
  do
  suspend;
end^


ALTER PROCEDURE PROC_ITENSTELEMKT (
    ICLI INTEGER,
    IFOR INTEGER)
RETURNS (
    AGE_LANCTO INTEGER,
    AGE_DATA DATE,
    AGE_CLIENTE INTEGER,
    AGE_HORARIO VARCHAR(5),
    AGE_STATUS VARCHAR(1),
    AGE_OBS VARCHAR(1800),
    AGE_INDUSTRIA INTEGER,
    AGE_TELEFONE VARCHAR(35),
    AGE_CONTATO VARCHAR(35),
    AGE_OPERADOR VARCHAR(25),
    FOR_NOMERED VARCHAR(15),
    AGE_TOPICO VARCHAR(25),
    STATUSEXT VARCHAR(20))
AS
begin
 if (ifor > 0) then
  begin
      for
        select a.age_lancto, a.age_data, a.age_cliente, a.age_horario, a.age_status,
               a.age_assunto, a.age_industria, a.age_telefone, a.age_contato, a.age_operador,
               f.for_nomered, a.age_topico,
               case a.age_status
               when 'A' then 'Em aberto'
               when 'E' then 'Em andamento'
               when 'F' then 'Finalizado'
               end as stat
        from agenda a
        left join fornecedores f on a.age_industria = f.for_codigo
        where age_cliente = :icli and
              age_industria = :ifor
        order by age_data desc
        into :age_lancto, :age_data, :age_cliente, :age_horario, :age_status,
             :age_obs, :age_industria, :age_telefone, :age_contato, :age_operador,
             :for_nomered, :age_topico, :statusext
      do
      suspend;
  end
 if (ifor = 0) then
  begin
      for
        select a.age_lancto, a.age_data, a.age_cliente, a.age_horario, a.age_status,
               a.age_assunto, a.age_industria, a.age_telefone, a.age_contato, a.age_operador,
               f.for_nomered, a.age_topico,
               case a.age_status
               when 'A' then 'Em aberto'
               when 'E' then 'Em andamento'
               when 'F' then 'Finalizado'
               end as stat
        from agenda a
        left join fornecedores f on a.age_industria = f.for_codigo
        where age_cliente = :icli
        order by age_data desc
        into :age_lancto, :age_data, :age_cliente, :age_horario, :age_status,
             :age_obs, :age_industria, :age_telefone, :age_contato, :age_operador,
             :for_nomered, :age_topico, :statusext
      do
      suspend;
  end

end^


ALTER PROCEDURE PROC_LANCTOSNAOCOMPRADO (
    IDFOR INTEGER,
    IDCLI INTEGER)
RETURNS (
    IDNAOCOMP VARCHAR(25),
    QTDLANCTOS INTEGER,
    PROTIFOLIO INTEGER,
    LANCAMENTO CHAR(1),
    QTDNAOCOMP INTEGER)
AS
declare variable VDIAS integer;
begin
  select count(p.pro_codigo)
  from produtos p
  where p.pro_industria = :idfor
  into :protifolio;

  select count(c.pro_codigonormalizado)
  from cad_prod c
  where c.pro_industria = :idfor and
        (current_date - pro_datalancamento) <= 180
  into :qtdlanctos;

  delete from tab_temp  where tmp_id > 0;

  merge into tab_temp t
  using
    (select i.ite_produto, max(fn_normalizar_codigo(i.ite_produto)) idProd
     from itens_ped i
     where i.ite_industria = :idfor and
           i.ite_cliente = :idcli
     group by 1
     order by 1) src
  on src.idProd = t.tmp_proid
  when not matched then
  insert (tmp_proid)
  values (idProd);

  select count(c.pro_codigonormalizado)
  from cad_prod c
  left join tab_temp x on c.pro_codigonormalizado = x.tmp_proid
  where c.pro_industria = :idfor and
        x.tmp_proid is null
   order by 1
  into :qtdnaocomp;

  for
    select p.pro_codprod, (current_date - p.pro_datalancamento),
          iif((current_date - p.pro_datalancamento) <= 180, 'S','')
      from cad_prod p
      left join (
           select distinct iv.ite_produto
           from itens_ped iv
           where iv.ite_industria = :idfor and
                 iv.ite_cliente   = :idcli
            ) comprados
        on comprados.ite_produto = p.pro_codigonormalizado
     where p.pro_industria = :idfor and
           comprados.ite_produto is null
     order by 1, 3 desc
   into :idnaocomp, :vdias, :lancamento
   do
   begin
    suspend;
   end
end^


ALTER PROCEDURE PROC_LISTARECEBER (
    ICLIENTE INTEGER,
    IVENDA INTEGER)
RETURNS (
    OLANCTO INTEGER,
    ODOCTO VARCHAR(15),
    ODATA DATE,
    OVALOR DOUBLE PRECISION,
    OVENC DATE)
AS
begin
  for
   select c.lan_lancto, c.lan_docto, c.lan_data, c.lan_valor, c.lan_vencimento
   from contaspgrec c
   where c.lan_clifor = :icliente
   order by 1
   into :olancto, :odocto, :odata, :ovalor, :ovenc
  do
  suspend;
end^


ALTER PROCEDURE PROC_MAPAANO (
    ICLIENTE INTEGER,
    IVEND INTEGER,
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDE CHAR(1))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    INDUSTRIA VARCHAR(15),
    MESANO VARCHAR(10),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION)
AS
declare variable VREDELOJA varchar(35);
declare variable IVEND2 integer;
declare variable IIND2 integer;
declare variable ICLIENTE2 integer;
begin
 ivend2 = ivend;
 iind2  = iind;
 icliente2 = icliente;

 if (icliente is null) then
 begin
 icliente = 1;
 icliente2 = 9999;
 end

 if (ivend is null or ivend = 0) then
  begin
    ivend  = 1;
    ivend2 = 999;
  end

 if (iind is null or iind = 0) then
  begin
    iind  = 1;
    iind2 = 9999;
  end

 delete from tab_temp where tmp_id > 0;

 if (:irede = 'S') then
  begin
   select cli_redeloja from clientes where cli_codigo = :icliente
   into :vredeloja;
  end


 if (:irede = 'N') then
  begin
      for
        select p.ped_pedido, f.for_nomered,
        cast(extract(year from p.ped_data) ||'/'|| extract(month from p.ped_data)||'/28' as date) MesAno,
        (select sum(ite_totliquido) from itens_ped where ite_pedido = p.ped_pedido) total,
        (select sum(ite_quant) from itens_ped where ite_pedido = p.ped_pedido) totalqtd
        from pedidos p
        join fornecedores f on p.ped_industria = f.for_codigo
        where p.ped_data      between :idata1 and :iData2 and
              p.ped_vendedor  between :ivend  and :ivend2 and
              p.ped_cliente   between :icliente and :icliente2 and
              p.ped_industria between :iInd   and :iind2  and
              p.ped_situacao  in ('P','F')
        group by 1,2,3
        order by 2,3
       into :ped_pedido, :industria, :mesano, :total, :totalqtd
      do
      suspend;
  end
 if (:irede = 'S') then
  begin
      for
        select p.ped_pedido, f.for_nomered,
        cast(extract(year from p.ped_data) ||'/'|| extract(month from p.ped_data)||'/28' as date) MesAno,
        (select sum(ite_totliquido) from itens_ped where ite_pedido = p.ped_pedido) total,
        (select sum(ite_quant) from itens_ped where ite_pedido = p.ped_pedido) totalqtd
        from pedidos p
        join clientes c on p.ped_cliente = c.cli_codigo
        join fornecedores f on p.ped_industria = f.for_codigo
        where p.ped_data      between :idata1 and :iData2 and
              p.ped_vendedor  between :ivend  and :ivend2 and
              p.ped_industria between :iInd   and :iind2  and
              p.ped_situacao  in ('P','F')    and
              c.cli_redeloja = :vredeloja
        group by 1,2,3
        order by 2,3
       into :ped_pedido, :industria, :mesano, :total, :totalqtd
      do
      suspend;
  end

end^


ALTER PROCEDURE PROC_MAPAANOCLI (
    IDATA1 DATE,
    IDATA2 DATE,
    IGRUPOLOJA BOOLEAN,
    IFOR INTEGER,
    IDETALHADA BOOLEAN)
RETURNS (
    PEDIDO VARCHAR(10),
    CLIENTE VARCHAR(30),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION,
    MES VARCHAR(10),
    INDUSTRIA VARCHAR(35),
    DATAPED DATE)
AS
begin
 if (idetalhada = false) then
  begin
   if (igrupoloja = false) then
    begin
      for
        select cli_nomred,
               f.for_nomered,
               max(p.ped_data),
               sum(ite_totliquido) total,
               sum(ite_quant) totalqtd,
               max(extract( month from p.ped_data) ||'/'|| extract( year from p.ped_data))
        from itens_ped i
        join pedidos  p on i.ite_pedido  = p.ped_pedido and i.ite_industria = p.ped_industria
        join clientes c on p.ped_cliente = c.cli_codigo
        join fornecedores f on p.ped_industria = f.for_codigo
        where p.ped_situacao in ('P','F')
        and p.ped_data between :idata1 and :idata2
        group by 2,1
        order by 2,3,1
        into :cliente, :industria, :dataped, :total, :totalqtd, :mes
      do
      begin
       pedido = '';
       suspend;
      end
   end
   else
   begin
      for
        select cli_redeloja cliente,
               f.for_nomered,
               max(p.ped_data),
               sum(ite_totliquido) total,
               sum(ite_quant) totalqtd,
               max(extract( month from p.ped_data) ||'/'|| extract( year from p.ped_data))
        from itens_ped i
        join pedidos  p on i.ite_pedido  = p.ped_pedido and i.ite_industria = p.ped_industria
        join clientes c on p.ped_cliente = c.cli_codigo
        join fornecedores f on p.ped_industria = f.for_codigo
        where p.ped_situacao in ('P','F')
        and p.ped_data between :idata1 and :idata2
        and c.cli_redeloja is not null
        group by 2,1
        order by 2,3,1
        into :cliente, :industria, :dataped, :total, :totalqtd, :mes
      do
      begin
       pedido = '';
       suspend;
      end
   end
  end -- relatorio nao detalhado
 if (idetalhada = true) then
  begin
      for
        select distinct
               p.ped_pedido,
               cli_nomred,
               f.for_nomered,
               p.ped_data,
               p.ped_totliq total,
               (select sum(i.ite_quant) from itens_ped i where i.ite_pedido = p.ped_pedido) qut
        from pedidos p
        join clientes c on p.ped_cliente = c.cli_codigo
        join fornecedores f on p.ped_industria = f.for_codigo
        where p.ped_situacao in ('P','F')
        and p.ped_data between :idata1 and :idata2
        order by f.for_nomered, p.ped_data desc
        into :pedido, :cliente, :industria, :dataped, :total, :totalqtd
      do
      begin
        mes = extract( month from :dataped) ||'/'|| extract( year from :dataped);
        suspend;
      end
  end
end^


ALTER PROCEDURE PROC_MAPAANOVEND (
    IDATA1 DATE,
    IDATA2 DATE,
    IVEND INTEGER)
RETURNS (
    INDUSTRIA VARCHAR(30),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION,
    MES VARCHAR(10))
AS
begin
      for
        select f.for_nomered indust,
               sum(ite_totliquido) total,
               sum(ite_quant) totalqtd,
               cast( extract( year from p.ped_data) ||'/'|| extract( month from p.ped_data) ||'/'||'28' as date) mes
        from itens_ped i
        join pedidos  p on i.ite_pedido  = p.ped_pedido and i.ite_industria = p.ped_industria
        join fornecedores f on p.ped_industria = f.for_codigo
        where p.ped_situacao in ('P','F')
        and p.ped_data between :idata1 and :idata2
        and p.ped_vendedor = :ivend
        group by 4, 1
        order by 4, 1
        into :industria, :total, :totalqtd, :mes
      do
      suspend;
end^


ALTER PROCEDURE PROC_MAPACLIGERAL (
    IIND INTEGER,
    ICLI INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDELOJA CHAR(1))
RETURNS (
    OCODIGO VARCHAR(25),
    ODESCRICAO VARCHAR(50),
    OCLIENTE INTEGER,
    OGERAL INTEGER)
AS
declare variable ICLI2 integer;
declare variable VREDELOJA varchar(35);
begin
 delete from tab_temp where tmp_id > 0;

 icli2 = 9999;

 if (:iredeloja = 'S') then
  begin
   select cli_redeloja from clientes where cli_codigo = :icli
   into :vredeloja;
  end

 if (iredeloja = 'S') then
  begin
     for
        select
        i.ite_produto, max(left(i.ite_nomeprod,50)) descricao,
        sum(iif(c.cli_redeloja =  :vredeloja, i.ite_quant, 0)) as cliente,
        sum(iif(c.cli_redeloja <> :vredeloja, i.ite_quant, 0)) as outros
        from itens_ped i
        join pedidos  p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
        join clientes c on p.ped_cliente = c.cli_codigo
        where p.ped_data between :idata1 and :idata2 and p.ped_industria = :iind and
              p.ped_situacao in ('P', 'F') and
              c.cli_tipopes = 'A'
        group by 1
        order by 3 desc
        into :ocodigo, :odescricao, :ocliente, :ogeral
     do
      suspend;
  end
 if (iredeloja = 'N') then
  begin
     for
        select
        i.ite_produto,
        max(left(t.pro_nome,50)),
        sum(iif(p.ped_cliente =  :icli, i.ite_quant, 0)),
        sum(iif(p.ped_cliente <> :icli, i.ite_quant, 0))
        from itens_ped i
        join pedidos   p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
        left join produtos t on i.ite_produto = t.pro_codprod and p.ped_industria = t.pro_industria and p.ped_tabela = t.pro_nometabela
        where p.ped_data between :idata1 and :idata2 and p.ped_industria = :iind and
              p.ped_situacao in ('P', 'F') and
              p.ped_cliente between :icli and :icli2
        group by 1
        order by 3 desc
        into :ocodigo, :odescricao, :ocliente, :ogeral
     do
      suspend;
  end

end^


ALTER PROCEDURE PROC_MAPACLIMONTH_TO_MONTH (
    IDATA1 DATE,
    IDATA2 DATE,
    IGRUPOLOJA BOOLEAN,
    IFOR INTEGER)
RETURNS (
    CLIENTE VARCHAR(30),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION,
    MES VARCHAR(10))
AS
begin
   if (igrupoloja = false) then
    begin
      for
        select cli_nomred cliente,
               Coalesce(sum(ite_totliquido),0),
               Coalesce(sum(ite_quant), 0),
               cast( extract( year from p.ped_data) ||'/'|| extract( month from p.ped_data) ||'/'||'28' as date)
        from itens_ped i
        join pedidos  p on i.ite_pedido  = p.ped_pedido and i.ite_industria = p.ped_industria
        join clientes c on p.ped_cliente = c.cli_codigo
        where p.ped_situacao in ('P','F')
        and p.ped_data between :idata1 and :idata2
        and p.ped_industria = :ifor
        group by 4, 1
        order by 4, 1
        into :cliente, :total, :totalqtd, :mes
      do
      suspend;
   end
   else
   begin
      for
        select c.cli_redeloja cliente,
               Coalesce(sum(ite_totliquido),0),
               Coalesce(sum(ite_quant), 0),
               cast( extract( year from p.ped_data) ||'/'|| extract( month from p.ped_data) ||'/'||'28' as date)
        from itens_ped i
        join pedidos  p on i.ite_pedido  = p.ped_pedido and i.ite_industria = p.ped_industria
        join clientes c on p.ped_cliente = c.cli_codigo
        where p.ped_situacao in ('P','F')
        and p.ped_data between :idata1 and :idata2
        and p.ped_industria = :ifor and
        c.cli_redeloja is not null
        group by 4, 1
        order by 4, 1
        into :cliente, :total, :totalqtd, :mes
      do
      suspend;
   end
end^


ALTER PROCEDURE PROC_MAPACOMP (
    IINDUSTRIA INTEGER,
    ICLIENTE1 INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IFILTRO CHAR(1),
    ICATEG CHAR(1))
RETURNS (
    MES CHAR(25),
    ATU DOUBLE PRECISION,
    ANT DOUBLE PRECISION,
    RET DOUBLE PRECISION)
AS
declare variable VSQL varchar(2000);
declare variable VLB char(2);
declare variable VCLIENTE2 integer;
begin
 vlb  = ascii_char(13)||ascii_char(10);
 vSql = '';

 if (icliente1 = 0) then
  begin
   icliente1 = 0;
   vcliente2 = 9999;
  end
  else
  begin
   vcliente2 = icliente1;
  end

 if (ifiltro = 'V' and icateg = 'M') then -- mapa em valor por mes
  begin
         vsql = 'with recursive r (dt_ini, dt_fim) as '
         ||vlb||'(select cast(:pDataInicial as date), '
         ||vlb||' dateadd(month, 1, cast(:pdatainicial as date)) - 1 '
         ||vlb||' from rdb$database '
         ||vlb||' union all '
         ||vlb||' select dateadd(month, 1, r.dt_ini), '
         ||vlb||' dateadd(month, 2, r.dt_ini) - 1 '
         ||vlb||' from r '
         ||vlb||' where r.dt_fim < :pdatafinal)'
         ||vlb||' '
         ||vlb||' select extract(month from r.dt_ini) mes, '
         ||vlb||' sum(iif(p.ped_data between r.dt_ini and r.dt_fim, i.ite_totliquido, 0)) atu, '
         ||vlb||' sum(iif(p.ped_data between dateadd(year, -1, r.dt_ini) and dateadd(year, -1, r.dt_fim), i.ite_totliquido, 0)) ant, '
         ||vlb||' sum(iif(p.ped_data between dateadd(year, -2, r.dt_ini) and dateadd(year, -2, r.dt_fim), i.ite_totliquido, 0)) ret '
         ||vlb||' from r '
         ||vlb||' left join pedidos p on p.ped_data between dateadd(year, -2, r.dt_ini) and r.dt_fim and p.ped_situacao in (''P'',''F'') and p.ped_industria = :xInd and p.ped_cliente between :xcli1 and :xcli2 '
         ||vlb||' left join itens_ped i on p.ped_pedido = i.ite_pedido and p.ped_industria = i.ite_industria '
         ||vlb||'group by 1 ';
  end

 if (ifiltro = 'Q' and icateg = 'M') then -- mapa em quantidade por mes
  begin
         vsql = 'with recursive r (dt_ini, dt_fim) as  '
         ||vlb||'(select cast(:pDataInicial as date), '
         ||vlb||' dateadd(month, 1, cast(:pdatainicial as date)) - 1 '
         ||vlb||' from rdb$database '
         ||vlb||' union all '
         ||vlb||' select dateadd(month, 1, r.dt_ini), '
         ||vlb||' dateadd(month, 2, r.dt_ini) - 1 '
         ||vlb||' from r '
         ||vlb||' where r.dt_fim < :pdatafinal)'
         ||vlb||' '
         ||vlb||' select extract(month from r.dt_ini) mes, '
         ||vlb||' sum(iif(p.ped_data between r.dt_ini and r.dt_fim, i.ite_quant, 0)) atu, '
         ||vlb||' sum(iif(p.ped_data between dateadd(year, -1, r.dt_ini) and dateadd(year, -1, r.dt_fim), i.ite_quant, 0)) ant, '
         ||vlb||' sum(iif(p.ped_data between dateadd(year, -2, r.dt_ini) and dateadd(year, -2, r.dt_fim), i.ite_quant, 0)) ret '
         ||vlb||' from r '
         ||vlb||' left join pedidos p on p.ped_data between dateadd(year, -2, r.dt_ini) and r.dt_fim and p.ped_situacao in (''P'',''F'') and p.ped_industria = :xInd and p.ped_cliente between :xcli1 and :xcli2 '
         ||vlb||' left join itens_ped i on p.ped_pedido = i.ite_pedido and p.ped_industria = i.ite_industria '
         ||vlb||'group by 1 ';
  end

 if (ifiltro = 'V' and icateg = 'C') then -- mapa em valor por codigos
  begin
         vsql = 'with recursive r (dt_ini, dt_fim) as '
         ||vlb||'(select cast(:pDataInicial as date), '
         ||vlb||' dateadd(month, 1, cast(:pdatainicial as date)) - 1 '
         ||vlb||' from rdb$database '
         ||vlb||' union all '
         ||vlb||' select dateadd(month, 1, r.dt_ini), '
         ||vlb||' dateadd(month, 2, r.dt_ini) - 1 '
         ||vlb||' from r '
         ||vlb||' where r.dt_fim < :pdatafinal)'
         ||vlb||' '
         ||vlb||' select i.ite_produto mes, '
         ||vlb||' sum(iif(p.ped_data between r.dt_ini and r.dt_fim, i.ite_totliquido, 0)) atu, '
         ||vlb||' sum(iif(p.ped_data between dateadd(year, -1, r.dt_ini) and dateadd(year, -1, r.dt_fim), i.ite_totliquido, 0)) ant, '
         ||vlb||' sum(iif(p.ped_data between dateadd(year, -2, r.dt_ini) and dateadd(year, -2, r.dt_fim), i.ite_totliquido, 0)) ret '
         ||vlb||' from r '
         ||vlb||' left join pedidos p on p.ped_data between dateadd(year, -2, r.dt_ini) and r.dt_fim and p.ped_situacao in (''P'',''F'') and p.ped_industria = :xInd and p.ped_cliente between :xcli1 and :xcli2 '
         ||vlb||' left join itens_ped i on p.ped_pedido = i.ite_pedido and p.ped_industria = i.ite_industria '
         ||vlb||'group by 1 ';
  end

 if (ifiltro = 'Q' and icateg = 'C') then -- mapa em quantidade por codigo
  begin
         vsql = 'with recursive r (dt_ini, dt_fim) as  '
         ||vlb||'(select cast(:pDataInicial as date), '
         ||vlb||' dateadd(month, 1, cast(:pdatainicial as date)) - 1 '
         ||vlb||' from rdb$database '
         ||vlb||' union all '
         ||vlb||' select dateadd(month, 1, r.dt_ini), '
         ||vlb||' dateadd(month, 2, r.dt_ini) - 1 '
         ||vlb||' from r '
         ||vlb||' where r.dt_fim < :pdatafinal)'
         ||vlb||' '
         ||vlb||' select i.ite_produto mes, '
         ||vlb||' sum(iif(p.ped_data between r.dt_ini and r.dt_fim, i.ite_quant, 0)) atu, '
         ||vlb||' sum(iif(p.ped_data between dateadd(year, -1, r.dt_ini) and dateadd(year, -1, r.dt_fim), i.ite_quant, 0)) ant, '
         ||vlb||' sum(iif(p.ped_data between dateadd(year, -2, r.dt_ini) and dateadd(year, -2, r.dt_fim), i.ite_quant, 0)) ret '
         ||vlb||' from r '
         ||vlb||' left join pedidos p on p.ped_data between dateadd(year, -2, r.dt_ini) and r.dt_fim and p.ped_situacao in (''P'',''F'') and p.ped_industria = :xInd and p.ped_cliente between :xcli1 and :xcli2 '
         ||vlb||' left join itens_ped i on p.ped_pedido = i.ite_pedido and p.ped_industria = i.ite_industria '
         ||vlb||'group by 1 ';
  end

 for
   execute statement (vSql) (xind := :iindustria, pdatainicial := :idata1, pdatafinal := :idata2, xcli1 := :icliente1, xcli2 := :vcliente2)
   into :mes, :atu, :ant, :ret
 do
  suspend;
end^


ALTER PROCEDURE PROC_MAPAFECHASELLS (
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDE CHAR(1))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    CLIENTE VARCHAR(35),
    MESANO VARCHAR(10),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION)
AS
begin
 delete from tab_temp where tmp_id > 0;

 if (:irede = 'N') then
  begin
      for
        select p.ped_pedido, c.cli_nomred,
        cast(extract(year from p.ped_data) ||'/'|| extract(month from p.ped_data)||'/28' as date) MesAno,
        (select sum(ite_totliquido) from itens_ped where ite_pedido = p.ped_pedido) total,
        (select sum(ite_quant) from itens_ped where ite_pedido = p.ped_pedido) totalqtd
        from pedidos p
        join clientes c on p.ped_cliente = c.cli_codigo
        where p.ped_data between :idata1 and :iData2 and
              p.ped_industria = :iInd and
              p.ped_situacao in ('P','F')
        group by 1,2,3
        order by 2,3, 4 desc
       into :ped_pedido, :cliente, :mesano, :total, :totalqtd
      do
      suspend;
  end
 if (:irede = 'S') then
  begin
      for
        select p.ped_pedido, c.cli_redeloja,
        cast(extract(year from p.ped_data) ||'/'|| extract(month from p.ped_data)||'/28' as date) MesAno,
        (select sum(ite_totliquido) from itens_ped where ite_pedido = p.ped_pedido) total,
        (select sum(ite_quant) from itens_ped where ite_pedido = p.ped_pedido) totalqtd
        from pedidos p
        join clientes c on p.ped_cliente = c.cli_codigo
        where p.ped_data      between :idata1 and :iData2 and
              p.ped_industria = :iind         and
              p.ped_situacao  in ('P','F')
        group by 1,2,3
        order by 2,3
       into :ped_pedido, :cliente, :mesano, :total, :totalqtd
      do
      suspend;
  end

end^


ALTER PROCEDURE PROC_MAPAGERALCLI (
    IDATA1 DATE,
    IDATA2 DATE,
    IFLAG CHAR(1),
    IFOR INTEGER,
    ICLI INTEGER,
    IREDE BOOLEAN,
    IVENDEDOR INTEGER)
RETURNS (
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(45),
    DIA DATE,
    TOTAL DOUBLE PRECISION,
    DIASSEMCOMPRA INTEGER,
    CLIUF CHAR(2))
AS
declare variable IFOR2 integer;
declare variable ICLI2 integer;
declare variable VREDELOJA varchar(35);
declare variable IVENDEDOR2 integer;
begin
 if (irede = true) then
  begin
   select cli_redeloja from clientes where cli_codigo = :icli
   into :vredeloja;
  end


 ifor2 = ifor;
 icli2 = icli;
 ivendedor2 = ivendedor;

 if (ifor = 0) then
  begin
   ifor = 1;
   ifor2 = 9999;
  end
 if (ivendedor = 0) then
  begin
   ivendedor = 1;
   ivendedor2 = 9999;
  end
 if (icli = 0) then
  begin
   icli = 1;
   icli2 = 9999;
  end

 if (irede = false) then
  begin
      if (iflag = 'V') then  --valor
       begin
        for
            select
                   f.for_nomered,
                   c.cli_nomred,
                   max(p.ped_data),
                   sum(p.ped_totliq),
                   c.cli_uf
            from pedidos p
            join fornecedores f   on p.ped_industria =  f.for_codigo
            join clientes c       on p.ped_cliente   = c.cli_codigo
            where p.ped_data       between :idata1 and :idata2 and
                  p.ped_situacao   in ('P','F') and
                  p.ped_cliente    between :icli and :icli2 and
                  p.ped_industria  between :ifor and :ifor2 and
                  c.cli_vendedor   between :ivendedor and :ivendedor2 and
                  f.for_tipo2 = 'A' and
                  c.cli_tipopes = 'A'
            group by 1,2,5
            order by 1
            into :for_nomered, :cli_nomred, :dia, :total, :cliuf
        do
         begin
           diassemcompra = (current_date - dia);
           suspend;
         end
       end
    
      if (iflag = 'Q') then --quantidade
       begin
        for
            select f.for_nomered,
                   c.cli_nomred,
                   max(p.ped_data),
                   sum(i.ite_quant),
                   c.cli_uf
            from pedidos p
            join itens_ped i      on p.ped_pedido    = i.ite_pedido and p.ped_industria = i.ite_industria
            join fornecedores f   on p.ped_industria = f.for_codigo
            join clientes c       on p.ped_cliente   = c.cli_codigo
            where p.ped_data between :idata1 and :idata2 and
                  p.ped_situacao in ('P','F') and
                  p.ped_cliente    between :icli and :icli2 and
                  p.ped_industria  between :ifor and :ifor2 and
                  c.cli_vendedor   between :ivendedor and :ivendedor2 and
                  f.for_tipo2 = 'A' and
                  c.cli_tipopes = 'A'
            group by 1,2,5
            order by 1
            into :for_nomered, :cli_nomred, :dia, :total, :cliuf
        do
         begin
           diassemcompra = (current_date - dia);
           suspend;
         end
       end
      if (iflag = 'D') then --dt ultima compra
       begin
        for
          with vendas_rank as (
           select p.ped_industria,
                  p.ped_cliente,
                  p.ped_data ult_compra,
                  p.ped_totliq,
                  f.for_nomered,
                  row_number() over (partition by p.ped_industria, p.ped_cliente order by p.ped_data desc) as rn
           from pedidos p
           join fornecedores f   on p.ped_industria = f.for_codigo
           join clientes c       on p.ped_cliente   = c.cli_codigo
           where p.ped_data between :idata1 and :idata2 and
                 p.ped_industria  between :ifor and :ifor2 and
                 c.cli_vendedor   between :ivendedor and :ivendedor2 and
                 p.ped_situacao in ('P','F') and
                 f.for_tipo2 = 'A' )


           select vr.for_nomered,
                  c.cli_nomred,
                  vr.ult_compra,
                  vr.ped_totliq,
                  c.cli_uf
           from clientes c
           left join vendas_rank vr on c.cli_codigo = vr.ped_cliente and vr.rn = 1
           where vr.ped_totliq > 0 and
                 vr.ped_cliente    between :icli and :icli2 and
                 c.cli_tipopes = 'A'

           order by 1,2
           into :for_nomered, :cli_nomred, :dia, :total, :cliuf
        do
         begin
           diassemcompra = (current_date - dia);
           suspend;
         end
       end
  end
  else -- grupo de lojas
  begin
      if (iflag = 'V') then  --valor
       begin
        for
            select f.for_nomered,
                   c.cli_nomred,
                   max(p.ped_data),
                   sum(p.ped_totliq),
                   c.cli_uf
            from pedidos p
            join fornecedores f   on p.ped_industria =  f.for_codigo
            join clientes c       on p.ped_cliente   = c.cli_codigo
            where p.ped_data between :idata1 and :idata2 and
                  p.ped_situacao in ('P','F') and
                  p.ped_industria between :ifor and :ifor2 and
                  f.for_tipo2 = 'A' and
                  c.cli_tipopes = 'A' and
                  c.cli_redeloja = :vredeloja

            group by 1,2,5
            order by 1
            into :for_nomered, :cli_nomred, :dia, :total, :cliuf
        do
         begin
           diassemcompra = (current_date - dia);
           suspend;
         end
       end
    
      if (iflag = 'Q') then --quantidade
       begin
        for
            select f.for_nomered,
                   c.cli_nomred,
                   max(p.ped_data),
                   sum(i.ite_quant),
                   c.cli_uf
            from pedidos p
            join itens_ped i      on p.ped_pedido    = i.ite_pedido and p.ped_industria = i.ite_industria
            join fornecedores f   on p.ped_industria = f.for_codigo
            join clientes c       on p.ped_cliente   = c.cli_codigo
            where p.ped_data between :idata1 and :idata2 and
                  p.ped_situacao in ('P','F') and
                  p.ped_industria between :ifor and :ifor2 and
                  f.for_tipo2 = 'A' and
                  c.cli_tipopes = 'A' and
                  c.cli_redeloja = :vredeloja


            group by 1,2,5
            order by 1
            into :for_nomered, :cli_nomred, :dia, :total, :cliuf
        do
         begin
           diassemcompra = (current_date - dia);
           suspend;
         end
       end
      if (iflag = 'D') then --dt ultima compra
       begin
        for
          with vendas_rank as (
           select p.ped_industria,
                  p.ped_cliente,
                  p.ped_data  ult_compra,
                  p.ped_totliq,
                  row_number() over (partition by p.ped_industria, p.ped_cliente order by p.ped_data desc) as rn
           from pedidos p
           where p.ped_data between :idata1 and :idata2 and
                 p.ped_industria between :ifor and :ifor2 and
                 p.ped_situacao in ('P','F') )


           select f.for_nomered,
                  c.cli_nomred,
                  vr.ult_compra,
                  vr.ped_totliq,
                  c.cli_uf
           from clientes c
           left join vendas_rank vr on c.cli_codigo = vr.ped_cliente and vr.rn = 1
           join fornecedores f   on vr.ped_industria = f.for_codigo
           where vr.ped_totliq > 0 and
                  f.for_tipo2 = 'A' and
                  c.cli_tipopes = 'A' and
                  c.cli_redeloja = :vredeloja

           order by 1,2
           into :for_nomered, :cli_nomred, :dia, :total, :cliuf
        do
         begin
           diassemcompra = (current_date - dia);
           suspend;
         end
       end
  end
end^


ALTER PROCEDURE PROC_MAPAGRLOJAS (
    IDATA1 DATE,
    IDATA2 DATE,
    IFOR INTEGER)
RETURNS (
    CLIENTE VARCHAR(30),
    GRUPO VARCHAR(35),
    TOTAL DOUBLE PRECISION,
    MES DATE,
    PEDIDO VARCHAR(10),
    QUANT DOUBLE PRECISION)
AS
begin
      for
        select distinct
               cli_nomred,
               p.ped_pedido,
               c.cli_redeloja,
               p.ped_totliq,
               p.ped_data,
               sum(i.ite_quant) over(partition by p.ped_pedido, c.cli_nomred)
        from itens_ped i
        join pedidos   p on i.ite_pedido  = p.ped_pedido and i.ite_industria = p.ped_industria
        join clientes  c on p.ped_cliente = c.cli_codigo
        where p.ped_situacao in ('P','F')
        and p.ped_data between :idata1 and :idata2
        and p.ped_industria = :ifor
        and c.cli_redeloja <> ''
        order by c.cli_nomred, p.ped_data desc
        into :cliente, :pedido, :grupo, :total, :mes, :quant
      do
      suspend;
end^


ALTER PROCEDURE PROC_MAPAITEMVENDIDO (
    PDT1 DATE,
    PDT2 DATE,
    PIND INTEGER,
    PCLI INTEGER,
    PGRUPOLOJAS BOOLEAN,
    PCATEGORIA BOOLEAN)
RETURNS (
    ITEM VARCHAR(25),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION,
    MESANO VARCHAR(10),
    DIA DATE)
AS
declare variable PCLI2 integer;
declare variable VREDELOJA varchar(35);
begin
 if (pgrupolojas) then
  begin
    select cli_redeloja from clientes where cli_codigo = :pcli
    into :vredeloja;
  end

 pcli2 = pcli;
 if (pcli = 0) then
    pcli2 = 9999;

if (not pgrupolojas) then
 begin
  if (not pcategoria) then
   begin
      for
         select trim(i.ite_produto),
                sum(i.ite_totliquido),
                sum(i.ite_quant),
                (extract( year from p.ped_data) ||'/'|| extract( month from p.ped_data)),
                max(last_day(of month from p.ped_data))
         from itens_ped i
         join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
         where p.ped_situacao in ('P','F') and
               p.ped_data between :pdt1 and :pdt2 and
               p.ped_industria   = :pind and
               p.ped_cliente between :pcli and :pcli2
         group by 1, 4
         order by 5, 1
       into  :item, :total, :totalqtd, :mesano, :dia
      do
      suspend;
   end
   if (pcategoria) then
    begin
      for
         select i.ite_produto,
                sum(i.ite_totliquido),
                sum(i.ite_quant),
                (extract( year from p.ped_data) ||'/'|| extract( month from p.ped_data)),
                max(last_day(of month from p.ped_data))
         from itens_ped i
         join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
         join produtos t on i.ite_produto = t.pro_codprod and i.ite_industria = t.pro_industria and p.ped_tabela = t.pro_nometabela
         where p.ped_situacao in ('P','F') and
               p.ped_data between :pdt1 and :pdt2 and
               p.ped_industria   = :pind and
               t.pro_setor = 'T' and --lancamentos
               p.ped_cliente between :pcli and :pcli2
         group by 1, 4
         order by 5, 1
       into  :item, :total, :totalqtd, :mesano, :dia
      do
      suspend;
    end
 end

if (pgrupolojas) then
 begin
  if (not pcategoria) then
   begin
      for
         select i.ite_produto,
                sum(i.ite_totliquido),
                sum(i.ite_quant),
                (extract( year from p.ped_data) ||'/'|| extract( month from p.ped_data)),
                max(last_day(of month from p.ped_data))
         from itens_ped i 
         join pedidos  p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
         join clientes c on p.ped_cliente = c.cli_codigo
         where p.ped_situacao in ('P','F') and
               p.ped_data between :pdt1 and :pdt2 and
               p.ped_industria   = :pind and
               c.cli_redeloja = :vredeloja
         group by 4,1
         order by 4,1
       into  :item, :total, :totalqtd, :mesano, :dia
      do
      suspend;
   end
  if (pcategoria) then
   begin
      for
         select i.ite_produto,
                sum(i.ite_totliquido),
                sum(i.ite_quant),
                (extract( year from p.ped_data) ||'/'|| extract( month from p.ped_data)),
                max(last_day(of month from p.ped_data))
         from itens_ped i
         join pedidos  p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
         join clientes c on p.ped_cliente = c.cli_codigo
         join produtos t on i.ite_produto = t.pro_codprod and i.ite_industria = t.pro_industria and p.ped_tabela = t.pro_nometabela
         where p.ped_situacao in ('P','F') and
               p.ped_data between :pdt1 and :pdt2 and
               p.ped_industria   = :pind and
               t.pro_setor = 'T' and --lancamentos
               c.cli_redeloja = :vredeloja
         group by 1, 4
         order by 5, 1
       into  :item, :total, :totalqtd, :mesano,  :dia
      do
      suspend;
   end
 end

end^


ALTER PROCEDURE PROC_MAPAITENSCLIENTE (
    IDATA1 DATE,
    IDATA2 DATE,
    IFOR INTEGER,
    ICLI1 INTEGER)
RETURNS (
    ITEM VARCHAR(25),
    CLI_NOMRED VARCHAR(30),
    TOTALQTD DOUBLE PRECISION)
AS
declare variable ICLI2 integer;
begin
 icli2 = 9999; -- todos os clientes
 if (icli1 > 0) then
  icli2 = icli1;

 for
  select i.ite_produto,
        c.cli_nomred,
        sum(i.ite_quant)
  from itens_ped i
  join pedidos  p on i.ite_pedido  = p.ped_pedido and i.ite_industria = p.ped_industria
  join clientes c on p.ped_cliente = c.cli_codigo
  where p.ped_industria = :ifor and
       p.ped_situacao in ('P','F') and
       p.ped_data between :idata1 and :idata2 and
       p.ped_cliente between :icli1 and :icli2
  group by 1,2
  order by 2,1
  into :item, :cli_nomred, :totalqtd
  do
  suspend;
end^


ALTER PROCEDURE PROC_MAPAMETAVEND (
    PINICIO DATE,
    PFIM DATE)
RETURNS (
    OVENDEDOR VARCHAR(45),
    OINDUSTRIA VARCHAR(15),
    OMES INTEGER,
    OPREVISTO DOUBLE PRECISION,
    OREALIZADO DOUBLE PRECISION,
    OPERC DOUBLE PRECISION)
AS
begin
 for
    with tMetas as (
                    select p.ped_vendedor, sum(p.ped_totliq) liquido,
                    extract(month from p.ped_data) mes,
                    p.ped_industria
                    from pedidos p
                    where p.ped_data between :pinicio and :pfim and p.ped_situacao in ('P', 'F')
                    group by 1,3,4
                )
    
    
    select v.ven_nome, f.for_nomered Industria, t.mes mes, m.met_mesvalor previsto, t.liquido realizado,
           ((t.liquido * 100) / m.met_mesvalor) Perc
    from metas_vend   m
    join fornecedores f on m.met_industria = f.for_codigo
    join vendedores   v on m.met_vendedor  = v.ven_codigo
    join tMetas       t on m.met_vendedor  = t.ped_vendedor and m.met_mes = t.mes and m.met_industria = t.ped_industria
    order by met_industria, t.mes
    into :ovendedor, :oindustria, :omes, :oprevisto, :orealizado, :operc
  do
  suspend;
end^


ALTER PROCEDURE PROC_MAPAMOM (
    MES_REFERENCIA INTEGER,
    ANO_REFERENCIA INTEGER,
    IFOR INTEGER,
    IREDE BOOLEAN)
RETURNS (
    CLIENTE VARCHAR(30),
    VALOR_ANT DOUBLE PRECISION,
    QTD_ANT DOUBLE PRECISION,
    VALOR_ATU DOUBLE PRECISION,
    QTD_ATU DOUBLE PRECISION,
    PERC_VAL DOUBLE PRECISION,
    PERC_QTD DOUBLE PRECISION)
AS
begin
 if (irede = false) then
  begin
     for
        select
          cli_nomred,
          valor_mes_anterior,
          quantidade_mes_anterior,
          valor_mes_atual,
          quantidade_mes_atual
        from clientes c
        left join (
                  select
                    p.ped_cliente,
                    -- dados do m?s atual
                    sum(iif( (extract(month from p.ped_data) = :mes_referencia) and (extract(year from p.ped_data) = :ano_referencia),
                        i.ite_totliquido, 0 )) as valor_mes_atual,
                    
                    sum(iif( (extract(month from p.ped_data) = :mes_referencia) and (extract(year from p.ped_data) = :ano_referencia),
                        i.ite_quant, 0 )) as quantidade_mes_atual,
    
                    -- dados do mesmo m?s no ano anterior
                    sum(iif( (extract(month from p.ped_data) = :mes_referencia) and (extract(year from p.ped_data) = (:ano_referencia -1)),
                        i.ite_totliquido, 0)) as valor_mes_anterior,
                    
                    sum(iif( (extract(month from p.ped_data) = :mes_referencia) and (extract(year from p.ped_data) = (:ano_referencia -1)),
                        i.ite_quant, 0)) as quantidade_mes_anterior
    
                  from pedidos   p
                  join itens_ped i on i.ite_pedido = p.ped_pedido
                  where p.ped_industria = :iFor and
                        (extract(month from p.ped_data) = :mes_referencia and
                        p.ped_situacao in ('P', 'F') and
                        extract(year from p.ped_data) in (:ano_referencia, (:ano_referencia) - 1)) or
                        p.ped_data is null
                  group by p.ped_cliente
                  order by p.ped_cliente
                ) drv on c.cli_codigo = drv.ped_cliente
    
        where valor_mes_atual > 0 or valor_mes_anterior > 0
        order by valor_mes_atual desc
        into :cliente, :valor_ant, :qtd_ant, :valor_atu, :qtd_atu
     do
     begin
      -- percentual de crescimento em valor
       perc_val = 0;
       perc_qtd = 0;
       if (valor_ant = 0 and valor_atu > 0) then
         perc_val = 100;
       else
       perc_val = round(((valor_atu - valor_ant) / valor_ant) * 100, 2);
    
      -- percentual de crescimento em quantidade
       if (qtd_ant = 0 and qtd_atu > 0) then
        perc_qtd = 100;
       else
       perc_qtd = round(((qtd_atu - qtd_ant) / qtd_ant) * 100, 2);
    
      suspend;
     end
  end

 if (irede = true) then
  begin
     for
        select distinct
          c.cli_redeloja,
          valor_mes_anterior,
          quantidade_mes_anterior,
          valor_mes_atual,
          quantidade_mes_atual
        from clientes c
        left join (
                  select
                    cl.cli_redeloja,
                    -- dados do m?s atual
                    sum(iif( (extract(month from p.ped_data) = :mes_referencia) and (extract(year from p.ped_data) = :ano_referencia),
                        i.ite_totliquido, 0 )) as valor_mes_atual,
                    
                    sum(iif( (extract(month from p.ped_data) = :mes_referencia) and (extract(year from p.ped_data) = :ano_referencia),
                        i.ite_quant, 0 )) as quantidade_mes_atual,
    
                    -- dados do mesmo m?s no ano anterior
                    sum(iif( (extract(month from p.ped_data) = :mes_referencia) and (extract(year from p.ped_data) = (:ano_referencia -1)),
                        i.ite_totliquido, 0)) as valor_mes_anterior,
                    
                    sum(iif( (extract(month from p.ped_data) = :mes_referencia) and (extract(year from p.ped_data) = (:ano_referencia -1)),
                        i.ite_quant, 0)) as quantidade_mes_anterior
    
                  from pedidos   p
                  join itens_ped i on i.ite_pedido = p.ped_pedido
                  join clientes  cl on p.ped_cliente = cl.cli_codigo
                  where p.ped_industria = :iFor and
                        (extract(month from p.ped_data) = :mes_referencia and
                        p.ped_situacao in ('P', 'F') and
                        extract(year from p.ped_data) in (:ano_referencia, (:ano_referencia) - 1)) or
                        p.ped_data is null
                  group by 1
                  order by 1
                ) drv on c.cli_redeloja = drv.cli_redeloja
    
        where (valor_mes_atual > 0 or valor_mes_anterior > 0) and
              character_length(c.cli_redeloja)>0
        order by 1
        into :cliente, :valor_ant, :qtd_ant, :valor_atu, :qtd_atu
     do
     begin
      -- percentual de crescimento em valor
       perc_val = 0;
       perc_qtd = 0;
       if (valor_ant = 0 and valor_atu > 0) then
         perc_val = 100;
       else
       perc_val = round(((valor_atu - valor_ant) / valor_ant) * 100, 2);
    
      -- percentual de crescimento em quantidade
       if (qtd_ant = 0 and qtd_atu > 0) then
        perc_qtd = 100;
       else
       perc_qtd = round(((qtd_atu - qtd_ant) / qtd_ant) * 100, 2);
    
      suspend;
     end
 end

end^


ALTER PROCEDURE PROC_MAPAMOSTRASELLOUT (
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDE CHAR(1))
RETURNS (
    CLIENTE VARCHAR(35),
    MESANO VARCHAR(10),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION)
AS
begin
 delete from tab_temp where tmp_id > 0;

 if (:irede = 'N') then
  begin
      for
        select c.cli_nomred,
        cast(extract(year from so.so_mesext) ||'/'|| extract(month from so.so_mesext)||'/28' as date) MesAno,
        sum(so.so_venda_valor),
        sum(so.so_venda_qtd)
        from sellout so
        join clientes c on so.so_cliente = c.cli_codigo
        where so.so_mesext between :idata1 and :iData2 and
              so.so_industria = :iind
        group by 1,2
        order by 2,3
       into :cliente, :mesano, :total, :totalqtd
      do
      suspend;
  end
 if (:irede = 'S') then
  begin
      for
        select c.cli_redeloja,
        cast(extract(year from so.so_mesext) ||'/'|| extract(month from so.so_mesext)||'/28' as date) MesAno,
        sum(so.so_venda_valor),
        sum(so.so_venda_qtd)
        from sellout so
        join clientes c on so.so_cliente = c.cli_codigo
        where so.so_mesext between :idata1 and :iData2 and
              so.so_industria = :iind
        group by 1,2
        order by 2,3
       into :cliente, :mesano, :total, :totalqtd
      do
      suspend;
  end

end^


ALTER PROCEDURE PROC_MAPAPORGRUPO (
    IDT1 DATE,
    IDT2 DATE,
    IIND INTEGER,
    IVEND INTEGER)
RETURNS (
    ODESCGRUPO VARCHAR(50),
    OQUANT DOUBLE PRECISION,
    OMESANO VARCHAR(10))
AS
declare variable IVEND2 integer;
declare variable ICODPROD varchar(25);
declare variable IGRUPOPRO varchar(50);
begin
 ivend2 = ivend;
 if (ivend = 0) then
  begin
   ivend = 1;
   ivend2 = 999;
  end

 delete from tab_temp where character_length(tmp_conversao) > 0;

 for
   select x.pro_codprod,
          gr.gru_nome
   from produtos x
   left join grupos gr on x.pro_grupopro = gr.gru_codigo
   where x.pro_industria = :iind
   group by 1, 2
   into :icodprod, :igrupopro
 do
 begin
  insert into tab_temp (tmp_conversao, tmp_descricao) values (:icodprod, :igrupopro);
 end

 for
    select pr.tmp_descricao,
           coalesce(sum(i.ite_quant), 0) totalqtd,
           cast( extract( year from p.ped_data) ||'/'|| extract( month from p.ped_data) ||'/'||'28' as date) mesano
     from itens_ped i 
     join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
     join tab_temp pr on i.ite_produto = pr.tmp_conversao
     where p.ped_situacao in ('P','F') and
           p.ped_data between :idt1 and :idt2 and
           p.ped_industria   = :iind and
           p.ped_cliente between :ivend and :ivend2
     group by 1,3
     order by 1
     into :odescgrupo, :oquant, :omesano
  do
  suspend;
end^


ALTER PROCEDURE PROC_MERGECADPRO
AS
begin
merge into cad_prod cp
using ( select
        p.pro_industria,
        p.pro_codprod,
        max(p.pro_codoriginal) pro_codoriginal,
        max(p.pro_nome) pro_nome,
        max(p.pro_codbarras) pro_codbarras,
        max(p.pro_grupo) pro_grupo,
        max(p.pro_setor) pro_setor,
        max(p.pro_embalagem) pro_embalagem,
        max(p.ite_peso) ite_peso,
        max(p.ite_conversao) ite_conversao,
        max(p.pro_ncm) pro_ncm,
        max(p.pro_aplicacao) pro_aplicacao,
        max(p.pro_aplicacao2) pro_aplicacao2,
        max(p.pro_linha) pro_linha,
        max(p.pro_linhaleve) pro_linhaleve,
        max(p.pro_linhapesada) pro_linhapesada,
        max(p.pro_linhaagricola) pro_linhaagricola,
        max(p.pro_linhautilitarios) pro_linhautilitarios
        from produtos p
        group by p.pro_codprod, p.pro_industria
        order by p.pro_codprod, p.pro_industria) us

on cp.pro_industria = us.pro_industria and cp.pro_codprod = us.pro_codprod
when not matched then
insert (pro_industria, pro_codprod, pro_codigooriginal,
        pro_nome, pro_codbarras,
        pro_grupo, pro_setor, pro_embalagem, pro_peso,
        pro_conversao, pro_ncm, pro_aplicacao, pro_aplicacao2, pro_linha,
        pro_linhaleve, pro_linhapesada, pro_linhaagricola,
        pro_linhautilitarios, pro_codigonormalizado)
values (us.pro_industria, us.pro_codprod, us.pro_codoriginal, us.pro_nome,
        us.pro_codbarras, us.pro_grupo, us.pro_setor, us.pro_embalagem,
        us.ite_peso, us.ite_conversao, us.pro_ncm, us.pro_aplicacao,
        us.pro_aplicacao2, us.pro_linha, us.pro_linhaleve, us.pro_linhapesada,
        us.pro_linhaagricola, us.pro_linhautilitarios, fn_normalizar_codigo(us.pro_codprod));
end^


ALTER PROCEDURE PROC_MERGEPEDIDOS (
    INUMERO INTEGER,
    IPEDIDO VARCHAR(10),
    IDATA DATE,
    IFOR INTEGER,
    ICLI INTEGER,
    ITRANSP INTEGER,
    IVENDEDOR INTEGER,
    ICLIIND VARCHAR(15),
    IDATAFAT DATE,
    INFFAT VARCHAR(15),
    IPRI DOUBLE PRECISION,
    ISEG DOUBLE PRECISION,
    ITER DOUBLE PRECISION,
    IQUA DOUBLE PRECISION,
    IQUI DOUBLE PRECISION,
    ISEX DOUBLE PRECISION,
    ISET DOUBLE PRECISION,
    IOIT DOUBLE PRECISION,
    INOV DOUBLE PRECISION,
    IDEZ DOUBLE PRECISION,
    IDESCADD DOUBLE PRECISION,
    ICONDPAG VARCHAR(100),
    IOBS VARCHAR(600),
    ISITU VARCHAR(1),
    ITOTLIQ DOUBLE PRECISION,
    ITOTBRU DOUBLE PRECISION,
    IENVIADO VARCHAR(1),
    IDTENVIO DATE,
    IACRESC DOUBLE PRECISION,
    IEXPORTADO VARCHAR(1),
    ICOEF DOUBLE PRECISION,
    IOBSFORA VARCHAR(600),
    ITIPOFRETE VARCHAR(1),
    ITOTALIPI DOUBLE PRECISION,
    ICOMPRADOR VARCHAR(30),
    IEMAILCOMP VARCHAR(60),
    ITABELA VARCHAR(20),
    ICRUD CHAR(1))
AS
begin
 if (icrud = 'I') then
  begin
   in autonomous transaction do
    begin
       insert into pedidos
       (ped_numero, ped_data, ped_pedido, ped_industria, ped_cliente, ped_transp, ped_vendedor, ped_cliind, ped_datafat, ped_nffat,
        ped_pri, ped_seg, ped_ter, ped_qua, ped_qui, ped_sex, ped_set, ped_oit, ped_nov, ped_dez, ped_descadic, ped_condpag,
        ped_obs, ped_situacao, ped_totliq, ped_totbruto, ped_enviado, ped_dataenvio, ped_acrescimo, ped_exportado, ped_coeficiente,
        ped_obsfora, ped_tipofrete, ped_totalipi, ped_comprador, ped_emailcomp, ped_tabela)
       values
       (:inumero, :idata, :ipedido, :ifor, :icli, :itransp, :ivendedor, :icliind,
        :idatafat, :inffat, :ipri, :iseg, :iter, :iqua, :iqui, :isex, :iset, :ioit,
        :inov, :idez, :idescadd, :icondpag, :iobs, :isitu, :itotliq, :itotbru, :ienviado,
        :idtenvio, :iacresc, :iexportado, :icoef, :iobsfora, :itipofrete, :itotalipi,
        :icomprador, :iemailcomp, :itabela);
    end
  end

 if (icrud = 'U') then -- update
  begin
   in autonomous transaction do
    begin
       update pedidos set
       ped_numero = :inumero, ped_data = :idata, ped_pedido = :ipedido, ped_industria = :ifor, ped_cliente = :icli, ped_transp = :itransp,
       ped_vendedor = :ivendedor, ped_cliind = :icliind, ped_datafat = :idatafat, ped_nffat = :inffat,
       ped_pri = :ipri, ped_seg = :iseg, ped_ter = :iter, ped_qua = :iqua, ped_qui = :iqui, ped_sex = :isex, ped_set = :iset, ped_oit = :ioit,
       ped_nov = :inov, ped_dez = :idez, ped_descadic = :idescadd, ped_condpag = :icondpag,
       ped_obs = :iobs, ped_situacao = :isitu, ped_totliq = :itotliq, ped_totbruto = :itotbru, ped_enviado = :ienviado, ped_dataenvio = :idtenvio,
       ped_acrescimo = :iacresc, ped_exportado = :iexportado, ped_coeficiente = :icoef,
       ped_obsfora = :iobsfora, ped_tipofrete = :itipofrete, ped_totalipi = :itotalipi, ped_comprador = :icomprador, ped_emailcomp = :iemailcomp,
       ped_tabela = :itabela
       where ped_pedido = :ipedido and ped_industria = :ifor;
    end
  end
end^


ALTER PROCEDURE PROC_METAINDPREV (
    IANO INTEGER,
    IFOR INTEGER)
RETURNS (
    INDUSTRIA VARCHAR(30),
    FLAG VARCHAR(12),
    JAN DOUBLE PRECISION,
    FEV DOUBLE PRECISION,
    MAR DOUBLE PRECISION,
    ABR DOUBLE PRECISION,
    MAI DOUBLE PRECISION,
    JUN DOUBLE PRECISION,
    JUL DOUBLE PRECISION,
    AGO DOUBLE PRECISION,
    STB DOUBLE PRECISION,
    OUT DOUBLE PRECISION,
    NOV DOUBLE PRECISION,
    DEZ DOUBLE PRECISION)
AS
begin
 jan = 0;
 fev = 0;
 mar = 0;
 abr = 0;
 mai = 0;
 jun = 0;
 jul = 0;
 ago = 0;
 stb = 0;
 out = 0;
 nov = 0;
 dez = 0;
 flag =  'PREVISTO';

 for
    select f.for_nomered, 'PREVISTO', i.met_jan, i.met_fev, i.met_mar, i.met_abr, i.met_mai,
           i.met_jun, i.met_jul, i.met_ago, i.met_set, i.met_out, i.met_nov, i.met_dez
    from ind_metas i
    join fornecedores f on i.met_industria = f.for_codigo
    where i.met_ano = :iano and i.met_industria = :ifor
    into :industria, :flag, :jan, :fev, :mar, :abr, :mai, :jun, :jul, :ago, :stb, :out, :nov, :dez
  do
  suspend;
end^


ALTER PROCEDURE PROC_METAINDREALIZ (
    IANO INTEGER,
    IFOR INTEGER)
RETURNS (
    INDUSTRIA VARCHAR(30),
    FLAG VARCHAR(12),
    JAN DOUBLE PRECISION,
    FEV DOUBLE PRECISION,
    MAR DOUBLE PRECISION,
    ABR DOUBLE PRECISION,
    MAI DOUBLE PRECISION,
    JUN DOUBLE PRECISION,
    JUL DOUBLE PRECISION,
    AGO DOUBLE PRECISION,
    STB DOUBLE PRECISION,
    OUT DOUBLE PRECISION,
    NOV DOUBLE PRECISION,
    DEZ DOUBLE PRECISION)
AS
declare variable VMES integer;
declare variable VVALOR double precision;
begin
 jan = 0;
 fev = 0;
 mar = 0;
 abr = 0;
 mai = 0;
 jun = 0;
 jul = 0;
 ago = 0;
 stb = 0;
 out = 0;
 nov = 0;
 dez = 0;
 flag =  'REALIZADO';

 for
    with jan as (select p.ped_industria,
                 extract(month from p.ped_data) mes,
                 coalesce(sum(p.ped_totliq), 0) valor
                 from pedidos p
                 where p.ped_situacao in ('P','F') and
                       extract(year from p.ped_data) = :iano and
                       p.ped_industria = :ifor
                 group by 1,2)
    
    
    select f.for_nomered, j1.mes, coalesce(j1.valor, 0)
    from fornecedores f
    join jan j1 on f.for_codigo = j1.ped_industria
    into :industria, :vmes, :vvalor
  do
  begin
   if (vmes = 1) then jan = vvalor;
   if (vmes = 2) then fev = vvalor;
   if (vmes = 3) then mar = vvalor;
   if (vmes = 4) then abr = vvalor;
   if (vmes = 5) then mai = vvalor;
   if (vmes = 6) then jun = vvalor;
   if (vmes = 7) then jul = vvalor;
   if (vmes = 8) then ago = vvalor;
   if (vmes = 9) then stb = vvalor;
   if (vmes = 10) then out = vvalor;
   if (vmes = 11) then nov = vvalor;
   if (vmes = 12) then dez = vvalor;
  end
  suspend;
end^


ALTER PROCEDURE PROC_METAINDRESULT (
    IANO INTEGER,
    IFOR INTEGER)
RETURNS (
    INDUSTRIA VARCHAR(30),
    FLAG VARCHAR(12),
    JANX DOUBLE PRECISION,
    FEVX DOUBLE PRECISION,
    MARX DOUBLE PRECISION,
    ABRX DOUBLE PRECISION,
    MAIX DOUBLE PRECISION,
    JUNX DOUBLE PRECISION,
    JULX DOUBLE PRECISION,
    AGOX DOUBLE PRECISION,
    STBX DOUBLE PRECISION,
    OUTX DOUBLE PRECISION,
    NOVX DOUBLE PRECISION,
    DEZX DOUBLE PRECISION)
AS
declare variable JANP double precision;
declare variable FEVP double precision;
declare variable MARP double precision;
declare variable ABRP double precision;
declare variable MAIP double precision;
declare variable JUNP double precision;
declare variable JULP double precision;
declare variable AGOP double precision;
declare variable STBP double precision;
declare variable OUTP double precision;
declare variable NOVP double precision;
declare variable DEZP double precision;
declare variable JANR double precision;
declare variable FEVR double precision;
declare variable MARR double precision;
declare variable ABRR double precision;
declare variable MAIR double precision;
declare variable JUNR double precision;
declare variable JULR double precision;
declare variable AGOR double precision;
declare variable STBR double precision;
declare variable OUTR double precision;
declare variable NOVR double precision;
declare variable DEZR double precision;
begin
 janx = 0;
 fevx = 0;
 marx = 0;
 abrx = 0;
 maix = 0;
 junx = 0;
 julx = 0;
 agox = 0;
 stbx = 0;
 outx = 0;
 novx = 0;
 dezx = 0;
 --
 janp = 0;
 fevp = 0;
 marp = 0;
 abrp = 0;
 maip = 0;
 junp = 0;
 julp = 0;
 agop = 0;
 stbp = 0;
 outp = 0;
 novp = 0;
 dezp = 0;
 --
 janr = 0;
 fevr = 0;
 marr = 0;
 abrr = 0;
 mair = 0;
 junr = 0;
 julr = 0;
 agor = 0;
 stbr = 0;
 outr = 0;
 novr = 0;
 dezr = 0;
 --busca o previsto
 select jan, fev, mar, abr, mai, jun, jul, ago, stb, out, nov, coalesce(dez, 0)
 from proc_metaindprev(:iano, :ifor)
 into :janp, :fevp, :marp, :abrp, :maip, :junp, :julp, :agop, :stbp, :outp, :novp, :dezp;
 --busca o realizado
 select jan, fev, mar, abr, mai, jun, jul, ago, stb, out, nov, coalesce(dez, 0)
 from proc_metaindrealiz(:iano, :ifor)
 into :janr, :fevr, :marr, :abrr, :mair, :junr, :julr, :agor, :stbr, :outr, :novr, :dezr;

 --calcula o resultado
 for
    select f.for_nomered, 'RESULTADO', i.met_jan, i.met_fev, i.met_mar, i.met_abr, i.met_mai,
           i.met_jun, i.met_jul, i.met_ago, i.met_set, i.met_out, i.met_nov, i.met_dez
    from ind_metas i
    join fornecedores f on i.met_industria = f.for_codigo
    where i.met_ano = :iano and i.met_industria = :ifor
    into :industria, :flag, :janx, :fevx, :marx, :abrx, :maix, :junx, :julx, :agox, :stbx, :outx, :novx, :dezx
  do
  begin
    janx = coalesce(((janr * 100) / janp), 0);
    fevx = coalesce(((fevr * 100) / fevp), 0);
    marx = coalesce(((marr * 100) / marp), 0);
    abrx = coalesce(((abrr * 100) / abrp), 0);
    maix = coalesce(((mair * 100) / maip), 0);
    junx = coalesce(((junr * 100) / junp), 0);
    julx = coalesce(((julr * 100) / julp), 0);
    agox = coalesce(((agor * 100) / agop), 0);
    stbx = coalesce(((stbr * 100) / stbp), 0);
    outx = coalesce(((outr * 100) / outp), 0);
    novx = coalesce(((novr * 100) / novp), 0);
    dezx = coalesce(((dezr * 100) / dezp), 0);
  end
  suspend;
end^


ALTER PROCEDURE PROC_METASCLI (
    ICLI INTEGER)
RETURNS (
    MET_INDUSTRIA INTEGER,
    MET_CLIENTE INTEGER,
    MET_VALOR DOUBLE PRECISION,
    MET_DATA DATE,
    MET_MESANO VARCHAR(8),
    FOR_NOMERED VARCHAR(15))
AS
begin
 for
    select m.met_industria, m.met_cliente, m.met_mesano, m.met_valor, m.met_data, f.for_nomered
    from metascli m
    join fornecedores f on m.met_industria = f.for_codigo
    where m.met_cliente = :icli
    order by m.met_data desc
    into :met_industria, :met_cliente, :met_mesano, :met_valor, :met_data, :for_nomered
 do
 suspend;
end^


ALTER PROCEDURE PROC_METASIND (
    IFOR INTEGER)
RETURNS (
    MET_INDUSTRIA INTEGER,
    MET_VALOR DOUBLE PRECISION,
    MET_DATA DATE,
    MET_MESANO VARCHAR(8),
    MET_METATELEMKT INTEGER,
    TOTAL DOUBLE PRECISION,
    PERCENTUAL DOUBLE PRECISION)
AS
begin
 for
    select m.met_industria, m.met_valor, m.met_data, m.met_mesano, m.met_metatelemkt,
    (select sum(p.ped_totliq) from pedidos p 
     where p.ped_industria = :ifor
     and p.ped_situacao in ('P','F')
     and extract(month from p.ped_data) = extract(month from m.met_data)
     and extract(year from p.ped_data) = extract(year from m.met_data) ) Total,
    
    (select Cast(((sum(p.ped_totliq) * 100) / m.met_valor) as Numeric(5,2)) from pedidos p 
     where p.ped_industria = :ifor
     and p.ped_situacao in ('P','F')
     and extract(month from p.ped_data) = extract(month from m.met_data)
     and extract(year from p.ped_data) = extract(year from m.met_data) ) Percentual
    
    from metasind m
    where m.met_industria = :ifor
    order by m.met_data desc
    into :met_industria, :met_valor, :met_data, :met_mesano, :met_metatelemkt, :total, :percentual
 do
 suspend;
end^


ALTER PROCEDURE PROC_METASMES (
    IFOR INTEGER,
    IMES VARCHAR(8),
    DT1 DATE,
    DT2 DATE)
RETURNS (
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    TOTPEDIDOS DOUBLE PRECISION,
    TOTFATURADOS DOUBLE PRECISION,
    PERCENTUAL DOUBLE PRECISION,
    META DOUBLE PRECISION,
    TOTALQTD INTEGER)
AS
begin
 for
  with iteped as
              (select
               p1.ped_pedido,
               sum(ip.ite_quant) quant
               from itens_ped ip
               join pedidos p1 on ip.ite_pedido = p1.ped_pedido and ip.ite_industria = p1.ped_industria
               where p1.ped_data between :dt1 and :dt2 and
                     p1.ped_industria = :ifor and
                     p1.ped_situacao in('P','F')
               group by 1
               )

    select f.for_nomered,
           c.cli_nomred,
           sum(p.ped_totliq),
           sum(coalesce(fp.fat_valorfat, 0)),
           coalesce((sum(p.ped_totliq) * 100) / max(m.met_valor),0),
           max(coalesce(m.met_valor,0)),
           max(i.quant)
    from pedidos p
    join iteped          i on p.ped_pedido = i.ped_pedido
    join fornecedores    f on p.ped_industria = f.for_codigo
    join clientes        c on p.ped_cliente = c.cli_codigo
    left join metascli   m on m.met_industria = f.for_codigo and m.met_mesano = :iMes and m.met_cliente = p.ped_cliente
    left join fatura_ped fp on p.ped_pedido = fp.fat_pedido
    where p.ped_situacao in('P','F') and
          p.ped_data between :dt1 and :dt2 and
          p.ped_industria = :ifor
    group by 1,2
    order by 1
    into :for_nomered, :cli_nomred, :totpedidos, :totfaturados, :percentual, :meta, :totalqtd
  do
  suspend;
end^


ALTER PROCEDURE PROC_METASMESOLD (
    IMES VARCHAR(8),
    DT1 DATE,
    DT2 DATE)
RETURNS (
    FOR_NOMERED VARCHAR(15),
    TOTPEDIDOS DOUBLE PRECISION,
    TOTFATURADOS DOUBLE PRECISION,
    PERCENTUAL DOUBLE PRECISION,
    META DOUBLE PRECISION)
AS
begin
 for
    select f.for_nomered,
           sum(p.ped_totliq),
           sum(coalesce(fp.fat_valorfat, 0)),
           (sum(p.ped_totliq) * 100) / max(m.met_valor),
           max(m.met_valor)
    from pedidos p
    join fornecedores    f on p.ped_industria = f.for_codigo
    join metasind        m on m.met_industria = f.for_codigo and m.met_mesano = :iMes
    left join fatura_ped fp on p.ped_pedido = fp.fat_pedido
    where p.ped_situacao in('P','F') and p.ped_data between :dt1 and :dt2
    group by 1
    order by 1
    into :for_nomered, :totpedidos, :totfaturados, :percentual, :meta
  do
  suspend;
end^


ALTER PROCEDURE PROC_METASVENDEDOR (
    IVENDEDOR INTEGER,
    IANO INTEGER)
RETURNS (
    MET_ANO INTEGER,
    MET_MES INTEGER,
    MET_VENDEDOR INTEGER,
    MET_INDUSTRIA INTEGER,
    MET_MESVALOR DOUBLE PRECISION,
    FOR_NOMERED VARCHAR(15))
AS
begin
  for
    select m.met_ano, m.met_mes, m.met_vendedor, m.met_industria, m.met_mesvalor, f.for_nomered
    from metas_vend m
    join fornecedores f on m.met_industria = f.for_codigo
    where m.met_vendedor = :ivendedor and met_ano = :iano
    order by met_mes
    into :met_ano, :met_mes, :met_vendedor, :met_industria, :met_mesvalor, :for_nomered
  do
  suspend;
end^


ALTER PROCEDURE PROC_MOSTRACAIXA (
    DATAINI DATE,
    DATAFIM DATE)
RETURNS (
    DATALANC DATE,
    SALDOANT NUMERIC(9,2),
    CREDITO NUMERIC(9,2),
    DEBITO NUMERIC(9,2),
    SALDOATU NUMERIC(9,2),
    TIPO VARCHAR(1),
    VALOR_DC NUMERIC(9,2),
    CAIID INTEGER)
AS
begin
 saldoatu = 0;

 select Coalesce(sum(x.cai_valor * decode(x.cai_dc,'C',1,-1)),0) as xSaldo
 from caixa x
 where x.cai_data < :dataini
 into :saldoatu;

 saldoatu = Coalesce(saldoatu,0);

 for select x1.cai_lancamento, x1.cai_data, x1.cai_dc, x1.cai_valor
 from caixa x1
 where x1.cai_data between :dataini and :datafim
 order by 1
 into :caiid, :datalanc, :tipo, :valor_dc

 do
  begin
     if (tipo = 'C' ) then
      begin
        credito = valor_dc;
        debito  = 0;
      end
      else
      begin
        credito = 0;
        debito  = valor_dc;
      end
      saldoant = saldoatu;
      saldoatu = saldoant + credito - debito;
      suspend;
  end
end^


ALTER PROCEDURE PROC_MOSTRACRM (
    ICLIENTE INTEGER)
RETURNS (
    TELE_ID INTEGER,
    TELE_CLIENTE INTEGER,
    CLI_NOMRED VARCHAR(30),
    DATA DATE)
AS
declare variable ICLIENTE2 integer;
begin

 if (icliente = 0) then
  begin
  icliente  = 1;
  icliente2 = 9999;
  end
  else
  icliente2 = icliente;

 for
   select distinct
    t.tele_id,
    t.tele_cliente,
    c.cli_nomred,
    max(a.age_data) over(partition by a.age_cliente) dia
    from crm t
    join clientes c on t.tele_cliente  = c.cli_codigo
    left join crm_interacoes a on t.tele_cliente = a.age_cliente
    where t.tele_cliente >= :icliente and
          t.tele_cliente <= :icliente2
    order by 4 desc
    into :tele_id, :tele_cliente, :cli_nomred, :data
 do
 suspend;
end^


ALTER PROCEDURE PROC_MOSTRAPED (
    PIND INTEGER,
    PCLI INTEGER,
    PVEND INTEGER,
    PSITU CHAR(1))
RETURNS (
    PEDIDO VARCHAR(10),
    DATA DATE,
    CLIENTE VARCHAR(30),
    SITUACAO VARCHAR(1),
    CONDICOES VARCHAR(100),
    ENVIO DATE,
    BRUTO DOUBLE PRECISION,
    LIQUIDO DOUBLE PRECISION,
    COMIPI DOUBLE PRECISION,
    INDUSTRIA INTEGER,
    CLIID INTEGER,
    TRANSPID INTEGER,
    RAZAO VARCHAR(75),
    FATURADO DOUBLE PRECISION,
    TABELA VARCHAR(20),
    VENDEDOR INTEGER,
    INDRED VARCHAR(15))
AS
declare variable VIND1 integer;
declare variable VIND2 integer;
declare variable VCLI1 integer;
declare variable VCLI2 integer;
declare variable VVEND1 integer;
declare variable VVEND2 integer;
begin

 vind1 = pind;
 vind2 = pind;
 vcli1 = pcli;
 vcli2 = pcli;
 vvend1 = pvend;
 vvend2 = pvend;

 if (pind = 0) then
  begin
   vind1 = 1;
   vind2 = 9999;
  end
 if (pcli = 0) then
  begin
   vcli1 = 1;
   vcli2 = 9999;
  end
 if (pvend = 0) then
  begin
   vvend1 = 1;
   vvend2 = 999;
  end

  if (pSitu <> 'Z') then
    begin
     for
      select first 800 ped_pedido, ped_data, cli_nomred, ped_situacao, ped_condpag, ped_dataenvio,
      ped_totbruto, ped_totliq, ped_totalipi, ped_industria, ped_cliente, ped_transp, cli_nome,
      sum(coalesce(fat_valorfat, 0)) over(partition by fp.fat_pedido, fp.fat_industria),
      ped_tabela, ped_vendedor, for_nomered
      from pedidos p
      join clientes c on p.ped_cliente   = c.cli_codigo
      join fornecedores f on p.ped_industria = f.for_codigo
      left join fatura_ped fp on p.ped_pedido = fp.fat_pedido and p.ped_industria = fp.fat_industria
      where coalesce(p.ped_industria, 0) between :vind1 and :vind2 and
            coalesce(p.ped_cliente, 0)   between :vcli1 and :vcli2 and
            coalesce(p.ped_vendedor, 0)  between :vvend1 and :vvend2 and
            p.ped_situacao = :psitu
      order by p.ped_data desc, p.ped_industria
      into :pedido, :data, :cliente, :situacao, :condicoes, :envio, :bruto, :liquido, :comipi, :industria,
           :cliid, :transpid, :razao, :faturado, :tabela, :vendedor, :indred
     do
     suspend;
   end

  if (pSitu = 'Z') then
    begin
     for
      select first 800 ped_pedido, ped_data, cli_nomred, ped_situacao, ped_condpag, ped_dataenvio,
      ped_totbruto, ped_totliq, ped_totalipi, ped_industria, ped_cliente, ped_transp, cli_nome,
      sum(coalesce(fat_valorfat, 0)) over(partition by fp.fat_pedido, fp.fat_industria),
      ped_tabela, ped_vendedor, for_nomered
      from pedidos p
      join clientes c on p.ped_cliente   = c.cli_codigo
      join fornecedores f on p.ped_industria = f.for_codigo
      left join fatura_ped fp on p.ped_pedido = fp.fat_pedido and p.ped_industria = fp.fat_industria
      where coalesce(p.ped_industria, 0) between :vind1 and :vind2 and
            coalesce(p.ped_cliente, 0)   between :vcli1 and :vcli2 and
            coalesce(p.ped_vendedor, 0)  between :vvend1 and :vvend2 and
            p.ped_situacao <> 'E'
      order by p.ped_data desc, p.ped_industria
      into :pedido, :data, :cliente, :situacao, :condicoes, :envio, :bruto, :liquido, :comipi, :industria,
           :cliid, :transpid, :razao, :faturado, :tabela, :vendedor, :indred
     do
     suspend;
   end
end^


ALTER PROCEDURE PROC_MOSTRAPEDINDEX (
    PIND INTEGER,
    PCLI INTEGER,
    PVEND INTEGER,
    PSITU CHAR(1))
RETURNS (
    PEDIDO VARCHAR(10),
    DATA DATE,
    CLIENTE VARCHAR(30),
    SITUACAO VARCHAR(1),
    CONDICOES VARCHAR(100),
    ENVIO DATE,
    BRUTO DOUBLE PRECISION,
    LIQUIDO DOUBLE PRECISION,
    COMIPI DOUBLE PRECISION,
    INDUSTRIA INTEGER,
    CLIID INTEGER,
    TRANSPID INTEGER,
    RAZAO VARCHAR(75),
    FATURADO DOUBLE PRECISION,
    TABELA VARCHAR(25),
    VENDEDOR INTEGER,
    INDRED VARCHAR(15),
    NUMPEDCLI VARCHAR(15),
    NUMPEDIND VARCHAR(15))
AS
declare variable PIND2 integer;
declare variable PCLI2 integer;
declare variable PVEND2 integer;
begin

 pind2  = pind;
 pcli2  = pcli;
 pvend2 = pvend;

 if (pind = 0) then
  begin
   pind  = 1;
   pind2 = 9999;
  end
 if (pcli = 0) then
  begin
   pcli  = 1;
   pcli2 = 9999;
  end
 if (pvend = 0) then
  begin
   pvend  = 0;
   pvend2 = 999;
  end

 if (psitu = 'Z') then
  begin
    for
      select  first 700 distinct
             ped_pedido, ped_data, cli_nomred, ped_situacao, ped_condpag, ped_dataenvio,
             ped_totbruto, ped_totliq, ped_totalipi,
             ped_industria, ped_cliente, ped_transp, cli_nome,
             ped_tabela, ped_vendedor, for_nomered,
             sum(fp.fat_valorfat) over(partition by p.ped_pedido),
             p.ped_cliind, p.ped_nffat
      from pedidos p
      join fornecedores f     on p.ped_industria = f.for_codigo
      left join clientes c    on p.ped_cliente   = c.cli_codigo
      left join fatura_ped fp on p.ped_pedido    = fp.fat_pedido
      where p.ped_industria between :pind  and :pind2 and
            p.ped_vendedor  between :pvend and :pvend2 and
            p.ped_cliente   between :pcli  and :pcli2  and
            p.ped_situacao  <> 'E'
      order by p.ped_data desc,  p.ped_numero desc
      into :pedido, :data, :cliente, :situacao, :condicoes, :envio, :bruto, :liquido, :comipi,
           :industria, :cliid, :transpid, :razao, :tabela, :vendedor, :indred, :faturado, :numpedcli,
           :numpedind
      do
      suspend;
 end
 else -- leva em conta a situacao
  begin
    for
      select distinct
             ped_pedido, ped_data, cli_nomred, ped_situacao, ped_condpag, ped_dataenvio,
             ped_totbruto, ped_totliq, ped_totalipi,
             ped_industria, ped_cliente, ped_transp, cli_nome,
             ped_tabela, ped_vendedor, for_nomered,
             sum(fp.fat_valorfat) over(partition by p.ped_pedido),
             p.ped_cliind, p.ped_nffat
      from pedidos p
      join fornecedores f     on p.ped_industria = f.for_codigo
      left join clientes c    on p.ped_cliente   = c.cli_codigo
      left join fatura_ped fp on p.ped_pedido    = fp.fat_pedido
      where p.ped_industria between :pind  and :pind2 and
            p.ped_vendedor  between :pvend and :pvend2 and
            p.ped_cliente   between :pcli  and :pcli2 and
            p.ped_situacao  = :psitu
      order by p.ped_data desc,  p.ped_numero desc
      into :pedido, :data, :cliente, :situacao, :condicoes, :envio, :bruto, :liquido, :comipi,
           :industria, :cliid, :transpid, :razao, :tabela, :vendedor, :indred, :faturado, :numpedcli,
           :numpedind
      do
      suspend;
  end
end^


ALTER PROCEDURE PROC_MOSTRAPGREC (
    IFAV INTEGER,
    IROT CHAR(1),
    ISIT CHAR(1),
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    ID INTEGER,
    DOCTO VARCHAR(15),
    DTLANCTO DATE,
    CREDEB CHAR(1),
    CONTA INTEGER,
    VALOR NUMERIC(15,2),
    VENCTO DATE,
    VALORPAGO NUMERIC(15,2),
    DATAPGTO DATE,
    CLIFOR_ID INTEGER,
    CLIFOR VARCHAR(60),
    DESCCONTA VARCHAR(50))
AS
declare variable IFAV2 integer;
begin
  ifav2 = ifav;
  if (ifav = 0) then
   begin
    ifav  = 1;
    ifav2 = 9999;
   end
  if (isit = 'A') then -- em aberto
  begin
   for
      select c.lan_lancto, c.lan_docto, c.lan_data, c.lan_credeb, c.lan_conta, c.lan_valor, c.lan_vencimento,
             c.lan_valorpago, c.lan_datapago, c.lan_clifor, c.lan_clifornome, t.cc_descricao
      from contaspgrec c
      left join ccustos t on c.lan_conta = t.cc_id
      where c.lan_valorpago = 0 and c.lan_vencimento between :idata1 and :idata2 and
            c.lan_credeb = :irot and c.lan_clifor between :ifav and :ifav2
      order by lan_vencimento
      into :id, :docto, :dtlancto, :credeb, :conta, :valor, :vencto, :valorpago, :datapgto, :clifor_id, :clifor, :descconta
   do
   suspend;
  end
  if (isit = 'Q') then -- quitados
  begin
   for
      select c.lan_lancto, c.lan_docto, c.lan_data, c.lan_credeb, c.lan_conta, c.lan_valor, c.lan_vencimento,
             c.lan_valorpago, c.lan_datapago, c.lan_clifor, c.lan_clifornome, t.cc_descricao
      from contaspgrec c
      left join ccustos t on c.lan_conta = t.cc_id
      where c.lan_valorpago > 0 and c.lan_datapago between :idata1 and :idata2 and
            c.lan_credeb = :irot and c.lan_clifor between :ifav and :ifav2
      order by lan_datapago
      into :id, :docto, :dtlancto, :credeb, :conta, :valor, :vencto, :valorpago, :datapgto, :clifor_id, :clifor, :descconta
   do
   suspend;
  end
end^


ALTER PROCEDURE PROC_MOSTRAPROD (
    IINDUSTRIA INTEGER,
    ITABELA VARCHAR(20),
    IGRUPO INTEGER,
    IPESQUISA VARCHAR(100))
RETURNS (
    ID INTEGER,
    CODIND INTEGER,
    CODIGO VARCHAR(25),
    CONVERSAO VARCHAR(300),
    NOME VARCHAR(100),
    PRECO1 DOUBLE PRECISION,
    PRECO2 DOUBLE PRECISION,
    PRECO3 DOUBLE PRECISION,
    LIQUIDO DOUBLE PRECISION,
    DATATAB DATE,
    EMBALAGEM INTEGER,
    DATAPROMO DATE,
    IPI NUMERIC(9,2),
    CODIGO2 VARCHAR(25),
    ST DOUBLE PRECISION,
    NOMETABELA VARCHAR(20),
    GRUPOPRO INTEGER,
    DESCADIC2 DOUBLE PRECISION,
    PESO DOUBLE PRECISION,
    PREPESO DOUBLE PRECISION,
    STATUS VARCHAR(20))
AS
declare variable VGRUPO2 integer;
begin

 if (igrupo = 0) then
 begin
   igrupo  = 0;
   vgrupo2 = 999;
 end
 if (igrupo > 0) then
   vgrupo2 = igrupo;

 if (char_length(ipesquisa) = 0 and iindustria < 9999) then
 begin
 for
   select first 700 pro_codigo, pro_industria, pro_codprod, ite_conversao, pro_nome, pro_valornormal, pro_valorpromo, pro_preco3,
    (select * from sp_calliqprod (pro_valornormal, gru_desc1,gru_desc2,gru_desc3,gru_desc4,gru_desc5,gru_desc6,gru_desc7,gru_desc8,gru_desc9)) pre_liq,
    pro_datatabela, pro_embalagem, pro_vencpromocao, pro_ipi, ite_codigo2, pro_st, pro_nometabela,
    pro_grupopro,  pro_descadic2, ite_peso, ite_prepeso,
    case p.pro_setor
    when 'L' then 'Linha leve'
    when 'P' then 'Linha pesada'
    when 'A' then 'Linha agricola'
    when 'U' then 'Utilitarios'
    when 'I' then 'Utilitarios'
    when 'T' then 'Lancamento'
    end as setor
    from produtos p
    left join grupo_desc g on p.pro_grupo = g.gru_codigo
    where pro_industria = :iindustria and pro_nometabela = :itabela and coalesce(pro_grupopro, 0) between :igrupo and :vgrupo2
    order by pro_codprod
    into
    :id, :codind, :codigo, :conversao, :nome, :preco1, :preco2, :preco3, :liquido, :datatab, :embalagem, :datapromo, :ipi,
    :codigo2, :st, :nometabela, :grupopro, :descadic2, :peso, :prepeso, :status
  do
  suspend;
 end
 if (char_length(ipesquisa) > 0 and iindustria < 9999) then
 begin
 for
   select pro_codigo, pro_industria, pro_codprod, ite_conversao, pro_nome, pro_valornormal, pro_valorpromo, pro_preco3,
    (select * from sp_calliqprod (pro_valornormal, gru_desc1,gru_desc2,gru_desc3,gru_desc4,gru_desc5,gru_desc6,gru_desc7,gru_desc8,gru_desc9)) pre_liq,
    pro_datatabela, pro_embalagem, pro_vencpromocao, pro_ipi, ite_codigo2, pro_st, pro_nometabela,
    pro_grupopro,  pro_descadic2, ite_peso, ite_prepeso,
    case p.pro_setor
    when 'L' then 'Linha leve'
    when 'P' then 'Linha pesada'
    when 'A' then 'Linha agricola'
    when 'U' then 'Utilitarios'
    when 'I' then 'Utilitarios'
    when 'T' then 'Lancamento'
    end as setor
    from produtos p
    left join grupo_desc g on p.pro_grupo = g.gru_codigo
    where pro_industria = :iindustria and pro_nometabela = :itabela and coalesce(pro_grupopro, 0) between :igrupo and :vgrupo2
          and (ite_codigo2 containing :ipesquisa or pro_nome containing :ipesquisa or ite_conversao containing :ipesquisa)
    order by pro_codprod
    into
    :id, :codind, :codigo, :conversao, :nome, :preco1, :preco2, :preco3, :liquido, :datatab, :embalagem, :datapromo, :ipi,
    :codigo2, :st, :nometabela, :grupopro, :descadic2, :peso, :prepeso, :status
  do
  suspend;
 end
 if (char_length(ipesquisa) > 0 and iindustria = 9999) then
 begin
 for
   select pro_codigo, pro_industria, pro_codprod, ite_conversao, pro_nome, pro_valornormal, pro_valorpromo, pro_preco3,
    (select * from sp_calliqprod (pro_valornormal, gru_desc1,gru_desc2,gru_desc3,gru_desc4,gru_desc5,gru_desc6,gru_desc7,gru_desc8,gru_desc9)) pre_liq,
    pro_datatabela, pro_embalagem, pro_vencpromocao, pro_ipi, ite_codigo2, pro_st, pro_nometabela,
    pro_grupopro,  pro_descadic2, ite_peso, ite_prepeso,
    case p.pro_setor
    when 'L' then 'Linha leve'
    when 'P' then 'Linha pesada'
    when 'A' then 'Linha agricola'
    when 'U' then 'Utilitarios'
    when 'I' then 'Utilitarios'
    when 'T' then 'Lancamento'
    end as setor
    from produtos p
    left join grupo_desc g on p.pro_grupo = g.gru_codigo
    where pro_industria < :iindustria and pro_nometabela <> :itabela and coalesce(pro_grupopro, 0) between :igrupo and :vgrupo2
          and (ite_codigo2 containing :ipesquisa or pro_nome containing :ipesquisa)
    order by pro_codprod
    into
    :id, :codind, :codigo, :conversao, :nome, :preco1, :preco2, :preco3, :liquido, :datatab, :embalagem, :datapromo, :ipi,
    :codigo2, :st, :nometabela, :grupopro, :descadic2, :peso, :prepeso, :status
  do
  suspend;
 end

end^


ALTER PROCEDURE PROC_MOSTRATMKT (
    ICLIENTE INTEGER)
RETURNS (
    TELE_ID INTEGER,
    TELE_CLIENTE INTEGER,
    CLI_NOMRED VARCHAR(30),
    DATA DATE)
AS
declare variable ICLIENTE2 integer;
begin

 if (icliente = 0) then
  begin
  icliente  = 1;
  icliente2 = 9999;
  end
  else
  icliente2 = icliente;

 for
   select distinct
    t.tele_id,
    t.tele_cliente,
    c.cli_nomred,
    max(a.age_data) over(partition by a.age_cliente) dia
    from telemkt t
    join clientes c on t.tele_cliente  = c.cli_codigo
    left join agenda a on t.tele_cliente = a.age_cliente
    where t.tele_cliente between :icliente and :icliente2
    order by 4 desc
    into :tele_id, :tele_cliente, :cli_nomred, :data
 do
 suspend;
end^


ALTER PROCEDURE PROC_NIVERCLI (
    IDATAINI DATE,
    IDATAFIM DATE)
RETURNS (
    ANI_NOME VARCHAR(55),
    ANI_FUNCAO VARCHAR(35),
    ANI_FONE VARCHAR(15),
    ANI_EMAIL VARCHAR(60),
    ANI_OBS VARCHAR(600),
    CLI_NOMRED VARCHAR(30),
    ANI_NIVER VARCHAR(10))
AS
begin
  for
    select a.ani_nome, a.ani_funcao, a.ani_fone, a.ani_email,
           a.ani_obs, c.cli_nomred, extract(day from a.ani_niver)||'/'||extract(month from a.ani_niver)
    from cli_aniv a
    join clientes c on a.ani_cliente = c.cli_codigo
    where ani_niver between :idataini and :idatafim and cli_tipopes = 'A'
    order by ani_nome
    into :ani_nome,  :ani_funcao, :ani_fone, :ani_email, :ani_obs, :cli_nomred, :ani_niver
  do
  suspend;
end^


ALTER PROCEDURE PROC_NIVERFOR (
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    CON_NOME VARCHAR(45),
    CON_CARGO VARCHAR(25),
    CON_FONE VARCHAR(15),
    CON_CELULAR VARCHAR(15),
    CON_EMAIL VARCHAR(60),
    FOR_NOMERED VARCHAR(15),
    DIA VARCHAR(6))
AS
begin
 for
  select c.con_nome, c.con_gargo, c.con_fone, c.con_celular, c.con_email,
  i.for_nomered, extract(day from c.con_dtnasc)||'/'||extract(month from c.con_dtnasc) dia
  from contato_for c
  left join fornecedores i on c.con_fornec = i.for_codigo
  where c.con_dtnasc between :idata1 and :idata2 and i.for_tipo2 = 'A'
  order by con_nome
 into :con_nome, :con_cargo, :con_fone, :con_celular, :con_email, :for_nomered, :dia
 do
 suspend;
end^


ALTER PROCEDURE PROC_NIVERFUNCIONARIOS (
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    VENDEDOR VARCHAR(45),
    DIA VARCHAR(10))
AS
begin
 for
  select vv.vendedor, vv.dia from
    (select ven_nome vendedor,
      Cast(substring(ven_aniversario from 1 for 2)||'.'|| substring(ven_aniversario from 4 for 2) ||'.'|| '2001' as Date) as dia
  from vendedores) vv
  where vv.dia between :idata1 and :idata2
  into :vendedor, :dia
 do
 suspend;
end^


ALTER PROCEDURE PROC_NIVERS (
    IDATAINI DATE,
    IDATAFIM DATE)
RETURNS (
    CONTATO VARCHAR(55),
    EMPRESA VARCHAR(50),
    FUNCAO VARCHAR(35),
    FONE VARCHAR(15),
    EMAIL VARCHAR(60),
    ANI_NIVER VARCHAR(10),
    DTNASC DATE)
AS
begin
  for
    select 'Cliente: '||c.cli_nomred,
           a.ani_nome,
           a.ani_funcao,
           a.ani_fone,
           a.ani_email,
           extract(day from a.ani_niver)||'/'||extract(month from a.ani_niver),
           a.ani_niver
    from cli_aniv a
    join clientes c on a.ani_cliente = c.cli_codigo
    where ani_niver between :idataini and :idatafim and cli_tipopes = 'A'

    union all

    select 'Industria: '||i.for_nomered,
           c.con_nome,
           c.con_gargo,
           c.con_fone,
           c.con_email,
           extract(day from c.con_dtnasc)||'/'||extract(month from c.con_dtnasc),
           c.con_dtnasc
    from contato_for c
    left join fornecedores i on c.con_fornec = i.for_codigo
    where c.con_dtnasc between :idataini and :idatafim and i.for_tipo2 = 'A'
    order by 7

    into :empresa, :contato, :funcao, :fone, :email, :ani_niver, :dtnasc
  do
  suspend;
end^


ALTER PROCEDURE PROC_OBJ_REAL_CLI (
    IFOR INTEGER,
    IDATA1 DATE,
    IDATA2 DATE)
AS
begin
--  for
--   select distinct
--   lpad(p.ped_cliente,4)||' - '||c.cli_nomred,
--   max(p.ped_data),
--   sum(i.ite_quant),
--   sum(i.ite_totliquido)
--   from itens_ped i
--   join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
--   join clientes c on p.ped_cliente = c.cli_codigo
--   where p.ped_industria = :ifor and
--         p.ped_data between :idata1 and :idata2 and
--         p.ped_status in ('P','F')
--   order by p.ped_cliente, p.ped_data
--


--  suspend;
end^


ALTER PROCEDURE PROC_PEDIDOSCLI (
    ICLIENTE INTEGER)
RETURNS (
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    PED_TOTLIQ DOUBLE PRECISION,
    FOR_NOMERED VARCHAR(15),
    PED_CLIENTE INTEGER,
    PED_INDUSTRIA INTEGER)
AS
begin
 for
    select p.ped_pedido, p.ped_data, p.ped_totliq, f.for_nomered,
           p.ped_cliente, p.ped_industria
    from pedidos p
    left join fornecedores   f on p.ped_industria = f.for_codigo
    where p.ped_cliente = :icliente and p.ped_situacao in ('P','F')
    order by ped_data desc, f.for_nomered
    into :ped_pedido, :ped_data, :ped_totliq, :for_nomered, :ped_cliente, :ped_industria
 do
 suspend;
end^


ALTER PROCEDURE PROC_PEDSEMFAT (
    PIND INTEGER,
    PCLI INTEGER,
    PNF VARCHAR(300))
RETURNS (
    PEDIDO VARCHAR(10),
    DATAPED DATE,
    CLIENTE VARCHAR(30),
    SITUACAO VARCHAR(1),
    LIQUIDO DOUBLE PRECISION,
    COMIPI DOUBLE PRECISION,
    INDUSTRIA INTEGER,
    CLIID INTEGER,
    FATURADO DOUBLE PRECISION,
    NUMPEDIND VARCHAR(15),
    IDPROD VARCHAR(25),
    QTDVENDIDA DOUBLE PRECISION,
    QTDFATURADA INTEGER,
    SALDO INTEGER)
AS
begin
  for
   with xnfs as (select trim(texto) aNf from sp_splitstring(:pnf,';'))

   select ped_pedido, ped_data, cli_nomred, ped_situacao,
   ped_totliq, ped_totalipi, ped_industria, ped_cliente,  p.ped_cliind,
   i.ite_produto, i.ite_quant, i.ite_qtdfat, 0, (i.ite_quant - coalesce(i.ite_qtdfat, 0))
   from pedidos p
   join xnfs         x on p.ped_cliind    = x.aNf
   join itens_ped    i on i.ite_pedido    = p.ped_pedido
   join clientes     c on p.ped_cliente   = c.cli_codigo
   join fornecedores f on p.ped_industria = f.for_codigo
   where p.ped_industria = :pind and
         p.ped_cliente   = :pcli
   order by i.ite_pedido
   into :pedido, :dataped, :cliente, :situacao, :liquido, :comipi, :industria,
        :cliid,  :numpedind, :idprod, :qtdvendida, :qtdfaturada, :faturado, :saldo
   do
    suspend;
end^


ALTER PROCEDURE PROC_PGREC (
    IDATA1 DATE,
    IDATA2 DATE,
    IROTINA CHAR(1),
    ICLIFOR INTEGER,
    IFLAG CHAR(2),
    ICCUSTO INTEGER,
    ICONTA INTEGER)
RETURNS (
    ID INTEGER,
    DOCTO VARCHAR(15),
    DTLANCTO DATE,
    CREDEB CHAR(1),
    CONTA INTEGER,
    VALOR DOUBLE PRECISION,
    VENCTO DATE,
    VALORPAGO DOUBLE PRECISION,
    DATAPGTO DATE,
    CLIFOR_ID INTEGER,
    CLIFOR VARCHAR(60),
    DESCRICAO VARCHAR(600),
    SALDO DOUBLE PRECISION,
    PARCELA INTEGER,
    CCUSTO VARCHAR(60),
    CTACRE VARCHAR(10),
    CTADEB VARCHAR(10),
    JUROS DOUBLE PRECISION)
AS
declare variable VCLIFOR2 integer;
declare variable VPAGO double precision;
declare variable VCCUSTO integer;
declare variable VCONTA integer;
declare variable VJUROS double precision;
begin
 juros = 0;
 if (iccusto > 0) then vccusto = iccusto;
 if (iccusto = 0) then
 begin
 iccusto = 1;
 vccusto = 9999;
 end

 if (iconta > 0) then vconta = iconta;
 if (iconta = 0) then
 begin
 iconta = 0;
 vconta = 9999;
 end

 if (iclifor > 0) then vclifor2 = iclifor;
 if (iclifor = 0) then
 begin
 iclifor = 1;
 vclifor2 = 9999;
 end


 delete from saldo_pgrec where sal_id > 0;
 -- popula saldos
 merge into saldo_pgrec s
 using (select f.cta_docto,
               f.cta_parcela,
               sum(coalesce(f.cta_valorpago, 0)) saldo,
               max(f.cta_id) contador,
               max(f.cta_data) pagto,
               max((select ct.con_grau from contas ct where ct.con_codigo = f.cta_conta)) ctacre,
               max((select ct.con_grau from contas ct where ct.con_codigo = f.cta_contadebito)) ctadeb,
               coalesce(max(f.cta_conta), 0) concre, coalesce(max(f.cta_contadebito),0) condeb
               from fracrecebimentos f
               group by 1,2
        ) f
 on
 f.cta_docto = s.sal_docto and f.cta_parcela = s.sal_parcela
 when not matched then insert (sal_docto, sal_parcela, sal_saldo, sal_id, sal_ultpagto, sal_graucre, sal_graudeb, sal_concre, sal_condeb)
                       values (f.cta_docto, f.cta_parcela,  f.saldo, f.contador, f.pagto, f.ctacre, f.ctadeb, f.concre, f.condeb);
 -- end

   if (iflag = 'RA' or iflag = 'PA') then   -- a receber/pagar em aberto
    begin
       for
            select c.lan_lancto, c.lan_docto, c.lan_data, c.lan_credeb, c.lan_conta, c.lan_valor, c.lan_vencimento,
                   x1.sal_saldo, x1.sal_ultpagto, c.lan_clifor, c.lan_clifornome, c.lan_descricao,
                   coalesce(x1.sal_saldo, 0), c.lan_parcela, cc.cc_descricao, x1.sal_graucre, x1.sal_graudeb,
                   1
            from contaspgrec c
            left join saldo_pgrec x1 on c.lan_docto = x1.sal_docto and c.lan_parcela = x1.sal_parcela
            left join ccustos cc on c.lan_conta = cc.cc_id
            left join cred_dev cl on c.lan_clifor = cl.cd_codigo
            where c.lan_vencimento between :idata1 and :idata2 and
                  c.lan_clifor between :iclifor and :vclifor2  and
                  coalesce(c.lan_conta,0) between :iccusto and :vccusto and
                  coalesce(c.lan_ctacontab,0) between :iconta and :vconta and
                  c.lan_credeb = :irotina and (coalesce(x1.sal_saldo, 0) < c.lan_valor)
            order by 7
    
            into :id, :docto, :dtlancto, :credeb, :conta, :valor, :vencto, :valorpago,
                 :datapgto, :clifor_id, :clifor, :descricao, :vpago, :parcela, :ccusto,
                 :ctacre, :ctadeb, :vjuros
       do
        begin
         :saldo = 0;
         if (:vpago < :valor) then
          :saldo = ((:valor+juros) - :vpago);
         if (iflag = 'RA') then
          begin
           juros = 0;
           if (vjuros > 0 and (vencto < current_date)) then
             begin
              vjuros = (vjuros/100)/30;
              juros = (saldo * vjuros);
              saldo = ((:valor+juros) - :vpago);
             end
          end
         suspend;
        end
    end
   if (iflag = 'RQ' or iflag = 'PQ') then   -- a receber/pagar (quitados)
    begin
       for
            select c.lan_lancto, c.lan_docto, c.lan_data, c.lan_credeb, c.lan_conta, c.lan_valor, c.lan_vencimento,
                   x1.sal_saldo, x1.sal_ultpagto, c.lan_clifor, c.lan_clifornome, c.lan_descricao,
                   coalesce(x1.sal_saldo, 0), c.lan_parcela, cc.cc_descricao, x1.sal_graucre, x1.sal_graudeb
            from contaspgrec c
            left join saldo_pgrec x1 on c.lan_docto = x1.sal_docto and c.lan_parcela = x1.sal_parcela
            left join ccustos cc on c.lan_conta = cc.cc_id
            where x1.sal_ultpagto between :idata1 and :idata2 and
                  c.lan_clifor between :iclifor and :vclifor2  and
                  coalesce(c.lan_conta, 0) between :iccusto and :vccusto and
                  (coalesce(x1.sal_concre, 0) between :iconta and :vconta or
                   coalesce(x1.sal_condeb, 0) between :iconta and :vconta) and
                  c.lan_credeb = :irotina
                  -- and (coalesce(x1.sal_saldo, 0) >= c.lan_valor)
            order by 9
    
            into :id, :docto, :dtlancto, :credeb, :conta, :valor, :vencto, :valorpago,
                 :datapgto, :clifor_id, :clifor, :descricao, :vpago, :parcela, :ccusto, :ctacre, :ctadeb
       do
        begin
        :saldo = 0;
        if (:vpago < :valor) then
        :saldo = (:valor - :vpago);
        juros = 0;
        suspend;
        end
    end
end^


ALTER PROCEDURE PROC_PGREC_REL (
    IDATA1 DATE,
    IDATA2 DATE,
    IROTINA CHAR(1),
    ICLIFOR INTEGER,
    IFLAG CHAR(2),
    ICCUSTO INTEGER,
    ICONTA VARCHAR(10))
RETURNS (
    ID INTEGER,
    DOCTO VARCHAR(15),
    DTLANCTO DATE,
    CREDEB CHAR(1),
    CONTA INTEGER,
    VALOR DOUBLE PRECISION,
    VENCTO DATE,
    VALORPAGO DOUBLE PRECISION,
    DATAPGTO DATE,
    CLIFOR_ID INTEGER,
    CLIFOR VARCHAR(60),
    DESCRICAO VARCHAR(600),
    SALDO DOUBLE PRECISION,
    PARCELA INTEGER,
    CCUSTO VARCHAR(60),
    CTACRE VARCHAR(10),
    CTADEB VARCHAR(30))
AS
declare variable VCLIFOR2 integer;
declare variable VPAGO double precision;
declare variable VCCUSTO integer;
begin
 if (iccusto > 0) then vccusto = iccusto;
 if (iccusto = 0) then
 begin
 iccusto = 1;
 vccusto = 9999;
 end

 if (char_length(iconta) = 0) then
  iconta = '0%';
  else
  iconta = iconta ||'%';

 if (iclifor > 0) then vclifor2 = iclifor;
 if (iclifor = 0) then
 begin
 iclifor = 1;
 vclifor2 = 9999;
 end


 delete from saldo_pgrec where sal_id > 0;

 -- popula saldos
 merge into saldo_pgrec s
 using (select distinct
               f.cta_docto,
               f.cta_parcela,
               sum(coalesce(f.cta_valorpago, 0)) over (partition by f.cta_docto, f.cta_parcela) saldo,
               max(f.cta_data) over (partition by f.cta_docto, f.cta_parcela) pagto
               from fracrecebimentos f
               join contaspgrec c on f.cta_docto = c.lan_docto and f.cta_parcela = c.lan_parcela and c.lan_credeb = :irotina
               order by f.cta_docto, f.cta_parcela
        ) f
 on
 f.cta_docto = s.sal_docto and f.cta_parcela = s.sal_parcela
 when not matched then insert (sal_docto, sal_parcela, sal_saldo, sal_ultpagto)
                       values (f.cta_docto, f.cta_parcela,  f.saldo, f.pagto);
 -- end

   if (iflag = 'RA' or iflag = 'PA') then   -- a receber/pagar em aberto
    begin
       for
            select c.lan_lancto, c.lan_docto, c.lan_data, c.lan_credeb, c.lan_conta, c.lan_valor, c.lan_vencimento,
                   x1.sal_saldo, x1.sal_ultpagto, c.lan_clifor, c.lan_clifornome, c.lan_descricao,
                   coalesce(x1.sal_saldo, 0), c.lan_parcela, cc.cc_descricao, s.con_grau, left(s.con_descricao, 30)
            from contaspgrec c
            left join saldo_pgrec x1 on c.lan_docto = x1.sal_docto and c.lan_parcela = x1.sal_parcela
            left join ccustos cc on c.lan_conta = cc.cc_id
            left join contas s on c.lan_ctacontab = s.con_codigo
            where c.lan_vencimento between :idata1 and :idata2 and
                  c.lan_clifor between :iclifor and :vclifor2  and
                  s.con_grau like :iconta and
                  c.lan_credeb = :irotina and
                  (coalesce(x1.sal_saldo, 0) < c.lan_valor)
            order by 7
    
            into :id, :docto, :dtlancto, :credeb, :conta, :valor, :vencto, :valorpago,
                 :datapgto, :clifor_id, :clifor, :descricao, :vpago, :parcela, :ccusto, :ctacre, :ctadeb
       do
        begin
        :saldo = 0;
        if (:vpago < :valor) then
        :saldo = (:valor - :vpago);
        suspend;
        end

    end
   if (iflag = 'RQ' or iflag = 'PQ') then   -- a receber/pagar (quitados)
    begin
       for
            select c.lan_lancto, c.lan_docto, c.lan_data, c.lan_credeb, c.lan_conta, c.lan_valor, c.lan_vencimento,
                   x1.sal_saldo, x1.sal_ultpagto, c.lan_clifor, c.lan_clifornome, c.lan_descricao,
                   coalesce(x1.sal_saldo, 0), c.lan_parcela, cc.cc_descricao,  s.con_grau, left(s.con_descricao, 30)
            from contaspgrec c
            left join saldo_pgrec x1 on c.lan_docto = x1.sal_docto and c.lan_parcela = x1.sal_parcela
            left join ccustos cc on c.lan_conta = cc.cc_id
            left join contas s on c.lan_ctacontab = s.con_codigo
            where x1.sal_ultpagto between :idata1 and :idata2 and
                  c.lan_clifor between :iclifor and :vclifor2  and
                  coalesce(c.lan_conta, 0) between :iccusto and :vccusto and
                  s.con_grau like :iconta and
                  c.lan_credeb = :irotina
            order by 9
    
            into :id, :docto, :dtlancto, :credeb, :conta, :valor, :vencto, :valorpago,
                 :datapgto, :clifor_id, :clifor, :descricao, :vpago, :parcela, :ccusto, :ctacre, :ctadeb
       do
        begin
        :saldo = 0;
        if (:vpago < :valor) then
        :saldo = (:valor - :vpago);
        suspend;
        end
    end
end^


ALTER PROCEDURE PROC_PLACON (
    IPESQ VARCHAR(40))
RETURNS (
    GRAU VARCHAR(10),
    ID INTEGER,
    DESCRICAO VARCHAR(50),
    TIPO CHAR(1),
    DESCTIPO VARCHAR(10))
AS
begin
 if (char_length(ipesq) = 0) then
   begin
     for
        select c.con_grau, c.con_codigo, c.con_descricao, c.con_tipo,
        iif(con_tipo = 'A', 'Anal?tica', 'Sint?tica') tipo
        from contas c
        order by 1
        into :grau, :id, :descricao, :tipo, :desctipo
     do
     suspend;
   end
 if (char_length(ipesq) > 0) then
   begin
     for
        select c.con_grau, c.con_codigo, c.con_descricao, c.con_tipo,
        iif(con_tipo = 'A', 'Anal?tica', 'Sint?tica') tipo
        from contas c
        where c.con_descricao containing :ipesq
        order by 1
        into :grau, :id, :descricao, :tipo, :desctipo
     do
     suspend;
   end
end^


ALTER PROCEDURE PROC_POLITDESC (
    IPEDIDO VARCHAR(10),
    IINDUSTRIA INTEGER)
AS
declare variable VDESC1 numeric(6,2);
declare variable VDESC2 numeric(6,2);
declare variable VDESC3 numeric(6,2);
declare variable VDESC4 numeric(6,2);
declare variable VDESC5 numeric(6,2);
declare variable VDESC6 numeric(6,2);
declare variable VDESC7 numeric(6,2);
declare variable VDESC8 numeric(6,2);
declare variable VDESC9 numeric(6,2);
declare variable IVALOR double precision;
begin
  select p.ped_totbruto
  from pedidos p
  where p.ped_pedido = :ipedido and p.ped_industria = :iindustria
  into :ivalor;

  select coalesce(g.gru_desc1, 0), coalesce(g.gru_desc2, 0), coalesce(g.gru_desc3, 0),
         coalesce(g.gru_desc4, 0), coalesce(g.gru_desc5, 0), coalesce(g.gru_desc6, 0),
         coalesce(g.gru_desc7, 0), coalesce(g.gru_desc8, 0), coalesce(g.gru_desc9, 0)
  from descontos_ind d
  join grupo_desc   g on d.des_desconto = g.gru_codigo
  where d.des_codind = :iindustria and :ivalor > d.des_valini and :ivalor <= d.des_valfim
  into :vdesc1,:vdesc2,:vdesc3,:vdesc4,:vdesc5,:vdesc6,:vdesc7,:vdesc8,:vdesc9;

  -- atualiza tabela itens_ped
  if (:vdesc1 > 0) then
   begin
     update itens_ped set ite_des1 = :vdesc1, ite_des2 = :vdesc2, ite_des3 = :vdesc3, ite_des4 = :vdesc4,
                          ite_des5 = :vdesc5, ite_des6 = :vdesc6, ite_des7 = :vdesc7, ite_des8 = :vdesc8,  ite_des9 = :vdesc9
     where ite_pedido = :ipedido and ite_industria = :iindustria;
   end
end^


ALTER PROCEDURE PROC_POSICAOSELLS (
    ICLIENTE INTEGER,
    IVEND INTEGER,
    IIND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IREDE CHAR(1))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    INDUSTRIA VARCHAR(15),
    MESANO VARCHAR(10),
    TOTAL DOUBLE PRECISION,
    TOTALQTD DOUBLE PRECISION)
AS
declare variable VREDELOJA varchar(35);
declare variable IVEND2 integer;
declare variable IIND2 integer;
declare variable ICLIENTE2 integer;
begin
 ivend2 = ivend;
 iind2  = iind;
 icliente2 = icliente;

 if (icliente is null) then
 begin
 icliente = 1;
 icliente2 = 9999;
 end

 if (ivend is null or ivend = 0) then
  begin
    ivend  = 1;
    ivend2 = 999;
  end

 if (iind is null or iind = 0) then
  begin
    iind  = 1;
    iind2 = 9999;
  end

 delete from tab_temp where tmp_id > 0;

 if (:irede = 'S') then
  begin
   select cli_redeloja from clientes where cli_codigo = :icliente
   into :vredeloja;
  end


 if (:irede = 'N') then
  begin
      for
        select p.ped_pedido, f.for_nomered,
        cast(extract(year from p.ped_data) ||'/'|| extract(month from p.ped_data)||'/28' as date) MesAno,
        (select sum(ite_totliquido) from itens_ped where ite_pedido = p.ped_pedido) total,
        (select sum(ite_quant) from itens_ped where ite_pedido = p.ped_pedido) totalqtd
        from pedidos p
        join fornecedores f on p.ped_industria = f.for_codigo
        where p.ped_data      between :idata1 and :iData2 and
              p.ped_vendedor  between :ivend  and :ivend2 and
              p.ped_cliente   between :icliente and :icliente2 and
              p.ped_industria between :iInd   and :iind2  and
              p.ped_situacao  in ('P','F')
        group by 1,2,3
        order by 2,3
       into :ped_pedido, :industria, :mesano, :total, :totalqtd
      do
      suspend;
  end
 if (:irede = 'S') then
  begin
      for
        select p.ped_pedido, f.for_nomered,
        cast(extract(year from p.ped_data) ||'/'|| extract(month from p.ped_data)||'/28' as date) MesAno,
        (select sum(ite_totliquido) from itens_ped where ite_pedido = p.ped_pedido) total,
        (select sum(ite_quant) from itens_ped where ite_pedido = p.ped_pedido) totalqtd
        from pedidos p
        join clientes c on p.ped_cliente = c.cli_codigo
        join fornecedores f on p.ped_industria = f.for_codigo
        where p.ped_data      between :idata1 and :iData2 and
              p.ped_vendedor  between :ivend  and :ivend2 and
              p.ped_industria between :iInd   and :iind2  and
              p.ped_situacao  in ('P','F')    and
              c.cli_redeloja = :vredeloja
        group by 1,2,3
        order by 2,3
       into :ped_pedido, :industria, :mesano, :total, :totalqtd
      do
      suspend;
  end

end^


ALTER PROCEDURE PROC_PRODPED (
    IFOR INTEGER,
    ITAB VARCHAR(20))
RETURNS (
    ID INTEGER,
    CODIND INTEGER,
    CODIGO VARCHAR(25),
    CONVERSAO VARCHAR(300),
    NOME VARCHAR(100),
    PRECO1 DOUBLE PRECISION,
    PRECO2 DOUBLE PRECISION,
    PRECO3 DOUBLE PRECISION,
    DATATAB DATE,
    EMBALAGEM INTEGER,
    DATAPROMO DATE,
    IPI DOUBLE PRECISION,
    CODIGO2 VARCHAR(25),
    LINHA VARCHAR(50),
    GRUPODES INTEGER,
    DESCADIC DOUBLE PRECISION,
    ST DOUBLE PRECISION,
    GRUPOPRO INTEGER,
    NOMETABELA VARCHAR(20),
    DESCADIC2 DOUBLE PRECISION,
    PESO DOUBLE PRECISION,
    PREPESO DOUBLE PRECISION,
    STATUS CHAR(1))
AS
begin
 for
  select p.pro_codigo, p.pro_industria, p.pro_codprod, p.ite_conversao, p.pro_nome, p.pro_valornormal, p.pro_valorpromo, p.pro_preco3,
         p.pro_datatabela, p.pro_embalagem, p.pro_vencpromocao, p.pro_ipi, p.ite_codigo2, p.pro_linha, p.pro_grupo, p.pro_descadic, p.pro_st,
         p.pro_grupopro, p.pro_nometabela, p.pro_descadic2, p.ite_peso, p.ite_prepeso, left(p.pro_setor,1)

  from produtos p
  where p.pro_industria = :ifor and p.pro_nometabela = :itab
  into
  :id, :codind, :codigo, :conversao, :nome, :preco1, :preco2, :preco3, :datatab, :embalagem, :datapromo, :ipi, :codigo2, :linha, :grupodes, :descadic,
  :st, :grupopro, :nometabela, :descadic2, :peso, :prepeso, :status
 do
 suspend;
end^


ALTER PROCEDURE PROC_PROTABELAS (
    IINDUSTRIA INTEGER)
RETURNS (
    PRO_NOMETABELA VARCHAR(25))
AS
begin
  for
    select pro_nometabela
    from produtos
    where pro_industria = :iindustria
    group by pro_nometabela, pro_industria
    order by pro_nometabela
    into :pro_nometabela
  do
  suspend;
end^


ALTER PROCEDURE PROC_RECBOLETOS (
    IDATA1 DATE,
    IDATA2 DATE,
    IFLAG VARCHAR(1))
RETURNS (
    LAN_LANCTO INTEGER,
    LAN_DOCTO VARCHAR(15),
    LAN_DATA DATE,
    LAN_VALOR DOUBLE PRECISION,
    LAN_CLIFOR INTEGER,
    LAN_CLIFORNOME VARCHAR(60),
    LAN_VENCIMENTO DATE,
    LAN_NOSSONUMERO VARCHAR(25),
    LAN_SEL CHAR(1),
    LAN_PATHBOLETO VARCHAR(300),
    LAN_DESCRICAO BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    CLI_EMAIL VARCHAR(100),
    CLI_RAZAO VARCHAR(60),
    CLI_ENDERECO VARCHAR(45),
    CLI_BAIRRO VARCHAR(25),
    CLI_TIPO CHAR(1),
    CLI_CIDADE VARCHAR(25),
    CLI_UF VARCHAR(2),
    CLI_CEP VARCHAR(10),
    CLI_CNPJ VARCHAR(18),
    CLI_ENDENUM VARCHAR(10))
AS
begin
   if (iflag = 'T') then -- todos
    begin
     for
      select
      lan_lancto, lan_docto, lan_data, lan_valor, lan_clifor, lan_clifornome,
      lan_vencimento, lan_nossonumero, lan_sel, lan_pathboleto, lan_descricao,
      c.cd_email, c.cd_nome, c.cd_endereco, c.cd_bairro, c.cd_tipo,
      c.cd_cidade, c.cd_uf, c.cd_cep, c.cd_cpfcnpj, c.cd_endenum
      from contaspgrec ct
      join cred_dev c on ct.lan_clifor = c.cd_codigo
      where ct.lan_credeb = 'R' and ct.lan_vencimento between :idata1 and :idata2
      order by ct.lan_clifor, ct.lan_vencimento
      into
      :lan_lancto, :lan_docto, :lan_data, :lan_valor, :lan_clifor, :lan_clifornome,
      :lan_vencimento, :lan_nossonumero, :lan_sel, :lan_pathboleto, :lan_descricao,
      :cli_email, :cli_razao, :cli_endereco, :cli_bairro, :cli_tipo,
      :cli_cidade, :cli_uf, :cli_cep, :cli_cnpj, :cli_endenum
      do
      suspend;
    end
end^


ALTER PROCEDURE PROC_RECEBEITENSBAIXAXML (
    PDADOS BLOB SUB_TYPE BINARY SEGMENT SIZE 80)
AS
declare variable VPEDIDOANT varchar(10);
declare variable VPEDIDO varchar(10);
declare variable VPRODUTO varchar(25);
declare variable VQTD double precision;
declare variable VUNI double precision;
declare variable VNUMNF integer;
declare variable VIDX integer;
declare variable VPARTE varchar(30000);
declare variable VLINHA varchar(500);
declare variable VVALOR varchar(100);
declare variable VDATA date;
declare variable VIND integer;
declare variable VTOTALPED double precision;
begin
  vpedidoant = '';
  vtotalped = 0;
  for
    select bp.parte
    from sp_blobempartes(:pDados,'|') bp
    into vParte
  do
  begin
    for
      select ss.texto
      from sp_splitstring(:vParte,'|') ss
      into vLinha
    do
    begin
      for
        select ss.idx, nullif(ss.texto, '')
        from sp_splitstring(:vLinha, ';') ss
        into vIdx, vValor
      do
      begin
        if (vpedidoant = '' and vIdx = 1) then vpedidoant = vvalor;
        if (vIdx = 1 and vpedidoant <> vvalor) then
         begin
          insert into fatura_ped (fat_pedido, fat_industria, fat_datafat, fat_valorfat, fat_nf)
          values (:vpedido, :vind, :vdata, :vtotalped, :vnumnf);
          vpedidoant = vvalor;
          vtotalped = 0;
         end
         if (vIdx = 1)       then vpedido    = vValor;
         else if (vIdx = 2)  then vdata      = vValor;
         else if (vIdx = 3)  then vproduto   = vvalor;
         else if (vIdx = 4)  then vqtd       = vvalor;
         else if (vIdx = 5)  then vuni       = vvalor;
         else if (vIdx = 6)  then vind       = vvalor;
         else if (vIdx = 7)  then vnumnf     = vvalor;
         if (vIdx = 7) then
         vtotalped = vtotalped + coalesce(vuni,  0);
      end
      update itens_ped set ite_qtdfat = (ite_qtdfat + :vqtd), ite_faturado = 'S'
      where ite_pedido = :vpedido and ite_produto = :vproduto;
    end
  end
 --para garantir o ultimo pedido da lista
 insert into fatura_ped (fat_pedido, fat_industria, fat_datafat, fat_valorfat, fat_nf)
 values (:vpedido, :vind, :vdata, :vtotalped, :vnumnf);
end^


ALTER PROCEDURE PROC_RECEBEITENSPED (
    PDADOS BLOB SUB_TYPE BINARY SEGMENT SIZE 80,
    IREPETEITENS BOOLEAN)
AS
declare variable VPEDIDO varchar(10);
declare variable VDATA date;
declare variable VPRODUTO varchar(25);
declare variable VQTD double precision;
declare variable VUNI double precision;
declare variable VUNILIQ double precision;
declare variable VIPI double precision;
declare variable VTOTLIQ double precision;
declare variable VCLIENTE integer;
declare variable VIND integer;
declare variable VVENDEDOR integer;
declare variable VDESCADIC integer;
declare variable VDES1 double precision;
declare variable VDES2 double precision;
declare variable VDES3 double precision;
declare variable VDES4 double precision;
declare variable VDES5 double precision;
declare variable VDES6 double precision;
declare variable VDES7 double precision;
declare variable VDES8 double precision;
declare variable VDES9 double precision;
declare variable VDES10 double precision;
declare variable VDES11 double precision;
declare variable VGRUPO integer;
declare variable VCOTACAO varchar(1);
declare variable VEMBUCH varchar(15);
declare variable VEXPORTADO char(1);
declare variable VSEQ integer;
declare variable VTOTBRUTO double precision;
declare variable VVALCOMIPI double precision;
declare variable VST double precision;
declare variable VVALCOMST double precision;
declare variable VDESCONTOS varchar(100);
declare variable VNOMEPROD varchar(100);
declare variable VIDX integer;
declare variable VPARTE varchar(30000);
declare variable VLINHA varchar(500);
declare variable VVALOR varchar(100);
declare variable VNUMPEDCLI varchar(25);
begin
  for
    select bp.parte
    from sp_blobempartes(:pDados,'|') bp
    into vParte
  do
  begin
    for
      select ss.texto
      from sp_splitstring(:vParte,'|') ss
      into vLinha
    do
    begin
      for
        select ss.idx, nullif(ss.texto, '')
        from sp_splitstring(:vLinha, ';') ss
        into vIdx, vValor
      do
      begin
        if (vIdx = 1)       then vpedido    = vValor;
        else if (vIdx = 2)  then vdata      = replace(vValor,'/','.');
        else if (vIdx = 3)  then vproduto   = vvalor;
        else if (vIdx = 4)  then vqtd       = iif(char_length(coalesce(vvalor, '')) < 1, 0, vvalor);
        else if (vIdx = 5)  then vuni       = vValor;
        else if (vIdx = 6)  then vuniliq    = vValor;
        else if (vIdx = 7)  then vipi       = vValor;
        else if (vIdx = 8)  then vtotliq    = vValor;
        else if (vIdx = 9)  then vcliente   = vValor;
        else if (vIdx = 10) then vind       = vValor;
        else if (vIdx = 11) then vvendedor  = vValor;
        else if (vIdx = 12) then vdescadic  = vvalor;
        else if (vIdx = 13) then vdes1      = vvalor;
        else if (vIdx = 14) then vdes2      = vvalor;
        else if (vIdx = 15) then vdes3      = vvalor;
        else if (vIdx = 16) then vdes4      = vvalor;
        else if (vIdx = 17) then vdes5      = vvalor;
        else if (vIdx = 18) then vdes6      = vvalor;
        else if (vIdx = 19) then vdes7      = vvalor;
        else if (vIdx = 20) then vdes8      = vvalor;
        else if (vIdx = 21) then vdes9      = vvalor;
        else if (vIdx = 22) then vdes10     = vvalor;
        else if (vIdx = 23) then vdes11     = vvalor;
        else if (vIdx = 24) then vgrupo     = vvalor;
        else if (vIdx = 25) then vcotacao   = vvalor;
        else if (vIdx = 26) then vembuch    = coalesce(vvalor, '');
        else if (vIdx = 27) then vexportado = vvalor;
        else if (vIdx = 28) then vseq       = vvalor;
        else if (vIdx = 29) then vtotbruto  = vvalor;
        else if (vIdx = 30) then vvalcomipi = vvalor;
        else if (vIdx = 31) then vst        = vvalor;
        else if (vIdx = 32) then vvalcomst  = vvalor;
        else if (vIdx = 33) then vdescontos = vvalor;
        else if (vIdx = 34) then vnomeprod  = vvalor;
        else if (vIdx = 36) then vnumpedcli = vvalor; --numero pedido do cliente em cada item do pedido (pulou 2 porque nao interessa ao proc)
      end
      if (irepeteitens = false) then
       begin
          update or insert into itens_ped
          (ite_pedido, ite_industria, ite_produto, ite_embuch, ite_nomeprod, ite_grupo, ite_data, ite_quant, ite_puni, ite_puniliq, ite_totliquido,
           ite_descadic, ite_des1, ite_des2, ite_des3, ite_des4, ite_des5, ite_des6, ite_des7, ite_des8, ite_des9, ite_des10, ite_des11, ite_descontos,
           ite_totbruto, ite_valcomipi, ite_ipi, ite_st, ite_valcomst, ite_cliente, ite_vendedor, ite_exportado, ite_cotacao, ite_seq, ite_numpedcli)
          values
          (:vpedido, :vind, :vproduto, :vembuch, :vnomeprod, :vgrupo, :vdata, :vqtd, :vuni, :vuniliq, :vtotliq,
           :vdescadic, :vdes1, :vdes2, :vdes3, :vdes4, :vdes5, :vdes6, :vdes7,  :vdes8, :vdes9, :vdes10, :vdes11, :vdescontos,
           :vtotbruto, :vvalcomipi, :vipi, :vst, :vvalcomst, :vcliente, :vvendedor, :vexportado, :vcotacao, :vseq, :vnumpedcli)
          matching (ite_pedido, ite_produto, ite_industria);
       end
      if (irepeteitens = true) then
       begin
          update or insert into itens_ped
          (ite_pedido, ite_industria, ite_produto, ite_embuch, ite_nomeprod, ite_grupo, ite_data, ite_quant, ite_puni, ite_puniliq, ite_totliquido,
           ite_descadic, ite_des1, ite_des2, ite_des3, ite_des4, ite_des5, ite_des6, ite_des7, ite_des8, ite_des9, ite_des10, ite_des11, ite_descontos,
           ite_totbruto, ite_valcomipi, ite_ipi, ite_st, ite_valcomst, ite_cliente, ite_vendedor, ite_exportado, ite_cotacao, ite_seq, ite_numpedcli)
          values
          (:vpedido, :vind, :vproduto, :vembuch, :vnomeprod, :vgrupo, :vdata, :vqtd, :vuni, :vuniliq, :vtotliq,
           :vdescadic, :vdes1, :vdes2, :vdes3, :vdes4, :vdes5, :vdes6, :vdes7,  :vdes8, :vdes9, :vdes10, :vdes11, :vdescontos,
           :vtotbruto, :vvalcomipi, :vipi, :vst, :vvalcomst, :vcliente, :vvendedor, :vexportado, :vcotacao, :vseq, :vnumpedcli)
          matching (ite_pedido, ite_produto, ite_seq, ite_industria);
       end
    end
  end
end^


ALTER PROCEDURE PROC_RECEBEITENSPEDEXCEL (
    PDADOS BLOB SUB_TYPE BINARY SEGMENT SIZE 80)
AS
declare variable VPEDIDO varchar(10);
declare variable VDATA date;
declare variable VPRODUTO varchar(25);
declare variable VQTD double precision;
declare variable VIND integer;
declare variable VCLIENTE integer;
declare variable VVENDEDOR integer;
declare variable VNOMEPROD varchar(50);
declare variable VEXPORTADO char(1);
declare variable VEMBUCH varchar(15);
declare variable VUNI double precision;
declare variable VSEQ integer;
declare variable VIDX integer;
declare variable VPARTE varchar(30000);
declare variable VLINHA varchar(500);
declare variable VVALOR varchar(100);
begin
  for
    select bp.parte
    from sp_blobempartes(:pDados,'|') bp
    into vParte
  do
  begin
    for
      select ss.texto
      from sp_splitstring(:vParte,'|') ss
      into vLinha
    do
    begin
      for
        select ss.idx, nullif(ss.texto, '')
        from sp_splitstring(:vLinha, ';') ss
        into vIdx, vValor
      do
      begin
        if (vIdx = 1)       then vpedido    = vValor;
        else if (vIdx = 2)  then vdata      = current_date;
        else if (vIdx = 3)  then vproduto   = vvalor;
        else if (vIdx = 4)  then vqtd       = iif(char_length(coalesce(vvalor, '')) < 1, 0, vvalor);
        else if (vIdx = 5)  then vind       = vValor;
        else if (vIdx = 6)  then vcliente   = vValor;
        else if (vIdx = 7)  then vvendedor  = vValor;
        else if (vIdx = 8)  then vnomeprod  = '';
        else if (vIdx = 9)  then vexportado = 'N';
        else if (vIdx = 10) then vembuch    = vValor;
        else if (vIdx = 11) then vuni       = iif(char_length(coalesce(vvalor, '')) < 1, 0, vvalor);
        else if (vIdx = 12) then vseq       = vvalor;
      end
      update or insert into itens_ped
      (ite_pedido, ite_data, ite_produto, ite_quant, ite_industria, ite_cliente, ite_vendedor, ite_nomeprod, ite_exportado,
       ite_embuch, ite_puni, ite_seq)
      values
      (:vpedido, :vdata, :vproduto, :vqtd, :vind, :vcliente, :vvendedor,
       :vnomeprod,:vexportado, :vembuch, :vuni, :vseq)
      matching (ite_pedido, ite_produto, ite_industria);
    end
  end
end^


ALTER PROCEDURE PROC_REGIAOVEND (
    IVEND INTEGER)
RETURNS (
    ID INTEGER,
    REGIAO VARCHAR(50))
AS
declare variable VSQL varchar(600);
declare variable VLB char(2);
begin
 vlb  = ascii_char(13)||ascii_char(10);
 vSql = '';

 if (ivend is null or ivend = 0) then
  ivend = 9999;

 if (ivend < 9999) then
 begin
   vsql = 'select r.reg_codigo, r.reg_descricao '
   ||vlb||'from regioes r '
   ||vlb||'join vendedor_reg v on v.vin_regiao = r.reg_codigo and v.vin_codigo = :xvend '
   ||vlb||'order by r.reg_descricao ';
 end

 if (ivend = 9999) then
 begin
   vsql = 'select r.reg_codigo, r.reg_descricao '
   ||vlb||'from regioes r '
   ||vlb||'left join vendedor_reg v on v.vin_regiao = r.reg_codigo and v.vin_codigo < :xvend '
   ||vlb||'order by r.reg_descricao ';
 end
 for
   execute statement (vSql) (xvend := :ivend)
   into :id, :regiao
 do
  suspend;
end^


ALTER PROCEDURE PROC_REGIOES (
    IPESQ VARCHAR(60))
RETURNS (
    ID INTEGER,
    DESCRICAO VARCHAR(50))
AS
begin
 if (ipesq is null) then ipesq = '';
 if (char_length(ipesq) = 0) then ipesq = '';

 if (char_length(ipesq) = 0) then
  begin
   for
    select r.reg_codigo, r.reg_descricao
    from regioes r
    order by r.reg_descricao
    into :id, :descricao
   do
   suspend;
  end

 if (char_length(ipesq) > 0) then
  begin
   ipesq = Upper(ipesq);
   for
    select r.reg_codigo, r.reg_descricao
    from regioes r
    where Upper(r.reg_descricao) like '%'||:ipesq||'%'
    order by r.reg_descricao
    into :id, :descricao
   do
   suspend;
  end
end^


ALTER PROCEDURE PROC_RELCLIATUAREGIAO (
    IDAREA INTEGER,
    IDREGIAO INTEGER)
RETURNS (
    IDCLI INTEGER,
    NOMERED VARCHAR(30),
    REGIAO VARCHAR(50),
    ENDERECO VARCHAR(200),
    ENDNUM VARCHAR(15),
    CIDADE VARCHAR(25),
    TELEFONE VARCHAR(20),
    BAIRRO VARCHAR(100))
AS
begin
 if (idregiao = 0) then
  begin
   for
    select a.atu_idcli, c.cli_nomred, r.reg_descricao,
           c.cli_endereco, c.cli_endnum, c.cli_bairro, c.cli_cidade, c.cli_fone1
    from atua_cli a
    join clientes c on a.atu_idcli = c.cli_codigo
    left join regioes r on c.cli_regiao2 = r.reg_codigo
    where a.atu_atuaid = :idarea and
          c.cli_tipopes = 'A'
    order by 2
    into :idcli, :nomered, :regiao, :endereco, :endnum, :bairro, :cidade, :telefone
    do
    suspend;
  end
  else
  begin
   for
    select a.atu_idcli, c.cli_nomred, r.reg_descricao,
           c.cli_endereco, c.cli_endnum, c.cli_bairro, c.cli_cidade, c.cli_fone1
    from atua_cli a
    join clientes c on a.atu_idcli = c.cli_codigo
    left join regioes r on c.cli_regiao2 = r.reg_codigo
    where a.atu_atuaid = :idarea and
          c.cli_tipopes = 'A' and
          r.reg_codigo = :idregiao
    order by 2
    into :idcli, :nomered, :regiao, :endereco, :endnum, :bairro, :cidade, :telefone
    do
    suspend;
  end
end^


ALTER PROCEDURE PROC_RELCLIENTES (
    IFLAG INTEGER,
    IDT1 DATE,
    IDT2 DATE,
    IFILTRO INTEGER,
    ATIVO CHAR(1))
RETURNS (
    CLI_CODIGO INTEGER,
    CLI_NOME TYPE OF COLUMN CLIENTES.CLI_NOME,
    CLI_FANTASIA TYPE OF COLUMN CLIENTES.CLI_FANTASIA,
    CLI_ENDERECO TYPE OF COLUMN CLIENTES.CLI_ENDERECO,
    CLI_BAIRRO TYPE OF COLUMN CLIENTES.CLI_BAIRRO,
    CLI_CIDADE TYPE OF COLUMN CLIENTES.CLI_CIDADE,
    CLI_CEP TYPE OF COLUMN CLIENTES.CLI_CEP,
    CLI_UF TYPE OF COLUMN CLIENTES.CLI_UF,
    CLI_TIPOPES TYPE OF COLUMN CLIENTES.CLI_TIPOPES,
    CLI_PTOREF TYPE OF COLUMN CLIENTES.CLI_PTOREF,
    CLI_CNPJ TYPE OF COLUMN CLIENTES.CLI_CNPJ,
    CLI_INSCRICAO TYPE OF COLUMN CLIENTES.CLI_INSCRICAO,
    CLI_FONE1 TYPE OF COLUMN CLIENTES.CLI_FONE1,
    CLI_FONE2 TYPE OF COLUMN CLIENTES.CLI_FONE2,
    CLI_FONE3 TYPE OF COLUMN CLIENTES.CLI_FONE3,
    CLI_ENDCOB TYPE OF COLUMN CLIENTES.CLI_ENDCOB,
    CLI_BAICOB TYPE OF COLUMN CLIENTES.CLI_BAICOB,
    CLI_CIDCOB TYPE OF COLUMN CLIENTES.CLI_CIDCOB,
    CLI_CEPCOB TYPE OF COLUMN CLIENTES.CLI_CEPCOB,
    CLI_UFCOB TYPE OF COLUMN CLIENTES.CLI_UFCOB,
    CLI_EMAIL TYPE OF COLUMN CLIENTES.CLI_EMAIL,
    CLI_REFCOME TYPE OF COLUMN CLIENTES.CLI_REFCOME,
    CLI_EMAILNFE TYPE OF COLUMN CLIENTES.CLI_EMAILNFE,
    CLI_IMP TYPE OF COLUMN CLIENTES.CLI_IMP,
    CLI_SUFRAMA TYPE OF COLUMN CLIENTES.CLI_SUFRAMA,
    CLI_VENCSUF TYPE OF COLUMN CLIENTES.CLI_VENCSUF,
    CLI_CAIXAPOSTAL TYPE OF COLUMN CLIENTES.CLI_CAIXAPOSTAL,
    CLI_OBS TYPE OF COLUMN CLIENTES.CLI_OBS,
    CLI_COMPENDERECO TYPE OF COLUMN CLIENTES.CLI_COMPENDERECO,
    CLI_ATUACAO TYPE OF COLUMN CLIENTES.CLI_ATUACAO,
    CLI_OBSPEDIDO TYPE OF COLUMN CLIENTES.CLI_OBSPEDIDO,
    CLI_EMAILFINANC TYPE OF COLUMN CLIENTES.CLI_EMAILFINANC,
    CLI_SKYPE TYPE OF COLUMN CLIENTES.CLI_SKYPE,
    CLI_NOMRED TYPE OF COLUMN CLIENTES.CLI_NOMRED,
    CLI_REGIMEEMP TYPE OF COLUMN CLIENTES.CLI_REGIMEEMP,
    CLI_REGIAO2 TYPE OF COLUMN CLIENTES.CLI_REGIAO2,
    CLI_VENDEDOR INTEGER,
    CLI_REGIAOATU VARCHAR(50),
    ANI_NIVER DATE,
    CLI_IDCIDADE INTEGER)
AS
begin
 if (iflag in ('0','1','2','4','5','6','7')) then
  begin
   if (ativo = 'A') then
    begin
     for
        with acompra as(select a.ani_cliente, left(list(distinct trim(a.ani_nome), '/'), 50) as comprador
                        from cli_aniv a
                        where a.ani_funcao like 'COMPRA%'
                        group by 1)

        select distinct cli_codigo, cli_nome, cli_fantasia, cli_endereco, cli_bairro, cli_cidade, cli_cep, cli_uf, cli_tipopes, cli_ptoref,
               cli_cnpj, cli_inscricao, cli_fone1, cli_fone2, cli_fone3, cli_endcob, cli_baicob, cli_cidcob, cli_cepcob, cli_ufcob,
               cli_email, cli_refcome, cli_emailnfe, cli_imp, cli_suframa, cli_vencsuf, cli_caixapostal, cli_obs,
               a.comprador,
               cli_atuacao, cli_obspedido, cli_emailfinanc, cli_skype, cli_nomred, cli_regimeemp, cli_regiao2, cli_vendedor,
               r.reg_descricao, c.cli_idcidade
               from clientes c
               left join regioes r on c.cli_regiao2 = r.reg_codigo
               left join acompra a on c.cli_codigo  = a.ani_cliente
               where cli_tipopes = :ativo
        into
               :cli_codigo, :cli_nome, :cli_fantasia, :cli_endereco, :cli_bairro, :cli_cidade, :cli_cep, :cli_uf, :cli_tipopes, :cli_ptoref,
               :cli_cnpj, :cli_inscricao, :cli_fone1, :cli_fone2, :cli_fone3, :cli_endcob, :cli_baicob, :cli_cidcob, :cli_cepcob, :cli_ufcob,
               :cli_email, :cli_refcome, :cli_emailnfe, :cli_imp, :cli_suframa, :cli_vencsuf, :cli_caixapostal, :cli_obs, :cli_compendereco,
               :cli_atuacao, :cli_obspedido, :cli_emailfinanc, :cli_skype, :cli_nomred, :cli_regimeemp, :cli_regiao2, :cli_vendedor,
               :cli_regiaoatu, :cli_idcidade
     do
     suspend;
    end
   if (ativo = 'I') then
    begin
      for
        with inatividade as
             (select p.ped_cliente, max(p.ped_data) ultcompra
              from pedidos p
              join clientes c1 on p.ped_cliente = c1.cli_codigo
              where c1.cli_tipopes = 'A' and
                    p.ped_situacao in ('P','F')
              group by p.ped_cliente
              having max(p.ped_data) <= (current_date - 90)
              order by 1
             )
        ,
             acompra as(select a.ani_cliente, left(list(distinct trim(a.ani_nome), '/'), 50) as comprador
                        from cli_aniv a
                        where a.ani_funcao like 'COMPRA%'
                        group by 1)

        select distinct cli_codigo, cli_nome, cli_fantasia, cli_endereco, cli_bairro, cli_cidade, cli_cep, cli_uf, cli_tipopes, cli_ptoref,
               cli_cnpj, cli_inscricao, cli_fone1, cli_fone2, cli_fone3, cli_endcob, cli_baicob, cli_cidcob, cli_cepcob, cli_ufcob,
               cli_email, cli_refcome, cli_emailnfe, cli_imp, cli_suframa, cli_vencsuf, cli_caixapostal, cli_obs,
               a.comprador,
               cli_atuacao, cli_obspedido, cli_emailfinanc, cli_skype, cli_nomred, cli_regimeemp, cli_regiao2, cli_vendedor,
               r.reg_descricao
               from clientes c
               join inatividade  i on c.cli_codigo = i.ped_cliente
               left join regioes r on c.cli_regiao2 = r.reg_codigo
               left join acompra a on c.cli_codigo  = a.ani_cliente
        into
               :cli_codigo, :cli_nome, :cli_fantasia, :cli_endereco, :cli_bairro, :cli_cidade, :cli_cep, :cli_uf, :cli_tipopes, :cli_ptoref,
               :cli_cnpj, :cli_inscricao, :cli_fone1, :cli_fone2, :cli_fone3, :cli_endcob, :cli_baicob, :cli_cidcob, :cli_cepcob, :cli_ufcob,
               :cli_email, :cli_refcome, :cli_emailnfe, :cli_imp, :cli_suframa, :cli_vencsuf, :cli_caixapostal, :cli_obs, :cli_compendereco,
               :cli_atuacao, :cli_obspedido, :cli_emailfinanc, :cli_skype, :cli_nomred, :cli_regimeemp, :cli_regiao2, :cli_vendedor,
               :cli_regiaoatu
     do
     suspend;
    end
  end
 if (iflag = 3) then -- clientes que compraram no periodo
  begin
     for
        select cli_codigo, cli_nome, cli_fantasia, cli_endereco, cli_bairro, cli_cidade, cli_cep, cli_uf, cli_tipopes, cli_ptoref,
               cli_cnpj, cli_inscricao, cli_fone1, cli_fone2, cli_fone3, cli_endcob, cli_baicob, cli_cidcob, cli_cepcob, cli_ufcob,
               cli_email, cli_refcome, cli_emailnfe, cli_imp, cli_suframa, cli_vencsuf, cli_caixapostal, cli_obs, c.cli_compendereco,
               cli_atuacao, cli_obspedido, cli_emailfinanc, cli_skype, cli_nomred, cli_regimeemp, cli_regiao2, cli_vendedor,
               r.reg_descricao
               from clientes c
               join pedidos       p on c.cli_codigo = p.ped_cliente
               left join regioes  r on c.cli_regiao2 = r.reg_codigo
               where cli_tipopes = :ativo and
                     p.ped_data between :idt1 and :idt2 and
                     p.ped_situacao in ('P','F')
        into
               :cli_codigo, :cli_nome, :cli_fantasia, :cli_endereco, :cli_bairro, :cli_cidade, :cli_cep, :cli_uf, :cli_tipopes, :cli_ptoref,
               :cli_cnpj, :cli_inscricao, :cli_fone1, :cli_fone2, :cli_fone3, :cli_endcob, :cli_baicob, :cli_cidcob, :cli_cepcob, :cli_ufcob,
               :cli_email, :cli_refcome, :cli_emailnfe, :cli_imp, :cli_suframa, :cli_vencsuf, :cli_caixapostal, :cli_obs, :cli_compendereco,
               :cli_atuacao, :cli_obspedido, :cli_emailfinanc, :cli_skype, :cli_nomred, :cli_regimeemp, :cli_regiao2, :cli_vendedor,
               :cli_regiaoatu
     do
     suspend;
  end
 if (iflag = 8) then -- clientes por area de atuacao
  begin
     for
        select cli_codigo, cli_nome, cli_fantasia, cli_endereco, cli_bairro, cli_cidade, cli_cep, cli_uf, cli_tipopes, cli_ptoref,
               cli_cnpj, cli_inscricao, cli_fone1, cli_fone2, cli_fone3, cli_endcob, cli_baicob, cli_cidcob, cli_cepcob, cli_ufcob,
               cli_email, cli_refcome, cli_emailnfe, cli_imp, cli_suframa, cli_vencsuf, cli_caixapostal, cli_obs,
               cli_atuacao, cli_obspedido, cli_emailfinanc, cli_skype, cli_nomred, cli_regimeemp, cli_regiao2, cli_vendedor,
               cli_nomred reg_descricao, c.cli_datacad ani_niver,
               (select coalesce(left(list(distinct trim(a.ani_nome), '/'), 50), '') as comprador
                        from cli_aniv a
                        where a.ani_funcao like 'COMPRA%' and
                              a.ani_cliente = c.cli_codigo)
               from clientes c
               join atua_cli     t on c.cli_codigo  = t.atu_idcli
               where cli_tipopes = :ativo and
                     c.cli_atuacaoprincipal = :ifiltro  --t.atu_atuaid = :ifiltro
        into
               :cli_codigo, :cli_nome, :cli_fantasia, :cli_endereco, :cli_bairro, :cli_cidade, :cli_cep, :cli_uf, :cli_tipopes, :cli_ptoref,
               :cli_cnpj, :cli_inscricao, :cli_fone1, :cli_fone2, :cli_fone3, :cli_endcob, :cli_baicob, :cli_cidcob, :cli_cepcob, :cli_ufcob,
               :cli_email, :cli_refcome, :cli_emailnfe, :cli_imp, :cli_suframa, :cli_vencsuf, :cli_caixapostal, :cli_obs,
               :cli_atuacao, :cli_obspedido, :cli_emailfinanc, :cli_skype, :cli_nomred, :cli_regimeemp, :cli_regiao2, :cli_vendedor,
               :cli_regiaoatu, :ani_niver, :cli_compendereco
     do
     suspend;
  end
 if (iflag = 9) then -- clientes por industria
  begin
     for
        select distinct
               cli_codigo, cli_nome, cli_fantasia, cli_endereco, cli_bairro, cli_cidade, cli_cep, cli_uf, cli_tipopes, cli_ptoref,
               cli_cnpj, cli_inscricao, cli_fone1, cli_fone2, cli_fone3, cli_endcob, cli_baicob, cli_cidcob, cli_cepcob, cli_ufcob,
               cli_email, cli_refcome, cli_emailnfe, cli_imp, cli_suframa, cli_vencsuf, cli_caixapostal, cli_obs, c.cli_compendereco,
               cli_atuacao, cli_obspedido, cli_emailfinanc, cli_skype, cli_nomred, cli_regimeemp, cli_regiao2, cli_vendedor,
               r.reg_descricao
               from clientes c
               join pedidos       p on c.cli_codigo = p.ped_cliente
               left join regioes  r on c.cli_regiao2 = r.reg_codigo
               where cli_tipopes = :ativo and
                     p.ped_industria = :ifiltro and
                     p.ped_situacao in ('P','F')
        into
               :cli_codigo, :cli_nome, :cli_fantasia, :cli_endereco, :cli_bairro, :cli_cidade, :cli_cep, :cli_uf, :cli_tipopes, :cli_ptoref,
               :cli_cnpj, :cli_inscricao, :cli_fone1, :cli_fone2, :cli_fone3, :cli_endcob, :cli_baicob, :cli_cidcob, :cli_cepcob, :cli_ufcob,
               :cli_email, :cli_refcome, :cli_emailnfe, :cli_imp, :cli_suframa, :cli_vencsuf, :cli_caixapostal, :cli_obs, :cli_compendereco,
               :cli_atuacao, :cli_obspedido, :cli_emailfinanc, :cli_skype, :cli_nomred, :cli_regimeemp, :cli_regiao2, :cli_vendedor,
               :cli_regiaoatu
     do
     suspend;
  end

 if (iflag = 100) then --ficha do cliente
  begin
     for
        select cli_codigo, cli_nome, cli_fantasia, cli_endereco, cli_bairro, cli_cidade, cli_cep, cli_uf, cli_tipopes, cli_ptoref,
               cli_cnpj, cli_inscricao, cli_fone1, cli_fone2, cli_fone3, cli_endcob, cli_baicob, cli_cidcob, cli_cepcob, cli_ufcob,
               cli_email, cli_refcome, cli_emailnfe, cli_imp, cli_suframa, cli_vencsuf, cli_caixapostal, cli_obs, cli_compendereco,
               cli_atuacao, cli_obspedido, cli_emailfinanc, cli_skype, cli_nomred, cli_regimeemp, cli_regiao2, cli_vendedor,
               r.reg_descricao, c.cli_datacad ani_niver
               from clientes c
               left join regioes r on c.cli_regiao2 = r.reg_codigo
               where c.cli_codigo = :ifiltro and
                     cli_tipopes = :ativo
        into
               :cli_codigo, :cli_nome, :cli_fantasia, :cli_endereco, :cli_bairro, :cli_cidade, :cli_cep, :cli_uf, :cli_tipopes, :cli_ptoref,
               :cli_cnpj, :cli_inscricao, :cli_fone1, :cli_fone2, :cli_fone3, :cli_endcob, :cli_baicob, :cli_cidcob, :cli_cepcob, :cli_ufcob,
               :cli_email, :cli_refcome, :cli_emailnfe, :cli_imp, :cli_suframa, :cli_vencsuf, :cli_caixapostal, :cli_obs, :cli_compendereco,
               :cli_atuacao, :cli_obspedido, :cli_emailfinanc, :cli_skype, :cli_nomred, :cli_regimeemp, :cli_regiao2, :cli_vendedor,
               :cli_regiaoatu, :ani_niver
     do
     suspend;
  end

end^


ALTER PROCEDURE PROC_RELCLIIND (
    IFOR INTEGER,
    IVEND INTEGER)
RETURNS (
    CLI_NOME VARCHAR(75),
    CLI_FONE1 VARCHAR(20),
    CLI_CIDADE VARCHAR(25),
    CLI_EMAIL VARCHAR(200),
    CLI_CNPJ VARCHAR(18),
    TOTAL DOUBLE PRECISION,
    DATA DATE)
AS
declare variable IVEND2 integer;
begin
  ivend2 = ivend;
  if (ivend = 0) then
   begin
     ivend = 1;
     ivend2 = 999;
   end

 for
    select distinct c.cli_nome, c.cli_fone1,
           c.cli_cidade, c.cli_email, c.cli_cnpj,
           sum(ped_totliq) over(partition by p.ped_cliente) total,
           max(p.ped_data) over(partition by p.ped_cliente) data
    from pedidos p
    join clientes c on p.ped_cliente = c.cli_codigo
    join vendedores v on p.ped_vendedor = v.ven_codigo
    where cli_tipopes     = 'A' and
          p.ped_industria = :ifor and
          p.ped_vendedor  between :ivend and :ivend2 and
          p.ped_situacao in ('P','F')
    order by c.cli_cidade, c.cli_nome
    into :cli_nome, :cli_fone1, :cli_cidade, :cli_email, :cli_cnpj, :total, :data
 do
 suspend;
end^


ALTER PROCEDURE PROC_RELFATPENDENDE (
    IFOR INTEGER,
    IFLAG BOOLEAN)
RETURNS (
    FAT_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    PED_TOTLIQ DOUBLE PRECISION,
    CLI_NOMRED VARCHAR(30),
    FOR_NOMERED VARCHAR(15),
    FATURADO DOUBLE PRECISION,
    PED_CONDPAG VARCHAR(100))
AS
begin
if (iflag) then
 begin
     for
        with fats as (select ft.fat_pedido,
                             ft.fat_datafat,
                             sum(ft.fat_valorfat) over(partition by ft.fat_pedido) faturado
                      from fatura_ped ft
                      where ft.fat_industria = :ifor
                      order by 1)
        
        
        select t.fat_pedido,
               p.ped_data,
               p.ped_totliq,
               c.cli_nomred,
               f.for_nomered,
               t.faturado,
               p.ped_condpag
        from pedidos p
        join fornecedores f on p.ped_industria =  f.for_codigo
        join clientes     c on p.ped_cliente   =  c.cli_codigo
        join fats         t on p.ped_pedido   =  t.fat_pedido
        where p.ped_situacao = 'P'    and
              p.ped_industria = :ifor and
              p.ped_totliq > t.faturado
        order by f.for_nomered, t.fat_pedido
        into :fat_pedido, :ped_data, :ped_totliq, :cli_nomred, :for_nomered, :faturado, :ped_condpag
     do
     suspend;
 end
if (not iflag) then
 begin
     for
        with fats as (select ft.fat_pedido,
                             ft.fat_datafat,
                             sum(ft.fat_valorfat) over(partition by ft.fat_pedido) faturado
                      from fatura_ped ft
                      where ft.fat_industria = :ifor
                      order by 1)
        
        
        select t.fat_pedido,
               p.ped_data,
               p.ped_totliq,
               c.cli_nomred,
               f.for_nomered,
               t.faturado,
               p.ped_condpag
        from pedidos p
        join fornecedores f on p.ped_industria =  f.for_codigo
        join clientes     c on p.ped_cliente   =  c.cli_codigo
        join fats         t on p.ped_pedido   =  t.fat_pedido
        where p.ped_situacao in ('F', 'P') and
              p.ped_industria = :ifor and
              p.ped_totliq > t.faturado
        order by f.for_nomered, t.fat_pedido
        into :fat_pedido, :ped_data, :ped_totliq, :cli_nomred, :for_nomered, :faturado, :ped_condpag
     do
     suspend;
 end

end^


ALTER PROCEDURE PROC_RELFATURAMENTOS (
    IFOR INTEGER,
    IVEN INTEGER,
    IDT1 DATE,
    IDT2 DATE)
RETURNS (
    VEN_NOME VARCHAR(45),
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    FAT_PEDIDO VARCHAR(10),
    FAT_DATAFAT DATE,
    FAT_VALORFAT DOUBLE PRECISION,
    FAT_NF VARCHAR(10),
    FAT_PERCENT DOUBLE PRECISION,
    FAT_COMISSAO DOUBLE PRECISION,
    PED_TOTLIQ DOUBLE PRECISION,
    PED_DATA DATE)
AS
declare variable IFOR2 integer;
declare variable IVEN2 integer;
begin
  iven2 = iven;
  ifor2 = ifor;
  if (ifor = 0) then
   begin
     ifor = 1;
     ifor2 = 9999;
   end
  if (iven = 0) then
   begin
     iven = 1;
     iven2 = 999;
   end
  for
    with fat as(select f2.fat_pedido,
                       f2.fat_industria,
                       f2.fat_valorfat,
                       f2.fat_nf,
                       f2.fat_datafat,
                       f2.fat_percent,
                       f2.fat_comissao,
                       fr.for_nomered
                       from fatura_ped f2
                       join fornecedores fr on f2.fat_industria = fr.for_codigo
                       where f2.fat_datafat between :idt1 and :idt2 and
                             f2.fat_industria between :ifor and :ifor2
                       order by 1
                       )
    
    select v.ven_nome,
           f.for_nomered,
           c.cli_nomred,
           f.fat_pedido,
           f.fat_datafat,
           f.fat_valorfat,
           f.fat_nf,
           f.fat_percent,
           f.fat_comissao,
           p.ped_totliq,
           p.ped_data
    from fat f
    join pedidos      p on p.ped_pedido    = f.fat_pedido and p.ped_industria = f.fat_industria
    join vendedores   v on p.ped_vendedor  = v.ven_codigo
    join clientes     c on p.ped_cliente   = c.cli_codigo
    where p.ped_vendedor between :iven and :iven2
    order by for_nomered, p.ped_data
    into :ven_nome, :for_nomered, :cli_nomred, :fat_pedido, :fat_datafat, :fat_valorfat, :fat_nf, :fat_percent, :fat_comissao, :ped_totliq, :ped_data
  do
  suspend;
end^


ALTER PROCEDURE PROC_RELITENS (
    IFOR INTEGER,
    ITABELA VARCHAR(20))
RETURNS (
    PRO_CODIGO INTEGER,
    PRO_CODPROD VARCHAR(25),
    PRO_CODORIGINAL VARCHAR(40),
    PRO_NOME VARCHAR(100),
    PRO_VALORNORMAL DOUBLE PRECISION,
    PRO_VALORPROMO DOUBLE PRECISION,
    PRO_INDUSTRIA INTEGER,
    PRO_PRECO3 DOUBLE PRECISION,
    ITE_CONVERSAO VARCHAR(300),
    PRO_IPI DOUBLE PRECISION,
    PRO_ST DOUBLE PRECISION,
    PRE_LIQ DOUBLE PRECISION,
    PRO_APLICACAO2 VARCHAR(800),
    PRO_EMBALAGEM INTEGER)
AS
begin
 for
    select p.pro_codigo, p.pro_codprod, p.pro_codoriginal, p.pro_nome,
           p.pro_valornormal, p.pro_valorpromo, p.pro_industria,
           p.pro_preco3, p.ite_conversao, p.pro_ipi, p.pro_st, p.pro_aplicacao2, p.pro_embalagem,
           (select resultado from sp_calliqprod(pro_valornormal, 0,0,0,0,0,0,0,0,0)) pre_liq
    from produtos p
    where p.pro_industria = :iFor and p.pro_nometabela = :itabela
    order by p.pro_codprod
    into :pro_codigo, :pro_codprod, :pro_codoriginal, :pro_nome,
         :pro_valornormal, :pro_valorpromo, :pro_industria,
         :pro_preco3, :ite_conversao, :pro_ipi, :pro_st,
         :pro_aplicacao2, :pro_embalagem, :pre_liq
 do
 suspend;
end^


ALTER PROCEDURE PROC_RELITENSCOMDESCONTO (
    IFOR INTEGER,
    ITABELA VARCHAR(20),
    IDES1 DOUBLE PRECISION,
    IDES2 DOUBLE PRECISION,
    IDES3 DOUBLE PRECISION,
    IDES4 DOUBLE PRECISION,
    IDES5 DOUBLE PRECISION,
    IDES6 DOUBLE PRECISION,
    IDES7 DOUBLE PRECISION,
    IDES8 DOUBLE PRECISION,
    IDES9 DOUBLE PRECISION)
RETURNS (
    PRO_CODIGO INTEGER,
    PRO_CODPROD VARCHAR(25),
    PRO_CODORIGINAL VARCHAR(40),
    PRO_NOME VARCHAR(100),
    PRO_VALORNORMAL DOUBLE PRECISION,
    PRO_VALORPROMO DOUBLE PRECISION,
    PRO_INDUSTRIA INTEGER,
    PRO_PRECO3 DOUBLE PRECISION,
    ITE_CONVERSAO VARCHAR(300),
    PRO_IPI DOUBLE PRECISION,
    PRO_ST DOUBLE PRECISION,
    PRE_LIQ DOUBLE PRECISION,
    PRO_APLICACAO2 VARCHAR(800),
    PRO_EMBALAGEM INTEGER)
AS
begin
 for
    select p.pro_codigo, p.pro_codprod, p.pro_codoriginal, p.pro_nome,
           p.pro_valornormal, p.pro_valorpromo, p.pro_industria,
           p.pro_preco3, p.ite_conversao, p.pro_ipi, p.pro_st, p.pro_aplicacao2, p.pro_embalagem,
           (select resultado from sp_calliqprod(pro_valornormal, :ides1,:ides2,:ides3,:ides4,:ides5,:ides6,:ides7,:ides8,:ides9)) pre_liq
    from produtos p
    where p.pro_industria = :iFor and p.pro_nometabela = :itabela
    order by p.pro_codprod
    into :pro_codigo, :pro_codprod, :pro_codoriginal, :pro_nome,
         :pro_valornormal, :pro_valorpromo, :pro_industria,
         :pro_preco3, :ite_conversao, :pro_ipi, :pro_st,
         :pro_aplicacao2, :pro_embalagem, :pre_liq
 do
 suspend;
end^


ALTER PROCEDURE PROC_RELPRODPED (
    IFOR INTEGER,
    ITAB VARCHAR(20))
RETURNS (
    ID INTEGER,
    CODIND INTEGER,
    CODIGO VARCHAR(25),
    CONVERSAO VARCHAR(300),
    NOME VARCHAR(100),
    PRECO1 DOUBLE PRECISION,
    PRECO2 DOUBLE PRECISION,
    PRECO3 DOUBLE PRECISION,
    DATATAB DATE,
    EMBALAGEM INTEGER,
    DATAPROMO DATE,
    IPI DOUBLE PRECISION,
    CODIGO2 VARCHAR(25),
    LINHA VARCHAR(50),
    GRUPODES INTEGER,
    DESCADIC DOUBLE PRECISION,
    ST DOUBLE PRECISION,
    GRUPOPRO INTEGER,
    NOMETABELA VARCHAR(20),
    DESCADIC2 DOUBLE PRECISION,
    PESO DOUBLE PRECISION,
    PREPESO DOUBLE PRECISION,
    STATUS CHAR(1),
    APLICACAO VARCHAR(800))
AS
begin
 for
  select p.pro_codigo, p.pro_industria, p.pro_codprod, p.ite_conversao, p.pro_nome, p.pro_valornormal, p.pro_valorpromo, p.pro_preco3,
         p.pro_datatabela, p.pro_embalagem, p.pro_vencpromocao, p.pro_ipi, p.ite_codigo2, p.pro_linha, p.pro_grupo, p.pro_descadic, p.pro_st,
         p.pro_grupopro, p.pro_nometabela, p.pro_descadic2, p.ite_peso, p.ite_prepeso, left(p.pro_setor,1), p.pro_aplicacao2

  from produtos p
  where p.pro_industria = :ifor and p.pro_nometabela = :itab
  into
  :id, :codind, :codigo, :conversao, :nome, :preco1, :preco2, :preco3, :datatab, :embalagem, :datapromo, :ipi, :codigo2, :linha, :grupodes, :descadic,
  :st, :grupopro, :nometabela, :descadic2, :peso, :prepeso, :status, :aplicacao
 do
 suspend;
end^


ALTER PROCEDURE PROC_RELTELEPORIND (
    XDATA1 DATE,
    XDATA2 DATE,
    XIND1 INTEGER,
    XOPE INTEGER)
RETURNS (
    AGE_LANCTO INTEGER,
    AGE_DATA DATE,
    AGE_CLIENTE INTEGER,
    AGE_HORARIO VARCHAR(5),
    AGE_STATUS VARCHAR(1),
    AGE_OBS VARCHAR(1800),
    AGE_INDUSTRIA INTEGER,
    AGE_TELEFONE VARCHAR(35),
    AGE_CONTATO VARCHAR(35),
    AGE_OPERADOR VARCHAR(35),
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    CLI_CIDADE VARCHAR(25),
    CLI_CNPJ VARCHAR(18),
    CLI_FONE1 VARCHAR(20),
    METACOMPLETADA DOUBLE PRECISION,
    LIGACOES INTEGER,
    METAIND INTEGER)
AS
declare variable XIND2 integer;
declare variable XMETA integer;
declare variable XMESANO varchar(10);
declare variable XOPE2 integer;
begin

  /* busca o ultimo dia do mes informado no xdata2 */
  select dateadd(-extract(day from dateadd(1 month to :xdata2 )) day to dateadd(1 month to :xdata2)) ultimo_dia
  from rdb$database
  into :xmesano;

  ligacoes = 1;
  xind2 = xind1;
  xope2 = xope;
  xmeta = 1;
  if (xind1 = 0) then
   begin
    xind1 = 0;
    xind2 = 9999;
   end
  if (xope = 0) then
   begin
    xope = 1;
    xope2 = 999;
   end

  select first 1 met_metatelemkt
  from metasind m
  where m.met_industria = :xind1 and m.met_data = :xmesano
  order by met_mesano
  into :xmeta;

  for
    select age_lancto, age_data, age_cliente, age_horario, age_status, age_assunto,  age_industria,
    age_telefone, age_contato, age_operador, f.for_nomered, c.cli_nomred, c.cli_cidade, c.cli_cnpj, 
    c.cli_fone1
    from crm_interacoes a
    join crm cr on a.age_cliente = cr.tele_cliente
    left join fornecedores f on a.age_industria = f.for_codigo
    join clientes     c on a.age_cliente   = c.cli_codigo
    where age_industria between :xInd1 and :xInd2 and
          age_data between :xdata1 and :xdata2 and
          cr.tele_idoperador between :xope and :xope2
    order by age_industria, age_data, age_horario
    into :age_lancto, :age_data, :age_cliente, :age_horario, :age_status, :age_obs,  :age_industria,
         :age_telefone, :age_contato, :age_operador, :for_nomered, :cli_nomred, :cli_cidade, :cli_cnpj,
         :cli_fone1
  do
  begin
   ligacoes       = ligacoes + 1;
   metacompletada = (ligacoes * 100) / xmeta;
   metaind        = :xmeta;
  suspend;
  end



end^


ALTER PROCEDURE PROC_RELVENDAS (
    IFOR INTEGER,
    ICLI INTEGER,
    IVEND INTEGER,
    IDATA1 DATE,
    IDATA2 DATE,
    IFLAG CHAR(1))
RETURNS (
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    FOR_NOME VARCHAR(75),
    CLI_NOME VARCHAR(50),
    PED_TOTLIQ DOUBLE PRECISION,
    VALORFAT DOUBLE PRECISION,
    PED_TOTBRUTO DOUBLE PRECISION,
    CLI_CIDADE VARCHAR(25),
    CLI_UF VARCHAR(2),
    NUMPEDCLI VARCHAR(15),
    NUMPEDIND VARCHAR(15))
AS
declare variable ICLI2 integer;
declare variable IVEND2 integer;
declare variable IFOR2 integer;
begin
  ifor2  = ifor;
  icli2  = icli;
  ivend2 = ivend;

  if (ifor = 0) then
   begin
     ifor = 1;
     ifor2 = 9999;
   end

  if (icli = 0) then
   begin
     icli = 1;
     icli2 = 9999;
   end

  if (ivend = 0) then
   begin
     ivend = 1;
     ivend2 = 99;
   end

  if (iflag = 'P') then --pedidos e faturados
   begin
      for
        select distinct
               p.ped_pedido,
               p.ped_data,
               f.for_nomered,
               left(c.cli_nome,50),
               p.ped_totliq,
               c.cli_cidade,
               c.cli_uf,
               p.ped_totbruto,
               sum(t.fat_valorfat) over(partition by p.ped_pedido),
               p.ped_cliind, p.ped_nffat
        from pedidos p
        left join clientes     c on p.ped_cliente   = c.cli_codigo
        left join vendedores        v on p.ped_vendedor  = v.ven_codigo
        join fornecedores      f on p.ped_industria = f.for_codigo
        left join fatura_ped   t on p.ped_pedido    = t.fat_pedido and p.ped_industria = t.fat_industria
        where p.ped_industria  between :ifor and :ifor2 and
              p.ped_data       between :idata1 and :idata2 and
              p.ped_situacao   in ('P','F') and
              p.ped_vendedor   between :ivend and :ivend2 and
              p.ped_cliente    between :icli and :icli2
    
        order by f.for_nomered, p.ped_data
        into :ped_pedido, :ped_data, :for_nome, :cli_nome, :ped_totliq, :cli_cidade, :cli_uf, :ped_totbruto, :valorfat,
             :numpedcli, :numpedind
      do
      suspend;
   end
  if (iflag = 'C') then --cotacoes pendente
   begin
      for
        select distinct
               p.ped_pedido,
               p.ped_data,
               f.for_nomered,
               left(c.cli_nome,50),
               p.ped_totliq,
               c.cli_cidade,
               c.cli_uf,
               p.ped_totbruto,
               sum(t.fat_valorfat) over(partition by p.ped_pedido),
               p.ped_cliind, p.ped_nffat
        from pedidos p
        left join clientes     c on p.ped_cliente   = c.cli_codigo
        join vendedores        v on p.ped_vendedor  = v.ven_codigo
        join fornecedores      f on p.ped_industria = f.for_codigo
        left join fatura_ped   t on p.ped_pedido    = t.fat_pedido and p.ped_industria = t.fat_industria
        where p.ped_industria  between :ifor and :ifor2 and
              p.ped_data       between :idata1 and :idata2 and
              p.ped_situacao   = 'C' and
              p.ped_vendedor   between :ivend and :ivend2 and
              p.ped_cliente    between :icli and :icli2
    
        order by f.for_nomered, p.ped_data
        into :ped_pedido, :ped_data, :for_nome, :cli_nome, :ped_totliq, :cli_cidade, :cli_uf, :ped_totbruto, :valorfat,
             :numpedcli, :numpedind
      do
      suspend;
   end

  if (iflag = 'S') then --sint?tico
   begin
      for
        select max(p.ped_pedido),
               max(p.ped_data),
               f.for_nomered,
               max(left(c.cli_nomred,50)),
               sum(p.ped_totliq),
               max(c.cli_cidade),
               max(c.cli_uf),
               sum(p.ped_totbruto),
               sum(t.fat_valorfat)
        from pedidos p
        left join clientes     c on p.ped_cliente   = c.cli_codigo
        left join vendedores        v on p.ped_vendedor  = v.ven_codigo
        join fornecedores      f on p.ped_industria = f.for_codigo
        left join fatura_ped   t on p.ped_pedido    = t.fat_pedido and p.ped_industria = t.fat_industria
        where p.ped_data       between :idata1 and :idata2 and
              p.ped_situacao   in ('P','F')
        group by 3
        order by 5 desc
        into :ped_pedido, :ped_data, :for_nome, :cli_nome, :ped_totliq, :cli_cidade, :cli_uf, :ped_totbruto, :valorfat
      do
      suspend;
   end

end^


ALTER PROCEDURE PROC_RETIRALETRASCOD (
    PTEXTO VARCHAR(20))
RETURNS (
    OLIMPO VARCHAR(20))
AS
begin
 with recursive r as (
  select
   substring(a.texto from 1 for 1) letra,
   substring(a.texto from 2) restante
   from (select cast(:pTexto as varchar(20)) texto from rdb$database) a

  union all

  select
   substring(r.restante from 1 for 1) letra,
   substring(r.restante from 2) restante
   from r
   where r.restante <> '' )

 select trim(list(r.letra, ''))
 from r
 where r.letra between '0' and '9'
 into :olimpo;

 suspend;

end^


ALTER PROCEDURE PROC_SELLOUT (
    IFOR INTEGER,
    IANO INTEGER,
    ICLI INTEGER)
RETURNS (
    ROTINA VARCHAR(20),
    VALOR DOUBLE PRECISION,
    QUANT INTEGER,
    MES DATE)
AS
begin
  for
    select 'SI - SellIn   ',
          sum(i.ite_totliquido) valor,
          sum(i.ite_quant) quant,
          last_day(of month from p.ped_data) mes
    from itens_ped i
    join pedidos p on i.ite_pedido = p.ped_pedido
    where p.ped_industria = :ifor and
          p.ped_cliente   = :icli and
          extract(year from p.ped_data) = :iano and
          p.ped_situacao in ('P', 'F')
    group by 1,4

    union

    select 'SO - Previsto ',
           s1.so_metavalor valor,
           s1.so_metaqtd quant,
           s1.so_mesext mes
    from sellout s1
    where s1.so_industria = :ifor and
          s1.so_cliente   = :icli and
          extract(year from s1.so_mesext) = :iano
    
    union
    
    select 'SO - Realizado',
           s2.so_venda_valor valor,
           s2.so_venda_qtd quant,
           s2.so_mesext mes
    from sellout s2
    where s2.so_industria = :ifor and
          s2.so_cliente   = :icli and
          extract(year from s2.so_mesext) = :iano
    order by 1,4
    into :rotina, :valor, :quant, :mes
  do
  suspend;
end^


ALTER PROCEDURE PROC_SOMATOTAIS (
    IFOR INTEGER,
    IPED VARCHAR(10))
AS
declare variable VALBRU double precision;
declare variable VALLIQ double precision;
declare variable VALIPI double precision;
declare variable VTOTBRU2 double precision;
declare variable VLIQ2 double precision;
declare variable VTOTCOMIPI double precision;
begin
 vtotbru2   = 0;
 vliq2      = 0;
 vtotcomipi = 0;
 for
  select i.ite_totbruto, i.ite_totliquido, i.ite_valcomipi
  from itens_ped i
  where i.ite_industria = :ifor and i.ite_pedido = :iped
  into :valbru, :valliq, :valipi
 do
 begin
   vtotbru2 = vtotbru2 + :valbru;
   vliq2    = vliq2    + :valliq;
   vtotcomipi = vtotcomipi + :valipi;
 end
 in autonomous transaction do
 begin
  update pedidos set ped_totbruto = :vtotbru2, ped_totliq = :vliq2, ped_totalipi = :vtotcomipi
  where ped_pedido = :iped and ped_industria = :ifor;
 end
end^


ALTER PROCEDURE PROC_TRANSPORTADORA (
    IPESQ VARCHAR(60))
RETURNS (
    ID INTEGER,
    NOME VARCHAR(60),
    TELEFONE VARCHAR(15),
    CIDADE VARCHAR(25))
AS
begin
 ipesq = Upper(ipesq);
 if (ipesq is null) then ipesq = '';
 if (char_length(ipesq) = 0) then
  begin
     for
      select t.codigo, t.nome, t.telefone1, t.cidade
      from transportadora t
      order by nome
      into :id, :nome, :telefone, :cidade
     do
      suspend;
  end
 if (char_length(ipesq) > 0) then
  begin
     for
      select t.codigo, t.nome, t.telefone1, t.cidade
      from transportadora t
      where Upper(t.nome) like '%'||:ipesq||'%'
      order by nome
      into :id, :nome, :telefone, :cidade
     do
      suspend;
  end

end^


ALTER PROCEDURE PROC_VENDAPROD (
    IFOR INTEGER,
    ICLI INTEGER,
    IVEND INTEGER,
    IPROD VARCHAR(25),
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    ITE_PRODUTO VARCHAR(25),
    ITE_NOMEPROD VARCHAR(100),
    ITE_EMBUCH VARCHAR(15),
    QUANT DOUBLE PRECISION,
    PRECO DOUBLE PRECISION,
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    CLI_NOMRED VARCHAR(30),
    PRECOLIQ DOUBLE PRECISION)
AS
declare variable ICLI2 integer;
declare variable IVEND2 integer;
begin
  icli2  = icli;
  ivend2 = ivend;

  if (icli = 0) then
   begin
    icli  = 1;
    icli2 = 9999;
   end
  if (ivend = 0) then
   begin
    ivend  = 1;
    ivend2 = 9999;
   end
  if (char_length(iprod) = 0) then
   begin
      for
        select distinct
               i.ite_produto,
               i.ite_nomeprod,
               p.ped_pedido,
               p.ped_data,
               c.cli_nomred,
               max(i.ite_embuch) over(partition by i.ite_produto, ite_pedido) ite_embuch,
               sum(ite_quant) over(partition by i.ite_produto, ite_pedido) quant,
               max(ite_puni)  over(partition by i.ite_produto, ite_pedido) preco,
               max(i.ite_puniliq) over(partition by i.ite_produto, ite_pedido)

           from itens_ped i
           join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
           join clientes c on p.ped_cliente = c.cli_codigo
           where p.ped_situacao in ('P','F') and
                 p.ped_industria = :ifor and
                 p.ped_data between :idata1 and :idata2 and
                 p.ped_cliente between :icli and :icli2 and
                 p.ped_vendedor between :ivend and :ivend2
           order by c.cli_nomred, i.ite_produto
        into :ite_produto, :ite_nomeprod, :ped_pedido, :ped_data, :cli_nomred, :ite_embuch, :quant, :preco, :precoliq
      do
      suspend;
   end
  if (char_length(iprod) > 0) then
   begin
      for
        select i.ite_produto,
               i.ite_nomeprod,
               p.ped_pedido,
               p.ped_data,
               c.cli_nomred,
               i.ite_pedido ite_embuch,
               ite_quant quant,
               ite_puni preco,
               ite_puniliq
    
           from itens_ped i
           join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
           join clientes c on p.ped_cliente = c.cli_codigo
           where p.ped_situacao in ('P','F') and
                 p.ped_industria = :ifor and
                 p.ped_data between :idata1 and :idata2 and
                 p.ped_cliente between :icli and :icli2 and
                 p.ped_vendedor between :ivend and :ivend2 and
                 i.ite_produto = :iprod
           order by c.cli_nomred, i.ite_produto
        into :ite_produto, :ite_nomeprod, :ped_pedido, :ped_data, :cli_nomred, :ite_embuch, :quant, :preco, :precoliq
      do
      suspend;
   end
end^


ALTER PROCEDURE PROC_VENDAPRODGRP (
    IFOR INTEGER,
    ICLI INTEGER,
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    ITE_PRODUTO VARCHAR(25),
    ITE_NOMEPROD VARCHAR(100),
    QUANT DOUBLE PRECISION,
    PRECO DOUBLE PRECISION,
    GRU_NOME VARCHAR(50))
AS
declare variable ICLI2 integer;
begin
  icli2  = icli;

  if (icli = 0) then
   begin
    icli  = 1;
    icli2 = 9999;
   end

   for
       with grp as (select distinct
                           d.pro_codprod,
                           max(d.pro_nome) pro_nome,
                           max(g.gru_nome) gru_nome
                    from produtos d
                    join grupos g on d.pro_grupopro = g.gru_codigo
                    where d.pro_industria = :ifor
                    group by 1
                    order by 1
                    )
    
        select distinct
               gr.gru_nome,
               gr.pro_nome,
               i.ite_produto,
               sum(i.ite_quant)   over(partition by i.ite_produto) quant,
               sum(i.ite_puniliq) over(partition by i.ite_produto) preco
        from itens_ped i
        join grp gr on i.ite_produto = gr.pro_codprod
        join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
        where p.ped_situacao in ('P','F') and
              p.ped_industria = :ifor and
              p.ped_data between :idata1 and :idata2 and
              p.ped_cliente between :icli and :icli2
        order by 1,2
        into :gru_nome, :ite_nomeprod, :ite_produto, :quant, :preco
  do
  suspend;
end^


ALTER PROCEDURE PROC_VENDEDORIND (
    IVENDEDOR INTEGER)
RETURNS (
    VIN_INDUSTRIA INTEGER,
    VIN_CODIGO INTEGER,
    VIN_PERCOM DOUBLE PRECISION,
    FOR_NOMERED VARCHAR(15))
AS
begin
 for
    select vin_industria, vin_codigo, vin_percom, f.for_nomered
    from vendedor_ind i
    join fornecedores f on i.vin_industria = f.for_codigo
    where vin_codigo = :ivendedor
    order by for_nomered
    into :vin_industria, :vin_codigo, :vin_percom, :for_nomered
 do
  suspend;
end^


ALTER PROCEDURE PROC_ZERARVALORESTAB (
    IIND INTEGER,
    ITAB VARCHAR(25),
    IFLAG CHAR(2),
    IVALOR DOUBLE PRECISION)
AS
begin
  if ((ivalor > 0) and (iflag = 'AP')) then ivalor = (ivalor / 100);

  if (iflag = 'DA') then --desconto ADD
   begin
     update produtos set  pro_descadic = :ivalor
     where pro_industria = :iind and pro_nometabela = :itab;
   end

  if (iflag = 'DE') then --desconto Especial
   begin
     update produtos set  pro_descadic2 = :ivalor
     where pro_industria = :iind and pro_nometabela = :itab;
   end

  if (iflag = 'P2') then --pre?
   begin
     update produtos set  pro_valorpromo = :ivalor
     where pro_industria = :iind and pro_nometabela = :itab;
   end

  if (iflag = 'P3') then --pre?
   begin
     update produtos set  pro_preco3 = :ivalor
     where pro_industria = :iind and pro_nometabela = :itab;
   end
  if (iflag = 'AP') then --atualizar em percentual
   begin
     update produtos set  pro_valornormal = (pro_valornormal + ( pro_valornormal * :ivalor)),
                          pro_valorpromo  = (pro_valorpromo  + ( pro_valorpromo  * :ivalor))
     where pro_industria = :iind and pro_nometabela = :itab;
   end
end^


ALTER PROCEDURE PWBI_ATUACAO
RETURNS (
    ATU_ID INTEGER,
    ATU_DESCRICAO VARCHAR(60))
AS
begin
  for
    select a.atu_id, a.atu_descricao
    from area_atu a
    order by 1
    into :atu_id, :atu_descricao
  do
  suspend;
end^


ALTER PROCEDURE PWBI_BRIDGEPROD
RETURNS (
    IDPROD INTEGER,
    CODPROD VARCHAR(25),
    IDINDUSTRIA INTEGER,
    IDGRUPO INTEGER,
    LINHALEVE CHAR(1),
    LINHAPESADA CHAR(1),
    LINHAAGRICOLA CHAR(1),
    LINHAUTILITARIOS CHAR(1),
    LINHAOFFROAD CHAR(1),
    CATEGORIA VARCHAR(35),
    FAMILIA VARCHAR(35))
AS
declare variable LEVE boolean;
declare variable PESADA boolean;
declare variable AGRICOLA boolean;
declare variable UTILITARIOS boolean;
declare variable OFFROAD boolean;
begin
  for
    select
    p.pro_id,
    p.pro_codprod,
    p.pro_industria,
    p.pro_grupo,
    p.pro_linhaleve,
    p.pro_linhapesada,
    p.pro_linhaagricola,
    p.pro_linhautilitarios,
    p.pro_offroad
    from cad_prod p
    order by 3,1
  into :idprod, :codprod, :idindustria, :idgrupo,
       :leve, :pesada, :agricola, :utilitarios, :offroad
  do
  begin
   familia = 'Sem familia';
   categoria = 'Sem categoria';
   if (:leve = true) then
   begin
    linhaleve = 'S';
    categoria = 'Linha leve';
   end
   if (:pesada = true) then
   begin
    linhapesada = 'S';
    categoria = 'Linha pesada';
   end
   if (:agricola = true) then
   begin
    linhaagricola = 'S';
    categoria = 'Linha agr?cola';
   end
   if (:utilitarios = true) then
   begin
    linhautilitarios = 'S';
    categoria = 'Linha utilit?rios';
   end
   if (:offroad = true) then
   begin
    linhaoffroad = 'S';
    categoria = 'Linha off-road';
   end
   suspend;
  end
end^


ALTER PROCEDURE PWBI_CLIENTES
RETURNS (
    CLI_NOMERED VARCHAR(30),
    CLI_CODIGO INTEGER,
    CLI_REDELOJA VARCHAR(35),
    ATUACAO VARCHAR(60),
    CLI_ATUACAOPRINCIPAL INTEGER,
    CLI_REGIAO SMALLINT,
    CLI_UF VARCHAR(2),
    CLI_VENDEDOR INTEGER)
AS
begin
  for
    select upper(c.cli_nomred), c.cli_codigo, upper(c.cli_redeloja),
           upper(a.atu_descricao), c.cli_atuacaoprincipal, c.cli_regiao2,
           c.cli_uf, c.cli_vendedor
    from clientes c
    left join area_atu a on c.cli_atuacaoprincipal = a.atu_id
    where c.cli_tipopes = 'A'
    order by 1
    into :cli_nomered, :cli_codigo, :cli_redeloja, :atuacao, :cli_atuacaoprincipal, :cli_regiao, :cli_uf, :cli_vendedor
  do
  suspend;
end^


ALTER PROCEDURE PWBI_CRM (
    IANO_INI DATE,
    IANO_FIM DATE)
RETURNS (
    AGE_CLIENTE INTEGER,
    AGE_INDUSTRIA INTEGER,
    AGE_DATA DATE,
    AGE_HORARIO VARCHAR(10),
    AGE_STATUS CHAR(1),
    AGE_TIPONTERACAO CHAR(30),
    AGE_TOPICO VARCHAR(25),
    AGE_TIPOVISITA CHAR(1),
    AGE_TIPOPROSPECCAO CHAR(1),
    VEN_NOME VARCHAR(45))
AS
begin
 for
  select ci.age_cliente, ci.age_industria, ci.age_data, ci.age_horario,
         ci.age_status,
         decode(ci.age_tipointeracao,
                'L','Liga??o telef?nica',
                'V','Visita',
                'E','E-mail',
                'W','Whatsapp/Skype',
                'R','Reuni?o',
                'O','Outros'),
         ci.age_topico, ci.age_tipovisita,
         ci.age_tipoprospeccao, v.ven_nome
  from crm_interacoes ci
  join clientes c on ci.age_cliente = c.cli_codigo
  join vendedores v on c.cli_vendedor = v.ven_codigo
  where ci.age_data between :iano_ini and :iano_fim
  order by 3
  into :age_cliente, :age_industria, age_data, age_horario,
       :age_status, :age_tiponteracao, :age_topico, :age_tipovisita,
       :age_tipoprospeccao, :ven_nome
  do
  suspend;
end^


ALTER PROCEDURE PWBI_EMPRESA
RETURNS (
    EMP_LOGOTIPO VARCHAR(200),
    EMP_NOME VARCHAR(50),
    EMP_ID INTEGER,
    EMP_GENERICO VARCHAR(200))
AS
begin
  for
    select e.nome, e.logotipo, cast('1' as integer), e.logogenerico
    from empresa_status e
    order by 1
    into :emp_nome, :emp_logotipo, :emp_id, :emp_generico
  do
  suspend;
end^


ALTER PROCEDURE PWBI_FATURAMENTO (
    IANO_INI DATE,
    IANO_FIM DATE)
RETURNS (
    FAT_PEDIDO VARCHAR(10),
    FAT_INDUSTRIA INTEGER,
    FAT_VALORFAT DOUBLE PRECISION,
    FAT_DATAFAT DATE)
AS
begin
  for
    select f.fat_pedido,
           f.fat_industria,
           sum(coalesce(f.fat_valorfat, 0)) fat_valorfat,
           max(f.fat_datafat) fat_datafat
    from fatura_ped f
    join pedidos p on p.ped_pedido = f.fat_pedido and
                 p.ped_industria = f.fat_industria
    join fornecedores fr on p.ped_industria = fr.for_codigo
    join clientes c on p.ped_cliente = c.cli_codigo
    where p.ped_data between :iano_ini and :iano_fim and
          p.ped_situacao in ('P','F') and
          fr.for_tipo2 = 'A' and
          c.cli_tipopes = 'A'
    group by 1,2
    order by 2,1
    into :fat_pedido, :fat_industria, :fat_valorfat, :fat_datafat
  do
  suspend;
end^


ALTER PROCEDURE PWBI_GRUPOS
RETURNS (
    GRU_CODIGO INTEGER,
    GRU_NOME VARCHAR(50))
AS
begin
  for
    select g.gru_codigo, upper(g.gru_nome)
    from grupos g
    order by 1
    into :gru_codigo, :gru_nome
  do
  suspend;
end^


ALTER PROCEDURE PWBI_INDUSTRIAS
RETURNS (
    FOR_CODIGO INTEGER,
    FOR_NOMERED VARCHAR(15),
    FOR_HOMEPAGE VARCHAR(150))
AS
begin
 for
    select upper(f.for_nomered), f.for_codigo, f.for_homepage
    from fornecedores f
    where f.for_tipo2 = 'A'
    order by 1
    into :for_nomered, :for_codigo, :for_homepage
 do
 suspend;
end^


ALTER PROCEDURE PWBI_ITENSPED (
    IANO_INI DATE,
    IANO_FIM DATE)
RETURNS (
    ITE_PEDIDO VARCHAR(10),
    PRODUTO VARCHAR(25),
    PED_INDUSTRIA INTEGER,
    PED_CLIENTE INTEGER,
    PED_VENDEDOR INTEGER,
    ITE_QUANT DOUBLE PRECISION,
    ITE_TOTLIQUIDO NUMERIC(15,2),
    PED_DATA DATE,
    GRU_CODIGO INTEGER,
    PED_DATA2 DATE,
    ITE_IDPRODUTO INTEGER)
AS
begin
  for
    select
           i.ite_pedido,
           --cast(i.ite_produto as varchar(30) character set NONE) Produto,
           i.ite_produto,
           p.ped_industria,
           p.ped_cliente,
           p.ped_vendedor,
           i.ite_quant,
           i.ite_totliquido,
           coalesce(g.gru_codigo, 0) gru_codigo,
           p.ped_data,
           p.ped_data,
           i.ite_idproduto
    from itens_ped i
    join pedidos p on p.ped_pedido = i.ite_pedido and
                 p.ped_industria = i.ite_industria
    join fornecedores f on p.ped_industria = f.for_codigo
    join clientes     c on p.ped_cliente = c.cli_codigo
    left join produtos pr on i.ite_produto = pr.pro_codprod and
                             i.ite_industria = pr.pro_industria and
                             pr.pro_nometabela = p.ped_tabela
    left join grupos g on pr.pro_grupopro = g.gru_codigo
    where p.ped_data between :iano_ini and :iano_fim and
          p.ped_situacao in ('P','F') and
          f.for_tipo2 = 'A' and
          c.cli_tipopes = 'A'
    order by p.ped_data
    into :ite_pedido, :produto, :ped_industria, :ped_cliente, :ped_vendedor,
         :ite_quant, :ite_totliquido, :gru_codigo, :ped_data, :ped_data2,
         :ite_idproduto
  do
  suspend;
end^


ALTER PROCEDURE PWBI_METASIND
RETURNS (
    MET_INDUSTRIA INTEGER,
    MET_VALOR DOUBLE PRECISION,
    MET_DATA DATE)
AS
declare variable VANO integer;
declare variable VDATA integer;
declare variable V01 double precision;
declare variable V02 double precision;
declare variable V03 double precision;
declare variable V04 double precision;
declare variable V05 double precision;
declare variable V06 double precision;
declare variable V07 double precision;
declare variable V08 double precision;
declare variable V09 double precision;
declare variable V10 double precision;
declare variable V11 double precision;
declare variable V12 double precision;
declare variable VAUX integer;
declare variable VDATAAUX date;
declare variable VMESAUX char(2);
begin
  vaux = 1;
  for
    select m.met_ano, m.met_industria, m.met_jan, m.met_fev, m.met_mar, m.met_abr,
           m.met_mai, m.met_jun, m.met_jul, m.met_ago, m.met_set, m.met_out, m.met_nov,
           m.met_dez
    from ind_metas m
    order by 1
    into :vano, :met_industria, :v01, :v02, :v03, :v04, :v05, :v06, :v07, :v08,
         :v09, :v10, :v11, :v12
  do
  begin
    while (vaux <= 12) do
    begin
     vmesaux = LPAD(vaux, 2, '0');
     vdataaux  = cast(vmesaux||'/'||'01/'||vano as date);
     met_data  = first_day(of month from vdataaux);
     if (vaux = 1) then
     met_valor = coalesce(v01, 0);
     if (vaux = 2) then
     met_valor = coalesce(v02, 0);
     if (vaux = 3) then
     met_valor = coalesce(v03, 0);
     if (vaux = 4) then
     met_valor = coalesce(v04, 0);
     if (vaux = 5) then
     met_valor = coalesce(v05, 0);
     if (vaux = 6) then
     met_valor = coalesce(v06, 0);
     if (vaux = 7) then
     met_valor = coalesce(v07, 0);
     if (vaux = 8) then
     met_valor = coalesce(v08, 0);
     if (vaux = 9) then
     met_valor = coalesce(v09, 0);
     if (vaux = 10) then
     met_valor = coalesce(v10, 0);
     if (vaux = 11) then
     met_valor = coalesce(v11, 0);
     if (vaux = 12) then
     met_valor = coalesce(v12, 0);
     vaux = vaux + 1;
     suspend;

    end
   vaux = 1;
  end
end^


ALTER PROCEDURE PWBI_METASVEND
RETURNS (
    MET_VENDEDOR INTEGER,
    MET_INDUSTRIA INTEGER,
    MET_VALOR DOUBLE PRECISION,
    MET_DATA DATE)
AS
declare variable VANO integer;
declare variable V01 double precision;
declare variable V02 double precision;
declare variable V03 double precision;
declare variable V04 double precision;
declare variable V05 double precision;
declare variable V06 double precision;
declare variable V07 double precision;
declare variable V08 double precision;
declare variable V09 double precision;
declare variable V10 double precision;
declare variable V11 double precision;
declare variable V12 double precision;
declare variable VAUX integer;
declare variable VDATAAUX date;
declare variable VMESAUX char(2);
begin
  vaux = 1;
  for
    select m.met_ano, m.met_industria, m.met_jan, m.met_fev, m.met_mar, m.met_abr,
           m.met_mai, m.met_jun, m.met_jul, m.met_ago, m.met_set, m.met_out, m.met_nov,
           m.met_dez, m.met_vendedor
    from vend_metas m
    order by 1
    into :vano, :met_industria, :v01, :v02, :v03, :v04, :v05, :v06, :v07, :v08,
         :v09, :v10, :v11, :v12, :met_vendedor
  do
  begin
    while (vaux <= 12) do
    begin
     vmesaux = LPAD(vaux, 2, '0');
     vdataaux  = cast(vmesaux||'/'||'01/'||vano as date);
     met_data  = last_day(of month from vdataaux);
     if (vaux = 1) then
     met_valor = coalesce(v01, 0);
     if (vaux = 2) then
     met_valor = coalesce(v02, 0);
     if (vaux = 3) then
     met_valor = coalesce(v03, 0);
     if (vaux = 4) then
     met_valor = coalesce(v04, 0);
     if (vaux = 5) then
     met_valor = coalesce(v05, 0);
     if (vaux = 6) then
     met_valor = coalesce(v06, 0);
     if (vaux = 7) then
     met_valor = coalesce(v07, 0);
     if (vaux = 8) then
     met_valor = coalesce(v08, 0);
     if (vaux = 9) then
     met_valor = coalesce(v09, 0);
     if (vaux = 10) then
     met_valor = coalesce(v10, 0);
     if (vaux = 11) then
     met_valor = coalesce(v11, 0);
     if (vaux = 12) then
     met_valor = coalesce(v12, 0);
     vaux = vaux + 1;
     suspend;

    end
   vaux = 1;
  end
end^


ALTER PROCEDURE PWBI_PEDIDOS (
    IANO_INI DATE,
    IANO_FIM DATE)
RETURNS (
    PED_PEDIDO VARCHAR(10),
    PED_DATA DATE,
    PED_SITUACAO CHAR(1),
    PED_INDUSTRIA INTEGER,
    PED_VENDEDOR INTEGER,
    PED_CLIENTE INTEGER,
    VALOR_PED DOUBLE PRECISION,
    QTD_PED DOUBLE PRECISION,
    QTD_FAT DOUBLE PRECISION)
AS
begin
  for
    select
           p.ped_pedido,
           p.ped_data,
           p.ped_situacao,
           p.ped_industria,
           p.ped_vendedor,
           p.ped_cliente,
           (select sum(ite_totliquido) from itens_ped i2 where p.ped_pedido = i2.ite_pedido and p.ped_industria = i2.ite_industria) valor_ped,
           (select sum(ite_quant)      from itens_ped  i2 where p.ped_pedido = i2.ite_pedido and p.ped_industria = i2.ite_industria) qtd_ped,
           (select count(fat_pedido)   from fatura_ped fp where p.ped_pedido = fp.fat_pedido and p.ped_industria = fp.fat_industria) qtd_fat
    from pedidos p
    join fornecedores f on p.ped_industria = f.for_codigo
    join clientes     c on p.ped_cliente   = c.cli_codigo
    join vendedores   v on p.ped_vendedor  = v.ven_codigo
    where p.ped_data between :iano_ini and :iano_fim and
          p.ped_situacao in ('P','F') and
          f.for_tipo2 = 'A' and
          c.cli_tipopes = 'A'
    group by 1,2,3,4,5,6,7
    order by 4,2
    into :ped_pedido, :ped_data, :ped_situacao, :ped_industria, :ped_vendedor, :ped_cliente, :valor_ped, :qtd_ped, :qtd_fat
  do
  suspend;
end^


ALTER PROCEDURE PWBI_PRODUTOS
RETURNS (
    PRO_CODPROD VARCHAR(25),
    PRO_INDUSTRIA INTEGER,
    PRO_GRUPOPRO INTEGER,
    CONTAGEM INTEGER,
    PRO_LINHA VARCHAR(50),
    PRO_CURVA CHAR(1),
    PRO_CHAVECOMBINADA VARCHAR(40),
    PRO_CATEGORIA VARCHAR(25),
    PRO_IDPROD INTEGER)
AS
declare variable LEVE boolean;
declare variable PESADO boolean;
declare variable AGRICOLA boolean;
declare variable UTILITARIOS boolean;
begin
  for
    select p.pro_codprod,
           max(p.pro_industria) pro_industria,
           max(coalesce(p.pro_grupopro, 0)) pro_grupopro,
           count(p.pro_codprod) contagem,
           max(p.pro_linha) pro_linha,
           p.pro_status,
           coalesce(p.pro_linhaleve, false),
           coalesce(p.pro_linhapesada, false),
           coalesce(p.pro_linhaagricola, false),
           coalesce(p.pro_linhautilitarios, false),
           p.pro_codigo
    from produtos p
    join fornecedores f on p.pro_industria = f.for_codigo
    where f.for_tipo2 = 'A'
    group by 1,6, 7, 8, 9, 10, 11
    order by 2,1
    into :pro_codprod, :pro_industria, :pro_grupopro, :contagem, :pro_linha,
    :pro_curva, :leve, :pesado, :agricola, :utilitarios, :pro_idprod
  do
   begin
    pro_chavecombinada = trim(:pro_codprod)||'/'||:pro_industria;
    pro_categoria = 'Nao Categorizado';
    if (leve = true) then
      pro_categoria = 'Linha Leve';
    if (pesado = true) then
      pro_categoria = 'Linha Pesada';
    if (agricola = true) then
      pro_categoria = 'Linha Agricola';
    if (utilitarios = true) then
      pro_linha = 'Utilitarios';
    suspend;
   end
end^


ALTER PROCEDURE PWBI_REGIOES
RETURNS (
    REG_CODIGO INTEGER,
    REG_NOME VARCHAR(50))
AS
begin
  for
    select r.reg_codigo, upper(r.reg_descricao)
    from regioes r
    order by 1
    into :reg_codigo, :reg_nome
  do
  suspend;
end^


ALTER PROCEDURE PWBI_VENDEDORES
RETURNS (
    VEN_CODIGO INTEGER,
    VEN_NOME VARCHAR(45),
    VEN_NOMEUSU VARCHAR(50),
    VEN_IMAGEM VARCHAR(200))
AS
begin
  for
      select v.ven_codigo, upper(v.ven_nome), upper(v.ven_nomeusu), v.ven_imagem
      from vendedores v
      order by 3
      into :ven_codigo, :ven_nome, :ven_nomeusu, :ven_imagem
  do
  suspend;
end^


ALTER PROCEDURE SP_ATZCIDADES
AS
declare variable CID_ID integer;
declare variable CLI_ID integer;
begin
  for
   select cr.codigo, c.cli_codigo
   from clientes c
   left join cidades cr on c.cli_cidade collate win_ptbr = cr.nome
   order by 1
   into :cid_id, :cli_id
   do
   update clientes set cli_idcidade = :cid_id
   where cli_codigo = :cli_id;
end^


ALTER PROCEDURE SP_ATZGENS
AS
declare variable VY integer;
declare variable VSEQ integer;
declare variable VNAME varchar(40);
begin
vseq = 0;
vy = 1;
  while (vy <= 20) do
   begin
    if (vy = 1) then
       select coalesce(max(x.atu_id),0) from area_atu x into :vseq;
    if (vy = 2) then
       select coalesce(max(x.cli_codigo),0) from clientes x into :vseq;
    if (vy = 3) then
       select coalesce(max(x.lan_lancto),0) from contaspgrec x into :vseq;
    if (vy = 4) then
       select coalesce(max(x.con_codigo),0) from contas x into :vseq;
    if (vy = 5) then
       select coalesce(max(x.con_codigo),0) from contato_for x into :vseq;
    if (vy = 6) then
       select coalesce(max(x.cd_codigo),0) from cred_dev x into :vseq;
    if (vy = 7) then
       select coalesce(max(x.for_codigo),0) from fornecedores x into :vseq;
    if (vy = 8) then
       select coalesce(max(g.gru_codigo),0) from grupos g into :vseq;
    if (vy = 9) then
       select coalesce(max(x.gru_codigo),0) from grupo_desc x into :vseq;
    if (vy = 10) then
       select coalesce(max(x.ite_lancto),0) from itens_ped x into :vseq;
    if (vy = 11) then
       select coalesce(max(x.pro_codigo),0) from produtos x into :vseq;
    if (vy = 12) then
       select coalesce(max(x.reg_codigo),0) from regioes x into :vseq;
    if (vy = 13) then
       select coalesce(max(x.codigo),0) from transportadora x into :vseq;
    if (vy = 14) then
       select coalesce(max(x.ven_codigo),0) from vendedores x into :vseq;
    if (vy = 15) then
       select coalesce(max(x.ped_numero),0) from pedidos x into :vseq;
    if (vy = 16) then
       select coalesce(max(x.codigo),0) from user_nomes x into :vseq;
    if (vy = 17) then
       select coalesce(max(x.tele_id),0) from telemkt x into :vseq;
    if (vy = 18) then
       select coalesce(max(x.age_lancto),0) from agenda x into :vseq;
    if (vy = 19) then
       select coalesce(max(x.ani_cliente),0) from cli_aniv x into :vseq;
    if (vy = 20) then
       select coalesce(max(x.fat_lancto),0) from fatura_ped x into :vseq;

    --generator names
    if (vy = 1) then
       :vname = 'GEN_AREA_ATU_ID';
    if (vy = 2) then
       :vname = 'GEN_CLIENTES_ID';
    if (vy = 3) then
       :vname = 'GEN_CONTASPGREC_ID';
    if (vy = 4) then
       :vname = 'GEN_CONTAS_ID';
    if (vy = 5) then
       :vname = 'GEN_CONTATO_FOR_ID';
    if (vy = 6) then
       :vname = 'GEN_CRED_DEV_ID';
    if (vy = 7) then
       :vname = 'GEN_FORNECEDORES_ID';
    if (vy = 8) then
       :vname = 'GEN_GRUPOS_ID';
    if (vy = 9) then
       :vname = 'GEN_GRUPO_DESC_ID';
    if (vy = 10) then
       :vname = 'GEN_ITENS_PED_ID';
    if (vy = 11) then
       :vname = 'GEN_REGIOES_ID';
    if (vy = 12) then
       :vname = 'GEN_TRANSPORTADORA_ID';
    if (vy = 13) then
       :vname = 'GEN_VENDEDORES_ID';
    if (vy = 14) then
       :vname = 'GEN_PEDIDOS_ID';
    if (vy = 15) then
       :vname = 'GEN_USER_NOMES_ID';
    if (vy = 16) then
       :vname = 'GEN_USER_NOMES_ID';
    if (vy = 17) then
       :vname = 'GEN_TELEMKT_ID';
    if (vy = 18) then
       :vname = 'GEN_AGENDA_ID';
    if (vy = 19) then
       :vname = 'GEN_CLI_ANIV_ID';
    if (vy = 20) then
       :vname = 'GEN_FATURA_PED_ID';

     execute statement('set generator '||:vname||' to '||:vseq);
     vy = vy + 1;
     vseq = 0;
   end
end^


ALTER PROCEDURE SP_ATZREGIOES
AS
declare variable REG_ID integer;
declare variable CLI_ID integer;
begin
  for
   select r.reg_id, c.cli_codigo
   from clientes c
   left join cidades_regioes r on c.cli_idcidade = r.cid_id
   order by 1
   into :reg_id, :cli_id
   do
   update clientes set cli_regiao2 = :reg_id
   where cli_codigo = :cli_id;
end^


ALTER PROCEDURE SP_BALANCETE (
    PDT1 DATE,
    PDT2 DATE)
RETURNS (
    CON_GRAU VARCHAR(10),
    CON_DESCRICAO VARCHAR(50),
    SALDOINI DOUBLE PRECISION,
    ENTRADA DOUBLE PRECISION,
    SAIDA DOUBLE PRECISION,
    SALDO DOUBLE PRECISION)
AS
begin
 for
    with saldoini as (select pr.lan_conta,
                             sum(case
                                 when lan_credeb = 'R' then coalesce(lan_valor, 0)
                                 when lan_credeb = 'P' then coalesce((lan_valor *-1), 0)
                                 end) as saldo_inicial
                      from contaspgrec pr
                      where pr.lan_datapago < :pdt1 and
                            pr.lan_valorpago > 0 and
                            coalesce(pr.lan_conta, 0) > 0
                      group by 1
                      order by 1),
    
         movimentos as (select pr.lan_conta,
                             sum(case when lan_credeb = 'R' then coalesce(lan_valor, 0) end) as entrada,
                             sum(case when lan_credeb = 'P' then coalesce(lan_valor, 0) end) as saida
                        from contaspgrec pr
                        where pr.lan_datapago between :pdt1 and :pdt2 and
                              pr.lan_valorpago > 0 and
                              coalesce(pr.lan_conta, 0) > 0
                        group by 1
                        order by 1),
    
          cadcontas as (select c.con_codigo, c.con_grau
                        from contas c
                        order by 2)
    
    select c.con_grau,
           c.con_descricao,
           sum(coalesce(i.saldo_inicial, 0)) as saldoini,
           sum(coalesce(e.entrada, 0))       as entrada,
           sum(coalesce(e.saida, 0))         as saida,
           sum(coalesce(i.saldo_inicial, 0) +(coalesce(e.entrada, 0) - coalesce(e.saida, 0))) as saldo
           from cadcontas cc
           left join contas     c on cc.con_grau like c.con_grau || '%'
           left join saldoini   i on cc.con_codigo = i.lan_conta
           left join movimentos e on cc.con_codigo = e.lan_conta
           group by 1,2
           order by c.con_grau asc
           into :con_grau, :con_descricao, :saldoini, :entrada, :saida, :saldo
 do
 suspend;
end^


ALTER PROCEDURE SP_BLOBEMPARTES (
    PBLOB BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    PDELIMITADOR CHAR(1))
RETURNS (
    IDX INTEGER,
    PARTE VARCHAR(30000))
AS
declare variable VTAMANHO bigint;
declare variable VLIMITEPARTE integer = 30000;
declare variable VPOS bigint = 1;
declare variable VPOSFINAL bigint;
begin
  idx = 1;
  vTamanho = char_length(pBlob);
  parte = '';

  while (vPos <= vTamanho) do
  begin
    parte = substring(pBlob from vPos for vLimiteParte);
    vPosFinal = position(pDelimitador, parte);
    parte = left(parte,vPosFinal);
    suspend;

    vPos = vPos + vPosFinal;
    idx = idx + 1;
  end
end^


ALTER PROCEDURE SP_CADTABELA (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    P_ROTINA CHAR(1))
AS
declare variable VIDX integer;
declare variable VPARTE varchar(30000);
declare variable VLINHA varchar(500);
declare variable VVALOR varchar(300);
declare variable CIND varchar(3);
declare variable CDESCONTO varchar(3);
declare variable CGRUPOPROD varchar(3);
declare variable CTABELA varchar(20);
declare variable CDATATAB varchar(10);
declare variable CVENCPROMO varchar(10);
declare variable CSTATUS varchar(50);
declare variable CCODIGO varchar(25);
declare variable CDESCR varchar(100);
declare variable CPRECO1 double precision;
declare variable CPRECO2 double precision;
declare variable CPRECO3 double precision;
declare variable CDBARRAS varchar(13);
declare variable CPESO varchar(10);
declare variable CAPLIC varchar(800);
declare variable CEMBAL varchar(10);
declare variable CST varchar(10);
declare variable CIPI double precision;
declare variable CCODORI varchar(40);
declare variable CPREPESO varchar(25);
declare variable CCONVERSAO varchar(300);
declare variable CDESCESPEC double precision;
declare variable CNCM varchar(10);
declare variable CDESCADD double precision;
declare variable CCODIGO2 varchar(25);
declare variable CCURVAABC char(1);
declare variable VDESC varchar(100);
declare variable VPRECO1 double precision;
declare variable VPRECO2 double precision;
declare variable VPRECO3 double precision;
declare variable VCDBARRAS varchar(13);
declare variable VPESO varchar(10);
declare variable VAPLIC varchar(800);
declare variable VEMBAL varchar(10);
declare variable VST varchar(10);
declare variable VIPI double precision;
declare variable VCODORI varchar(40);
declare variable VPREPESO double precision;
declare variable VCONVERSAO varchar(300);
declare variable VDESCESPEC double precision;
declare variable VNCM varchar(10);
declare variable VDESCADD double precision;
declare variable VSTATUS varchar(50);
declare variable VGRUPODESC integer;
declare variable VGRUPOPROD integer;
declare variable VPERCOMGRUPO varchar(10);
declare variable VLEVE boolean;
declare variable VPESADA boolean;
declare variable VAGRICOLA boolean;
declare variable VUTILITARIO boolean;
begin
  for
    select bp.parte
    from sp_blobempartes(:pDados,'|') bp
    into vParte
  do
  begin
    for
      select ss.texto
      from sp_splitstring(:vParte,'|') ss
      into vLinha
    do
    begin
      for
        select ss.idx, trim(nullif(ss.texto, ''))
        from sp_splitstring(:vLinha, ';') ss
        into vIdx, vValor
      do
      begin
        if (vIdx = 1)       then cind       = vValor;
        else if (vIdx = 2)  then ctabela    = trim(vValor);
        else if (vIdx = 3)  then ccodigo2   = trim(vValor);
        else if (vIdx = 4)  then ccodigo    = trim(vValor);
        else if (vIdx = 5)  then vpercomgrupo  = vValor;

        else if (vIdx = 6)  then cdesconto  = iif(vvalor = '0', :vgrupodesc, vvalor);
        else if (vIdx = 7)  then cgrupoprod = iif(vvalor = '000', :vgrupoprod, vvalor);
        else if (vIdx = 8)  then cdatatab   = replace(vValor,'/','.');
        else if (vIdx = 9)  then cvencpromo = replace(vValor,'/','.');
        else if (vIdx = 10) then cstatus    = iif(char_length(coalesce(vvalor, '')) < 2, :vstatus, vvalor); --familia de produtos
        else if (vIdx = 11) then cdescr     = iif(char_length(coalesce(vvalor, '')) < 2, :vdesc, vvalor);
        else if (vIdx = 12) then cpreco1    = iif(cast(vvalor as numeric(10,2)) = 0, :vpreco1, vvalor);
        else if (vIdx = 13) then cpreco2    = iif(cast(vvalor as numeric(10,2)) = 0, :vpreco2, vvalor);
        else if (vIdx = 14) then cpreco3    = iif(cast(vvalor as numeric(10,2)) = 0, :vpreco3, vvalor);
        else if (vIdx = 15) then cdbarras   = iif(char_length(coalesce(vvalor, '')) < 2, :vcdbarras, vvalor);
        else if (vIdx = 16) then cpeso      = iif(char_length(coalesce(vvalor, '')) < 1, :vpeso, vvalor);
        else if (vIdx = 17) then caplic     = iif(char_length(coalesce(vvalor, '')) < 2, :vaplic, vvalor);
        else if (vIdx = 18) then cembal     = iif(cast(vvalor as integer) = 0, :vembal, vvalor);
        else if (vIdx = 19) then cst        = iif(cast(vvalor as numeric(10,2)) < 1, :vst, vvalor);
        else if (vIdx = 20) then cipi       = iif(cast(vvalor as numeric(10,2)) = 0, :vipi, vvalor);
        else if (vIdx = 21) then ccodori    = iif(char_length(coalesce(vvalor, '')) < 2, :vcodori, vvalor);
        else if (vIdx = 22) then cprepeso   = iif(cast(vvalor as numeric(10,2)) < 1, :vprepeso, vvalor);
        else if (vIdx = 23) then cconversao = iif(char_length(coalesce(vvalor, '')) < 2, :vconversao, vvalor);
        else if (vIdx = 24) then cdescespec = iif(cast(vvalor as numeric(10,2)) < 1, :vdescespec, vvalor);
        else if (vIdx = 25) then cncm       = iif(char_length(coalesce(vvalor, '')) < 2, :vncm, vvalor);
        else if (vIdx = 26) then cdescadd   = iif(cast(vvalor as numeric(10,2)) < 1, :vdescadd, vvalor);
        else if (vIdx = 27) then vleve      = iif(vvalor =  'S', true, false);
        else if (vIdx = 28) then vpesada    = iif(vvalor =  'S', true, false);
        else if (vIdx = 29) then vagricola  = iif(vvalor =  'S', true, false);
        else if (vIdx = 30) then vutilitario = iif(vvalor =  'S', true, false);
        else if (vIdx = 31) then ccurvaabc   = trim(vValor);
        --
        if (vIdx = 5 and p_rotina = 'U') then -- update em lista ja cadastrada
         begin
           select first 1 p.pro_nome, p.pro_linha, p.pro_valornormal, p.pro_valorpromo, p.pro_preco3, p.pro_codbarras, p.ite_peso,
                  p.pro_aplicacao2, p.pro_embalagem, p.pro_st, p.pro_ipi, p.pro_codoriginal, p.ite_prepeso,
                  p.ite_conversao, p.pro_descadic2, p.pro_ncm, p.pro_descadic, p.pro_grupo, p.pro_grupopro,
                  p.pro_qtdped, p.pro_linhaleve, p.pro_linhapesada, p.pro_linhaagricola, p.pro_linhautilitarios
           from produtos p
           where p.pro_industria = :cind and p.ite_codigo2 = :ccodigo2 and p.pro_nometabela = :ctabela
           into
           :vdesc, :vstatus, :vpreco1, :vpreco2, :vpreco3, :vcdbarras, :vpeso, :vaplic,
           :vembal, :vst,  :vipi, :vcodori, :vprepeso, :vconversao, :vdescespec, :vncm, :vdescadd,
           :vgrupodesc, :vgrupoprod, :vpercomgrupo, vleve, vpesada, vagricola, vutilitario;

           cstatus = iif(char_length(coalesce(cstatus, '')) < 2, :vstatus, cstatus);
         end
      end
  
      update or insert into produtos
      (pro_industria, pro_grupo, pro_grupopro, pro_nometabela, pro_datatabela, pro_vencpromocao, pro_linha,
       pro_codprod, pro_nome, pro_valornormal, pro_valorpromo, pro_preco3, pro_codbarras, ite_peso, pro_aplicacao2,
       pro_embalagem, pro_st, pro_ipi, pro_codoriginal, ite_prepeso, ite_conversao, pro_descadic2,
       pro_ncm, pro_descadic, ite_codigo2, pro_qtdped, pro_linhaleve, pro_linhapesada, pro_linhaagricola, pro_linhautilitarios,
       pro_status)
      values
      (:cind, :cdesconto, :cgrupoprod, :ctabela, :cdatatab, :cvencpromo, :cstatus,
       :ccodigo,:cdescr, :cpreco1, :cpreco2, :cpreco3, :cdbarras, :cpeso, :caplic,
       :cembal, :cst,  :cipi, :ccodori, :cprepeso, :cconversao, :cdescespec, :cncm,
       :cdescadd, :ccodigo2, :vpercomgrupo, :vleve, :vpesada, :vagricola, :vutilitario,
       :ccurvaabc)
       matching (pro_industria,pro_codprod,pro_nometabela);
    end
  end
end^


ALTER PROCEDURE SP_CALC_PERC_CLIATIVO_CLIMES
RETURNS (
    INDUSTRIA VARCHAR(20),
    CLIGERAL INTEGER,
    CLIMES INTEGER,
    PERCENTUAL DOUBLE PRECISION)
AS
begin
  for
    with
      total_hist as (select
                     p.ped_industria,
                     count(distinct p.ped_cliente) as total_clientes
                     from pedidos p
                     group by
                     p.ped_industria
                    ),
       mes_corr  as (select
                     p.ped_industria,
                     count(distinct p.ped_cliente) as clientes_mes
                     from pedidos p
                     where extract(month from p.ped_data) = extract(month from current_date) and
                           extract(year from p.ped_data)  = extract(year from current_date)
                     group by p.ped_industria
                    )
    
    select
        f.for_nomered as fornecedor,
        th.total_clientes,
        coalesce(mc.clientes_mes, 0) as clientes_mes,
        iif(th.total_clientes > 0, round((coalesce(mc.clientes_mes, 0) * 100.0) / th.total_clientes, 2), 0) as percentual_ativos_mes
        from total_hist th
        join fornecedores f on f.for_codigo = th.ped_industria
        left join mes_corr mc on mc.ped_industria = th.ped_industria
        where f.for_tipo2 = 'A'
        order by percentual_ativos_mes desc
    into :industria, :cligeral, :climes, :percentual

  do
  suspend;
end^


ALTER PROCEDURE SP_CALC_PERC_CRM_CLIMES
RETURNS (
    INDUSTRIA VARCHAR(20),
    CLIGERAL INTEGER,
    CLIMES INTEGER,
    PERCENTUAL DOUBLE PRECISION)
AS
begin
  for
    with
      total_hist as (select
                     ci.age_industria,
                     count(distinct ci.age_cliente) as total_clientes
                     from crm_interacoes ci
                     group by
                     ci.age_industria
                    ),
       mes_corr  as (select
                     ci.age_industria,
                     count(distinct ci.age_cliente) as clientes_mes
                     from crm_interacoes ci
                     where extract(month from ci.age_data) = extract(month from current_date) and
                           extract(year from ci.age_data)  = extract(year from current_date)
                     group by ci.age_industria
                    )
    
    select
        f.for_nomered as fornecedor,
        th.total_clientes,
        coalesce(mc.clientes_mes, 0) as clientes_mes,
        iif(th.total_clientes > 0,round((coalesce(mc.clientes_mes, 0) * 100.0) / th.total_clientes, 2), 0) as percentual_ativos_mes
        from total_hist th
        join fornecedores f on f.for_codigo = th.age_industria
        left join mes_corr mc on mc.age_industria = th.age_industria
        where f.for_tipo2 = 'A'
        order by percentual_ativos_mes desc
    into :industria, :cligeral, :climes, :percentual
  do
  suspend;
end^


ALTER PROCEDURE SP_CALDESEMPENHO (
    IDATA1 DATE,
    IDATA2 DATE)
RETURNS (
    OVENDADIA DOUBLE PRECISION,
    OVENDAMES DOUBLE PRECISION,
    OTICKETMEDIO DOUBLE PRECISION,
    OCLIATENDIDOS INTEGER,
    OPERFATHOJE DOUBLE PRECISION,
    OPERFATMES DOUBLE PRECISION,
    OPERTICKET DOUBLE PRECISION,
    OPERATENDIMENTO DOUBLE PRECISION,
    OATENDULTSEMANA INTEGER,
    OPERCATENDULTSEM DOUBLE PRECISION,
    QTDCLIVENDAS INTEGER,
    PERCCLIVENDAS DOUBLE PRECISION)
AS
declare variable VVENDADIAANT double precision;
declare variable VVENDAMESANT double precision;
declare variable VDATAMESANT1 date;
declare variable VDATAMESANT2 date;
declare variable CLIATENDANT integer;
declare variable VDIAANT date;
declare variable ATENDSEMRETRASADA integer;
declare variable VTEMP double precision;
begin
  ocliatendidos = 0;
  -- interacoes hoje
  select
  count(c.age_lancto)
  from crm_interacoes c
  where c.age_data = current_date
  into :ocliatendidos;

  select
  coalesce(count(c.age_lancto),0)
  from crm_interacoes c
  where c.age_data between :idata1 and :idata2
  into :ovendames;

  --busca a ultima data antes de hoje
  select max(c.age_data)
  from crm_interacoes c
  where c.age_data < current_date
  into :vdiaant;
  if (vdiaant is null) then
   vdiaant = current_date;

  select
  count(c.age_data)
  from crm_interacoes c
  where c.age_data = :vdiaant
  into :cliatendant;

  --clientes atendidos dia anterior
  select
  count(distinct p.ped_cliente)
  from pedidos p
  where p.ped_data >= (current_date - 90) and
        p.ped_situacao in ('P','F')
  into :qtdclivendas;

  -- interacoes mes anterior
  select first_day(of month from (current_date-30)) primeiro_dia,
       last_day(of month from (current_date-30)) ultimo_dia
  from rdb$database
  into :vdatamesant1, :vdatamesant2;

  select
  count(coalesce(c.age_lancto,0))
  from crm_interacoes c
  where c.age_data between :vdatamesant1 and :vdatamesant2
  into :vvendamesant;

  -- interacoes na semana anterior
  select
  count(coalesce(c.age_lancto,0))
  from crm_interacoes c
  where c.age_data >= first_day(of week from (current_date - 6)) and
        c.age_data <= last_day(of week from (current_date - 6))
  into :oatendultsemana;

  -- interacoes na semana retrasada
  select
  count(coalesce(c.age_lancto,0))
  from crm_interacoes c
  where c.age_data >= first_day(of week from (current_date - 12)) and
        c.age_data <= last_day(of week from (current_date - 12))
  into :atendsemretrasada;

  if (coalesce(vvendadiaant,0) = 0) then
   vvendadiaant = 1;
  if (vvendamesant = 0) then
  vvendamesant = 1;
  if (vvendamesant > 0) then
  operticket   = (vvendadiaant / cliatendant);
  else
  operticket   = 0;

  --calculos
  :operticket      = 0;
  :oticketmedio    = 0;
  :ovendadia       = coalesce(ocliatendidos,0);
  if (ovendadia > 0) then
  :oticketmedio    = coalesce((ovendadia / ocliatendidos),0);
  :operfathoje     = coalesce(((ovendadia - vvendadiaant)/vvendadiaant) * 100, 0);
  :operfatmes      = coalesce(((ovendames - vvendamesant)/vvendamesant) * 100, 0);
  if (operticket > 0) then
   begin
   operticket      = (oticketmedio - operticket) / operticket;
   operticket      = operticket * 100;
   end
  if (atendsemretrasada > 0 and oatendultsemana > 0) then
   begin
   vtemp = (oatendultsemana - atendsemretrasada);
   vtemp = (vtemp/atendsemretrasada) * 100;
   end


  operatendimento = ocliatendidos - cliatendant;
  operatendimento = operatendimento/cliatendant;
  operatendimento = operatendimento * 100;
  operatendimento = coalesce(operatendimento, 0);
  if (ovendames > 0) then
  percclivendas = coalesce(((qtdclivendas - ovendames)/ovendames)*100,0);
  else
  percclivendas = 0;
  opercatendultsem = coalesce(vtemp, 0);
  suspend;
end^


ALTER PROCEDURE SP_CALLIQPROD (
    P_BRUTO DOUBLE PRECISION,
    P_DES1 DOUBLE PRECISION,
    P_DES2 DOUBLE PRECISION,
    P_DES3 DOUBLE PRECISION,
    P_DES4 DOUBLE PRECISION,
    P_DES5 DOUBLE PRECISION,
    P_DES6 DOUBLE PRECISION,
    P_DES7 DOUBLE PRECISION,
    P_DES8 DOUBLE PRECISION,
    P_DES9 DOUBLE PRECISION)
RETURNS (
    RESULTADO DOUBLE PRECISION)
AS
begin
  /* procedure text */
  resultado = p_bruto;
  resultado = resultado - (resultado *(p_des1 / 100));
  resultado = resultado - (resultado *(p_des2 / 100));
  resultado = resultado - (resultado *(p_des3 / 100));
  resultado = resultado - (resultado *(p_des4 / 100));
  resultado = resultado - (resultado *(p_des5 / 100));
  resultado = resultado - (resultado *(p_des6 / 100));
  resultado = resultado - (resultado *(p_des7 / 100));
  resultado = resultado - (resultado *(p_des8 / 100));
  resultado = resultado - (resultado *(p_des9 / 100));
  suspend;
end^


ALTER PROCEDURE SP_CURVA_01 (
    PDATA1 DATE,
    PDATA2 DATE,
    PIND INTEGER,
    PUF CHAR(2),
    PIND2 INTEGER)
AS
declare variable VDESCRICAO varchar(50);
declare variable VVALOR integer;
declare variable VCONVERSAO varchar(25);
begin
 delete from curvaabc where valor > 0;
 delete from tab_temp where tmp_valor > 0;

 if (pind = 0 or pInd is null) then
  begin
   pind = 1;
   pind2 = 9999;
  end
  else
  begin
   pind2 = pind;
  end
 if (puf is null or puf = '') then
  puf = 'XX';

  if (puf <> 'XX') then
  begin
   for
     select distinct
            upper(c.cli_nomred),
            p.ped_cliente,
            sum(p.ped_totliq)
     from pedidos p
     join clientes c on p.ped_cliente = c.cli_codigo
     where p.ped_data between :pdata1  and :pdata2 and
           p.ped_situacao in ('P','F') and
           c.cli_uf = :puf and c.cli_tipopes = 'A' and
           p.ped_industria between :pind and :pind2
     group by 1, 2
     order by 3 desc
     into :vdescricao, :vconversao, :vvalor
   do
    insert into tab_temp (tmp_descricao, tmp_conversao, tmp_valor) values (:vdescricao, :vconversao, :vvalor);
  end

  if (puf = 'XX') then
  begin
   for
     select upper(c.cli_nomred),
            p.ped_cliente,
            sum(p.ped_totliq)
     from pedidos p
     join clientes c on p.ped_cliente = c.cli_codigo
     where p.ped_data between :pdata1  and :pdata2 and
           p.ped_situacao in ('P','F') and
           c.cli_uf <> :puf and c.cli_tipopes = 'A' and
           p.ped_industria between :pind and :pind2
     group by 1, 2
     order by 3 desc
     into :vdescricao, :vconversao, :vvalor
   do
    insert into tab_temp (tmp_descricao, tmp_conversao, tmp_valor) values (:vdescricao, :vconversao, :vvalor);
  end
end^


ALTER PROCEDURE SP_CURVA_02 (
    PDATA1 DATE,
    PDATA2 DATE,
    PCLI INTEGER,
    PUF CHAR(2),
    PCLI2 INTEGER)
AS
declare variable VDESCRICAO varchar(50);
declare variable VVALOR integer;
declare variable VCONVERSAO varchar(25);
begin
 delete from curvaabc where valor > 0;
 delete from tab_temp where tmp_valor > 0;

 if (pcli = 0 or pcli is null) then
  begin
   pcli = 1;
   pcli2 = 9999;
  end
  else
  begin
   pcli2 = pcli;
  end
 if (puf is null or puf = '') then
  puf = 'XX';

  if (puf <> 'XX') then
  begin
    for
        select ped_industria ,
        sum(i.ite_totliquido),
        f.for_nomered
        from itens_ped i
        join pedidos p on i.ite_pedido = p.ped_pedido
        join fornecedores f on p.ped_industria = f.for_codigo and f.for_tipo2 = 'A'
        join clientes c on p.ped_cliente = c.cli_codigo
        where p.ped_data between :pdata1 and :pdata2 and
              p.ped_situacao in ('P','F') and
              p.ped_cliente between :pcli and :pcli2 and
              c.cli_uf = :puf
        group by 1, 3
        order by 2 desc
        into :vconversao, :vvalor, :vdescricao
    do
    insert into tab_temp (tmp_conversao, tmp_valor, tmp_descricao) values (:vconversao, :vvalor, :vdescricao);
  end
  if (puf = 'XX') then
  begin
    for
        select ped_industria,
        sum(i.ite_totliquido),
        f.for_nomered
        from itens_ped i
        join pedidos p on i.ite_pedido = p.ped_pedido
        join fornecedores f on p.ped_industria = f.for_codigo and f.for_tipo2 = 'A'
        join clientes c on p.ped_cliente = c.cli_codigo
        where p.ped_data between :pdata1 and :pdata2 and
              p.ped_situacao in ('P','F') and
              p.ped_cliente between :pcli and :pcli2 and
              c.cli_uf <> :puf
        group by 1, 3
        order by 2 desc
        into :vconversao, :vvalor, :vdescricao
    do
    insert into tab_temp (tmp_conversao, tmp_valor, tmp_descricao) values (:vconversao, :vvalor, :vdescricao);
  end
end^


ALTER PROCEDURE SP_CURVA_03 (
    PDATA1 DATE,
    PDATA2 DATE,
    PCLI INTEGER,
    PCLI2 INTEGER,
    PIND INTEGER,
    PUF VARCHAR(2),
    PGRUPOPRO INTEGER,
    PGRUPOLOJA BOOLEAN)
AS
declare variable VDESCRICAO varchar(50);
declare variable VCODIGO varchar(25);
declare variable VVALOR numeric(15,2);
declare variable VQUANT numeric(8,2);
declare variable VGRUPOPRO2 integer;
declare variable VGRUPOLOJAS varchar(35);
begin
 delete from tab_temp where coalesce(tmp_quant, 0) >= 0;
 delete from pro_tempcurva where pro_id > 0;

 merge into pro_tempcurva t
 using (select d.pro_codprod,
               max(d.pro_nome) pro_nome,
               max(d.pro_codigo) pro_codigo,
               max(d.pro_grupopro) pro_grupopro,
               sum(d.pro_preliq) preco
               from produtos d
               where d.pro_industria = :pind
               group by 1
               order by 1
        ) d
 on t.pro_codprod = d.pro_codprod
 when not matched then insert (pro_id, pro_descricao, pro_codprod, pro_grupopro)
                       values (d.pro_codigo, d.pro_nome,  d.pro_codprod, d.pro_grupopro);


 pcli2 = pcli;
 vgrupopro2 = pgrupopro;

 if (pcli = 0 or pcli is null) then
  begin
   pcli = 1;
   pcli2 = 9999;
  end

 if (pgrupopro = 0 or pgrupopro is null) then
  begin
   pgrupopro = 0;
   vgrupopro2 = 999;
  end

 if (pgrupoloja = true) then
  begin
    select c.cli_redeloja
    from clientes c
    where c.cli_codigo = :pcli
    into :vgrupolojas;
  end

if (pgrupoloja <> true) then
 begin
  if (puf = 'XX') then -- nao escolheu estado
   begin
     for
        select i.ite_produto,
               max(left(i.ite_nomeprod, 50)),
               sum(i.ite_quant),
               sum(i.ite_totliquido)
        from pedidos t
        join itens_ped i on i.ite_pedido = t.ped_pedido and t.ped_industria = i.ite_industria
        join pro_tempcurva x on i.ite_produto =  x.pro_codprod
        where t.ped_data between :pdata1 and :pdata2 and
              t.ped_situacao in ('P','F') and
              t.ped_cliente between :pcli and :pcli2 and
              coalesce(x.pro_grupopro, 0) between :pgrupopro and :vgrupopro2 and
              t.ped_industria = :pind
        group by 1
        order by 3 desc
        into :vcodigo, :vdescricao, :vquant, :vvalor
     do
     insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor) values (:vcodigo, :vdescricao, :vquant, :vvalor);
   end

 if (puf <> 'XX') then -- escolheu um estado
   begin
    for
        select i.ite_produto,
               max(left(i.ite_nomeprod, 50)),
               sum(i.ite_quant),
               sum(i.ite_totliquido)
        from pedidos t
        join itens_ped i on i.ite_pedido = t.ped_pedido -- and t.ped_industria = :pind
        left join pro_tempcurva x on i.ite_produto =  x.pro_codprod
        left join clientes c on t.ped_cliente = c.cli_codigo
        where t.ped_data between :pdata1 and :pdata2 and
              t.ped_situacao in ('P','F') and
              t.ped_cliente between :pcli and :pcli2 and
              coalesce(x.pro_grupopro, 0) between :pgrupopro and :vgrupopro2 and
              t.ped_industria = :pind and
              c.cli_uf = :puf
        group by 1
        order by 3 desc
        into :vcodigo, :vdescricao, :vquant, :vvalor
     do
     insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor) values (:vcodigo, :vdescricao, :vquant, :vvalor);
   end
 end

 if (pgrupoloja = true) then
  begin
   begin
     for
        select i.ite_produto,
               max(left(i.ite_nomeprod, 50)),
               sum(i.ite_quant),
               sum(i.ite_totliquido)
        from pedidos t
        join clientes  c on t.ped_cliente = c.cli_codigo
        join itens_ped i on i.ite_pedido = t.ped_pedido and t.ped_industria = i.ite_industria
        join pro_tempcurva x on i.ite_produto =  x.pro_codprod
        where t.ped_data between :pdata1 and :pdata2 and
              t.ped_situacao in ('P','F') and
              t.ped_industria = :pind and
              c.cli_redeloja = :vgrupolojas
        group by 1
        order by 3 desc
        into :vcodigo, :vdescricao, :vquant, :vvalor
     do
     insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor) values (:vcodigo, :vdescricao, :vquant, :vvalor);
   end
  end
end^


ALTER PROCEDURE SP_CURVA_04 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE,
    PCLI INTEGER,
    PCLI2 INTEGER,
    PUF VARCHAR(2))
AS
declare variable VDESCRICAO varchar(50);
declare variable VVALOR numeric(15,2);
declare variable VQUANT numeric(8,2);
begin
 delete from curvaabc where valor > 0;
 delete from tab_temp where tmp_valor > 0;

 if (pcli = 0 or pcli is null) then
  begin
   pcli = 1;
   pcli2 = 999;
  end
  else
  pcli2 = pcli;

 if (puf is null or puf = '') then  puf = 'XX';

  if (puf <> 'XX') then
   begin
     for
        select g2.gru_nome,
               sum(i.ite_quant),
               sum(i.ite_totliquido)
        from itens_ped i
        join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
        join clientes c on p.ped_cliente = c.cli_codigo
        join produtos t on i.ite_produto = t.pro_codprod
        join grupos g2 on t.pro_grupopro = g2.gru_codigo
        where p.ped_industria = :pInd and
              p.ped_data between :pdata1 and :pdata2  and
              p.ped_situacao in ('P','F') and
              p.ped_cliente between :pcli and :pCli2 and
              c.cli_uf = :pUF
        group by 1
        order by 2 desc
        into :vdescricao, :vquant, :vvalor
     do
     insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor) values (:vdescricao, :vdescricao, :vquant, :vvalor);
   end

  if (puf = 'XX') then
   begin
     for
        select g2.gru_nome,
               sum(i.ite_quant),
               sum(i.ite_totliquido)
        from itens_ped i
        join pedidos p on i.ite_pedido = p.ped_pedido and i.ite_industria = p.ped_industria
        join produtos t on i.ite_produto = t.pro_codprod
        join grupos g2 on t.pro_grupopro = g2.gru_codigo
        where p.ped_industria = :pInd and
              p.ped_data between :pdata1 and :pdata2  and
              p.ped_situacao in ('P','F') and
              p.ped_cliente between :pcli and :pCli2
        group by 1
        order by 2 desc
        into :vdescricao, :vquant, :vvalor
     do
     insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor) values (:vdescricao, :vdescricao, :vquant, :vvalor);
   end

end^


ALTER PROCEDURE SP_CURVA_05 (
    PDATA1 DATE,
    PDATA2 DATE,
    PIND INTEGER,
    PUF VARCHAR(2))
AS
declare variable VDESCRICAO varchar(50);
declare variable VVALOR numeric(15,2);
declare variable VQUANT numeric(8,2);
begin
 delete from curvaabc where valor > 0;
 delete from tab_temp where tmp_valor > 0;

 if (puf is null or puf = '') then
  puf = 'XX';

  if (puf <> 'XX') then
  begin
    for
      select left(c.cli_redeloja, 25),
         sum(i.ite_quant),
         sum(i.ite_totliquido)
         from itens_ped i
         join pedidos  p on i.ite_pedido = p.ped_pedido and i.ite_industria  = p.ped_industria
         join clientes c on p.ped_cliente = c.cli_codigo
         where p.ped_data between :pdata1  and :pdata2 and
               p.ped_situacao in ('P','F') and
               p.ped_industria = :pind and
               c.cli_tipopes = 'A' and
               c.cli_uf = :puf
         group by 1
         order by 3 desc
         into :vdescricao, :vquant, :vvalor
     do
     insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor) values (:vdescricao, :vdescricao, :vquant, :vvalor);
  end

  if (puf = 'XX') then
  begin
    for
      select left(c.cli_redeloja, 25),
         sum(i.ite_quant),
         sum(i.ite_totliquido)
         from itens_ped i
         join pedidos  p on i.ite_pedido = p.ped_pedido and i.ite_industria  = p.ped_industria
         join clientes c on p.ped_cliente = c.cli_codigo
         where p.ped_data between :pdata1  and :pdata2 and
               p.ped_situacao in ('P','F') and
               p.ped_industria = :pind and
               c.cli_tipopes = 'A'
         group by 1
         order by 3 desc
         into :vdescricao, :vquant, :vvalor
     do
     insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor) values (:vdescricao, :vdescricao, :vquant, :vvalor);
  end
end^


ALTER PROCEDURE SP_CURVA_06 (
    PDATA1 DATE,
    PDATA2 DATE,
    PCLI INTEGER,
    PIND INTEGER)
AS
declare variable VDESCRICAO varchar(50);
declare variable VCODIGO varchar(25);
declare variable VVALOR numeric(15,2);
declare variable VQUANT numeric(8,2);
declare variable VGERAL numeric(15,2);
begin

 delete from curvaabc where valor > 0;
 delete from tab_temp where tmp_valor > 0;
 for
  with xProd as(select t.pro_codprod as procod, max(t.pro_nome) descricao
              from produtos t
              where t.pro_industria = :pind
              group by 1 order by 1)

  select i.ite_produto,
         max(xp.descricao),
         sum(case when p.ped_cliente = :pcli  then i.ite_quant else 0 end),
         sum(case when p.ped_cliente = :pcli  then i.ite_totliquido else 0 end),
         sum(case when p.ped_cliente <> :pcli then i.ite_quant else 0 end)
         from itens_ped i
         join pedidos p on i.ite_pedido = p.ped_pedido and p.ped_industria = :pind
         left join xProd xp on i.ite_produto = xp.procod
         where p.ped_situacao in ('P', 'F') and
         p.ped_data between :pdata1 and :pdata2
         group by 1
         having sum(case when p.ped_cliente = :pcli then i.ite_totliquido else 0 end)> 0
         order by 3 desc
         into :vcodigo, :vdescricao, :vquant, :vvalor, :vgeral
 do
  insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor, tmp_geral) values (:vcodigo, :vdescricao, :vquant, :vvalor, :vgeral);
end^


ALTER PROCEDURE SP_CURVA_07 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE,
    PGRP INTEGER,
    PCLI INTEGER)
AS
declare variable VDESCRICAO varchar(50);
declare variable VVALOR numeric(15,2);
declare variable VSQL varchar(1000);
declare variable VLB char(2);
declare variable VQUANT numeric(8,2);
declare variable VSQLQRY varchar(500);
declare variable VCONVERSAO varchar(25);
declare variable PCLI2 integer;
begin
 vlb  = ascii_char(13)||ascii_char(10);
 vSql = '';
 delete from curvaabc where valor > 0;
 delete from tab_temp where tmp_valor > 0;

 if (pcli = 0 or pcli is null) then
  begin
   pcli = 1;
   pcli2 = 999;
  end
  else
  pcli2 = pcli;

 vsqlqry =  'with xProd as (select pr.pro_codprod Codigo, max(g.gru_nome) Descricao '
      ||vlb||'from produtos pr '
      ||vlb||'join grupos g on g.gru_codigo = '|| :pGrp ||' '
      ||vlb||'where pr.pro_industria = ' || :pind || ' '
      ||vlb||'group by 1 ) ';

 vsql = 'select i.ite_produto, x.descricao, sum(i.ite_quant) as Quant, sum(i.ite_totliquido) as Valor '
         ||vlb||'from itens_ped i '
         ||vlb||'join pedidos p on i.ite_pedido = p.ped_pedido and p.ped_industria = :xInd '
         ||vlb||'join xprod x on i.ite_produto = x.codigo '
         ||vlb||'where p.ped_data between :xData1 and :xData2 and '
         ||vlb||'p.ped_cliente between :xCli1 and :xCli2 and '
         ||vlb||'p.ped_situacao in (''P'',''F'') '
         ||vlb||'group by 1,2 '
         ||vlb||'order by 1 ';

  vsql = vsqlqry
         ||vlb|| vsql;
 for
   execute statement (vSql) (xind := pind, xdata1 := :pdata1, xdata2 := :pdata2, xCli1 := :pcli, xCli2 := :pcli2)
   into :vconversao, :vdescricao, :vquant, :vvalor
 do
 begin
  insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor) values (:vconversao, :vdescricao, :vquant, :vvalor);
 end
end^


ALTER PROCEDURE SP_CURVA_08 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE,
    PRLJ VARCHAR(35))
AS
declare variable VDESCRICAO varchar(50);
declare variable VVALOR numeric(15,2);
declare variable VQUANT numeric(8,2);
declare variable VREDELOJA varchar(35);
declare variable VCONVERSAO varchar(25);
declare variable VCODPROD varchar(25);
begin
 delete from curvaabc where valor > 0;
 delete from tab_temp where tmp_valor > 0;
 delete from pro_tempcurva where pro_id > 0;
-- filtra a tabela da industra agrupando por codigo do produto
 for
  select p.pro_codprod,
         max(p.pro_nome)
  from produtos p
  where p.pro_industria = :pind
  group by 1
  into :vcodprod, :vdescricao
 do
  insert into pro_tempcurva (pro_codprod, pro_descricao) values (:vcodprod, :vdescricao);
--
 for
   select i.ite_produto Codigo,
          max(p2.pro_descricao),
          sum(i.ite_quant) Quant,
          sum(i.ite_totliquido),
          max(c.cli_redeloja)
   from itens_ped i
   join pedidos       p on i.ite_pedido   = p.ped_pedido and p.ped_industria = :pind
   join clientes      c on p.ped_cliente  = c.cli_codigo
   join pro_tempcurva p2 on i.ite_produto = p2.pro_codprod
   where p.ped_situacao in ('P', 'F') and
   p.ped_data between :pData1 and :pData2 and
   c.cli_redeloja = :prlj
   group by 1
   order by 3 desc
   into :vconversao, :vdescricao, :vquant, :vvalor, :vredeloja
 do
 begin
  insert into tab_temp (tmp_conversao, tmp_descricao, tmp_quant, tmp_valor, tmp_proid) values
                       (:vconversao, :vdescricao, :vquant, :vvalor, :vredeloja);
 end
end^


ALTER PROCEDURE SP_CURVA_09 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE)
AS
declare variable VVALOR numeric(15,2);
declare variable VQUANT numeric(8,2);
declare variable VREGIAO varchar(50);
begin
  delete from tab_temp where tmp_valor > 0;
  delete from curvaabc where valor > 0;
  for
    select c.cli_uf,
           sum(v.total),
           sum(v.quant)
    from (select
          p.ped_cliente, i.ite_totliquido total, i.ite_quant quant
          from itens_ped i
          join pedidos p on i.ite_pedido = p.ped_pedido and p.ped_industria = :pind
          where p.ped_data between :pData1 and :pdata2 and
          p.ped_situacao in ('P','F')
          order by 1) v
    join clientes c on v.ped_cliente = c.cli_codigo
    group by 1
    into :vregiao, :vvalor, :vquant
   do
   begin
     insert into tab_temp (tmp_conversao, tmp_quant, tmp_valor, tmp_descricao) values
                          (:vregiao, :vquant, :vvalor, :vregiao);
   end
end^


ALTER PROCEDURE SP_CURVA_10 (
    PIND INTEGER,
    PDATA1 DATE,
    PDATA2 DATE,
    PVENDEDOR INTEGER)
AS
declare variable VVALOR numeric(15,2);
declare variable VQUANT numeric(8,2);
declare variable VREGIAO varchar(50);
begin
  delete from tab_temp where tmp_valor > 0;
  delete from curvaabc where valor > 0;
  for
    select
    r.reg_descricao, v.total total, v.quant quant
    from (select
          p.ped_cliente, sum(i.ite_totliquido) as total, sum(i.ite_quant) as quant
          from itens_ped i
          join pedidos p on i.ite_pedido = p.ped_pedido and p.ped_industria = :pind
          where p.ped_data between :pData1 and :pdata2 and
          p.ped_situacao in ('P','F')
          group by 1) v
    join clientes c on v.ped_cliente = c.cli_codigo
    join regioes  r on c.cli_regiao2 = r.reg_codigo
    into :vregiao, :vvalor, :vquant
   do
   begin
     insert into tab_temp (tmp_industria, tmp_valor, tmp_quant, tmp_descricao, tmp_conversao) values
                          (:pind, :vvalor, :vquant, :vregiao, :vregiao);
   end
end^


ALTER PROCEDURE SP_DEL_ITE_PED (
    IIND INTEGER,
    IPRO VARCHAR(25),
    IEMB VARCHAR(25),
    IPED VARCHAR(10))
AS
begin
  delete from itens_ped
  where ite_produto = :ipro and
        ite_embuch  = :iemb and
        ite_industria = :iind and
        ite_pedido = :iped;
end^


ALTER PROCEDURE SP_DELETA_PROD_DUPL (
    ITABELA VARCHAR(20),
    IFOR INTEGER)
AS
begin
  merge into produtos a
  using ( select a.RDB$DB_KEY chave
          from produtos a
          join ( select a.pro_codprod, min(a.RDB$DB_KEY) db_chave
                 from produtos a
                 where a.pro_nometabela = :itabela and a.pro_industria = :ifor
                 group by a.pro_codprod
                 having count(*) > 1) b on b.pro_codprod = a.pro_codprod and b.db_chave <> a.RDB$DB_KEY
          where a.pro_nometabela = :itabela and
                a.pro_industria = :ifor ) b
  on a.RDB$DB_KEY = b.chave

  when matched then delete;
end^


ALTER PROCEDURE SP_DELETAITEMPED (
    IIND INTEGER,
    IPED VARCHAR(10))
AS
begin
  delete from itens_ped
  where ite_pedido = :iped and
        ite_industria = :iind;
end^


ALTER PROCEDURE SP_DRE (
    PDT1 DATE,
    PDT2 DATE)
RETURNS (
    CON_CODIGO INTEGER,
    CON_DESCRICAO VARCHAR(50),
    CON_GRAU VARCHAR(10),
    TOTAL_CONTA DOUBLE PRECISION)
AS
begin
 for
    select
           cc.con_codigo,
           cc.con_descricao,
           cc.con_grau,
           sum(iif(m.lan_credeb = 'R', m.lan_valorpago, (m.lan_valorpago * -1))) as total_conta
    from contas cc
    join contaspgrec m on m.lan_conta = cc.con_codigo
    where m.lan_datapago between :pDt1 and :pDt2 and
          cc.con_tipo = 'A'
    group by 1,2,3
    order by cc.con_grau asc
    into :con_codigo, :con_descricao, :con_grau, :total_conta
 do
 suspend;
end^


ALTER PROCEDURE SP_FLUXO (
    CODCONTA INTEGER,
    INICIO DATE,
    FIM DATE)
RETURNS (
    LANCAMENTO INTEGER,
    TIPO VARCHAR(10),
    CLIFOR VARCHAR(60),
    CREDITO NUMERIC(15,2),
    DEBITO NUMERIC(15,2),
    DATALANCAMENTO DATE,
    DESCRICAO VARCHAR(300),
    CONTA VARCHAR(80))
AS
declare variable CF_TIPO varchar(1);
declare variable VALOR numeric(15,2);
begin
 if (codconta > 0) then
   begin
      for
        select f.cta_id lan_lancto, f.cta_data lan_data,
               iif(l.lan_credeb = 'R', 'E', 'S') lan_credeb, lan_clifornome,
               l.lan_descricao, f.cta_valorpago lan_valor,
               c.con_descricao
        from fracrecebimentos f
        join contaspgrec l on f.cta_id    = l.lan_lancto
        join contas c on f.cta_conta = c.con_codigo
        where f.cta_data between :inicio and :fim and
              f.cta_conta = :codconta
        
        union
        
        select f.cta_id lan_lancto, f.cta_data lan_data,
               iif(l.lan_credeb = 'R', 'E', 'S') lan_credeb, lan_clifornome,
               l.lan_descricao, f.cta_valorpago lan_valor,
               c.con_descricao
        from fracrecebimentos f
        join contaspgrec l on f.cta_id     = l.lan_lancto
        join contas c on f.cta_contadebito = c.con_codigo
        where f.cta_data between :inicio and :fim and
              f.cta_contadebito = :codconta
        
        union
        

        select cx.cai_lancamento lan_lancto, cx.cai_data lan_data,
              iif(cx.cai_dc = 'C', 'E', 'S') lan_credeb,
               cx.cai_clifornome lan_clifornome, cx.cai_historico lan_descricao, cx.cai_valor lan_valor,
               c1.con_descricao
        from caixa cx
        join contas c1 on cx.cai_conta = c1.con_codigo
        where cx.cai_data between :inicio and :fim and
              cx.cai_conta = :codconta and
              cx.cai_contadebito > 0
        
        union
        
        select cx.cai_lancamento lan_lancto, cx.cai_data lan_data,
               iif(cx.cai_dc = 'C', 'E', 'S') lan_credeb,
               cx.cai_clifornome lan_clifornome, cx.cai_historico lan_descricao, cx.cai_valor lan_valor,
               c1.con_descricao
        from caixa cx
        join contas c1 on cx.cai_contadebito = c1.con_codigo
        where cx.cai_data between :inicio and :fim and
              cx.cai_contadebito = :codconta and
              cx.cai_conta > 0

        order by 3


        into :lancamento, :datalancamento, :cf_tipo, :clifor, :descricao, :valor, :conta
      do
      begin
        tipo = iif(cf_tipo = 'R', 'cliente', 'Fornecedor');

        if (cf_tipo = 'E') then
        begin
          credito = valor;
          debito = null;
        end
        else
        begin
          credito = null;
          debito = valor;
        end
        suspend;
      end
   end
 if (codconta = 0) then
   begin
      for
        select f.cta_id lan_lancto, f.cta_data lan_data,
               iif(l.lan_credeb = 'R', 'E', 'S') lan_credeb, lan_clifornome,
               l.lan_descricao, f.cta_valorpago lan_valor,
               c.con_descricao
        from fracrecebimentos f
        join contaspgrec l on f.cta_id    = l.lan_lancto
        join contas c on f.cta_conta = c.con_codigo
        where f.cta_data between :inicio and :fim
        
        union
        
        select f.cta_id lan_lancto, f.cta_data lan_data,
               iif(l.lan_credeb = 'R', 'E', 'S') lan_credeb, lan_clifornome,
               l.lan_descricao, f.cta_valorpago lan_valor,
               c.con_descricao
        from fracrecebimentos f
        join contaspgrec l on f.cta_id     = l.lan_lancto
        join contas c on f.cta_contadebito = c.con_codigo
        where f.cta_data between :inicio and :fim
        
        union
        
        select cx.cai_lancamento lan_lancto, cx.cai_data lan_data,
              iif(cx.cai_dc = 'C', 'E', 'S') lan_credeb,
               cx.cai_clifornome lan_clifornome, cx.cai_historico lan_descricao, cx.cai_valor lan_valor,
               c1.con_descricao
        from caixa cx
        join contas c1 on cx.cai_conta = c1.con_codigo
        where cx.cai_data between :inicio and :fim and
              cx.cai_conta > 0 and
              cx.cai_contadebito > 0
        
        union
        
        select cx.cai_lancamento lan_lancto, cx.cai_data lan_data,
               iif(cx.cai_dc = 'C', 'E', 'S') lan_credeb,
               cx.cai_clifornome lan_clifornome, cx.cai_historico lan_descricao, cx.cai_valor lan_valor,
               c1.con_descricao
        from caixa cx
        join contas c1 on cx.cai_contadebito = c1.con_codigo
        where cx.cai_data between :inicio and :fim and
              cx.cai_conta > 0 and
              cx.cai_contadebito > 0
        
        order by 3

        into :lancamento, :datalancamento, :cf_tipo, :clifor, :descricao, :valor, :conta
      do
      begin
        tipo = iif(cf_tipo = 'R', 'cliente', 'Fornecedor');
        if (cf_tipo = 'E') then
        begin
          credito = valor;
          debito = null;
        end
        else
        begin
          credito = null;
          debito = valor;
        end
        suspend;
      end
   end
end^


ALTER PROCEDURE SP_FLUXOPREV (
    CODCONTA INTEGER,
    INICIO DATE,
    FIM DATE)
RETURNS (
    LANCAMENTO INTEGER,
    TIPO VARCHAR(10),
    CLIFOR VARCHAR(60),
    CREDITO NUMERIC(15,2),
    DEBITO NUMERIC(15,2),
    DATALANCAMENTO DATE,
    DESCRICAO VARCHAR(300),
    CONTA VARCHAR(80))
AS
declare variable CF_TIPO varchar(1);
declare variable VALOR numeric(15,2);
begin
 if (codconta > 0) then
   begin
      for
        select l.lan_lancto, l.lan_data, l.lan_credeb, lan_clifornome, l.lan_descricao, l.lan_valor, c.con_descricao
        from contaspgrec l, contas c
        where l.lan_conta = c.con_codigo and
              l.lan_conta = :codconta and
              l.lan_vencimento between :inicio and :fim
        into :lancamento, :datalancamento, :cf_tipo, :clifor, :descricao, :valor, :conta
      do
      begin
        if (cf_tipo = 'R') then
          tipo = 'cliente';
        else
          tipo = 'fornecedor';
        if (cf_tipo = 'R') then
        begin
          credito = valor;
          debito = null;
        end
        else
        begin
          credito = null;
          debito = valor;
        end
        suspend;
      end
   end
 if (codconta = 0) then
   begin
      for
        select l.lan_lancto, l.lan_data, l.lan_credeb, lan_clifornome, l.lan_descricao, l.lan_valor, c.con_descricao
        from contaspgrec l
        left join contas c on l.lan_conta = c.con_codigo
        where l.lan_vencimento between :inicio and :fim
        into :lancamento, :datalancamento, :cf_tipo, :clifor, :descricao, :valor, :conta
      do
      begin
        if (cf_tipo = 'R') then
          tipo = 'cliente';
        else
          tipo = 'fornecedor';
        if (cf_tipo = 'R') then
        begin
          credito = valor;
          debito = null;
        end
        else
        begin
          credito = null;
          debito = valor;
        end
        suspend;
      end
   end
end^


ALTER PROCEDURE SP_IMPTABELA (
    PBLOB BLOB SUB_TYPE TEXT SEGMENT SIZE 80)
AS
begin
 merge into produtos as p
 using ( select
         cind, cdesconto, cgrupoprod, ctabela, cdatatab, cvencpromo, cstatus,
         ccodigo, cdescr, cpreco1, cpreco2, cpreco3, cdbarras, cpeso, caplic,
         cembal, cst, cipi, ccodori, cprepeso, cconversao, cdescespec, cncm,
         cdescadd, ccodigo2, cpercomgrupo, csetor
         from sp_quebrablob(:pblob)
         order by ccodigo2
       ) as dd
 on (p.pro_industria = dd.cind and p.pro_nometabela = ctabela and p.ite_codigo2 = dd.ccodigo2)
 when matched then
  update set
       pro_industria  = dd.cind,     pro_grupo        = dd.cdesconto,  pro_grupopro    = dd.cgrupoprod,   pro_nometabela  = dd.ctabela,
       pro_datatabela = dd.cdatatab, pro_vencpromocao = dd.cvencpromo, pro_linha       = dd.cstatus,      ite_prepeso     = dd.cprepeso,
       pro_codprod    = dd.ccodigo,  pro_nome         = dd.cdescr,     pro_valornormal = dd.cpreco1,      pro_valorpromo  = dd.cpreco2,
       pro_preco3     = dd.cpreco3,  pro_codbarras    = dd.cdbarras,   ite_peso        = dd.cpeso,        pro_aplicacao2  = dd.caplic,
       pro_embalagem  = dd.cembal,   pro_st           = dd.cst,        pro_ipi         = dd.cipi,         pro_codoriginal = dd.ccodori,
       ite_conversao  = dd.cconversao, pro_descadic2  = dd.cdescespec, pro_ncm         = dd.cncm,
       pro_descadic   = dd.cdescadd, ite_codigo2      = dd.ccodigo2,   pro_qtdped      = dd.cpercomgrupo, pro_setor       = dd.csetor
 when not matched then
  insert
      (pro_industria, pro_grupo, pro_grupopro, pro_nometabela, pro_datatabela, pro_vencpromocao, pro_linha,
       pro_codprod, pro_nome, pro_valornormal, pro_valorpromo, pro_preco3, pro_codbarras, ite_peso, pro_aplicacao2,
       pro_embalagem, pro_st, pro_ipi, pro_codoriginal, ite_prepeso, ite_conversao, pro_descadic2,
       pro_ncm, pro_descadic, ite_codigo2, pro_qtdped, pro_setor)
  values
      (dd.cind, dd.cdesconto, dd.cgrupoprod, dd.ctabela, dd.cdatatab, dd.cvencpromo, dd.cstatus,
       dd.ccodigo,dd.cdescr, dd.cpreco1, dd.cpreco2, dd.cpreco3, dd.cdbarras, dd.cpeso, dd.caplic,
       dd.cembal, dd.cst,  dd.cipi, dd.ccodori, dd.cprepeso, dd.cconversao, dd.cdescespec, dd.cncm,
       dd.cdescadd, dd.ccodigo2, dd.cpercomgrupo, dd.csetor);
end^


ALTER PROCEDURE SP_INS_CAIXA
RETURNS (
    OCHAVE INTEGER)
AS
begin
  oChave = gen_id(gen_caixa_id, 1);
end^


ALTER PROCEDURE SP_INS_CLIENTES
RETURNS (
    OCHAVE INTEGER)
AS
begin
  oChave = gen_id(gen_clientes_id, 1);
end^


ALTER PROCEDURE SP_INS_CREDDEV
RETURNS (
    OCHAVE INTEGER)
AS
begin
  oChave = gen_id(gen_cred_dev_id, 1);
end^


ALTER PROCEDURE SP_INS_FORMAPG
RETURNS (
    OCHAVE INTEGER)
AS
begin
  oChave = gen_id(gen_forma_pagamento_id, 1);
end^


ALTER PROCEDURE SP_INS_GRUPOPRO
RETURNS (
    OCHAVE INTEGER)
AS
begin
  oChave = gen_id(gen_grupos_id, 1);
end^


ALTER PROCEDURE SP_INS_GRUPOPRODES
RETURNS (
    OCHAVE INTEGER)
AS
begin
  oChave = gen_id(gen_grupo_desc_id, 1);
end^


ALTER PROCEDURE SP_INS_INDUSTRIA
RETURNS (
    OCHAVE INTEGER)
AS
begin
  oChave = gen_id(gen_fornecedores_id, 1);
end^


ALTER PROCEDURE SP_INS_TRANSP
RETURNS (
    OCHAVE INTEGER)
AS
begin
  oChave = gen_id(gen_transportadora_id, 1);
end^


ALTER PROCEDURE SP_INSEREPEDIDO (
    IPEDIDO VARCHAR(10),
    INUMPED INTEGER,
    IDATA DATE,
    IINDUSTRIA INTEGER,
    ICLIENTE INTEGER,
    ITRANSP INTEGER,
    IVENDEDOR INTEGER,
    ITABELA VARCHAR(20),
    ICONDPAG VARCHAR(100),
    ISITUACAO VARCHAR(1),
    ITIPOFRETE VARCHAR(1),
    IEXPORTADO VARCHAR(1),
    ICOMPRADOR VARCHAR(30),
    IEMAILCOMP VARCHAR(60),
    IPRI DOUBLE PRECISION,
    ISEG DOUBLE PRECISION,
    ITER DOUBLE PRECISION,
    IQUA DOUBLE PRECISION,
    IQUI DOUBLE PRECISION,
    ISEX DOUBLE PRECISION,
    ISET DOUBLE PRECISION,
    IOIT DOUBLE PRECISION,
    INOV DOUBLE PRECISION,
    IDEZ DOUBLE PRECISION)
AS
begin
 in autonomous transaction do
  begin
      insert into pedidos (ped_pedido, ped_data, ped_numero, ped_industria, ped_cliente, ped_transp, ped_vendedor, ped_tabela,
                           ped_condpag, ped_situacao, ped_tipofrete, ped_exportado, ped_comprador, ped_emailcomp,
                           ped_pri, ped_seg, ped_ter, ped_qua, ped_qui, ped_sex, ped_set, ped_oit, ped_nov, ped_dez)
                  values  (:ipedido, :idata, :inumped, :iindustria, :icliente, :itransp, :ivendedor, :itabela, :icondpag, :isituacao,
                           :itipofrete, :iexportado, :icomprador, :iemailcomp, :ipri, :iseg, :iter, :iqua, :iqui, :isex, :iset,
                           :ioit, :inov, :idez);
  end
end^


ALTER PROCEDURE SP_INSERIR_REPL (
    PDADOS VARCHAR(31900))
RETURNS (
    SQL VARCHAR(2000))
AS
declare variable VDADOS varchar(2000);
begin
  for
    select
      sp.linha
    from sp_split_receber(:pDados, '|') sp
    into vDados
  do
  begin
    sql = vDados;
    execute statement sql;   -- os comandos de insert ou update vem passado como parametro no pDados
  end
End^


ALTER PROCEDURE SP_MONTA_CURVA (
    PIND INTEGER,
    VINDEXCURVA INTEGER,
    VFILTRO CHAR(1),
    PDATA1 DATE,
    PDATA2 DATE,
    PUF CHAR(2),
    PCLI INTEGER,
    PGRP INTEGER,
    PGRUPOLOJA BOOLEAN)
RETURNS (
    DESCRICAO VARCHAR(50),
    QUANTIDADE DOUBLE PRECISION,
    VALOR DOUBLE PRECISION,
    PERCENTUAL DOUBLE PRECISION,
    ACUMULADO DOUBLE PRECISION,
    CLASSIFICACAO VARCHAR(1),
    GERAL DOUBLE PRECISION,
    CONVERSAO VARCHAR(25),
    PERC DOUBLE PRECISION,
    PERCQTD DOUBLE PRECISION)
AS
declare variable TOTGERAL double precision;
declare variable QTDGERAL double precision;
begin
--  if (pgrupoloja = true) then
--   begin
--     select c.cli_redeloja
--     from clientes c
--     where c.cli_codigo = :pcli
--     into :vgrupolojas;
--   end

  acumulado  = 0;
  perc       = 0;
  percqtd    = 0;

  if (vindexcurva = 1) then --curva clientes
   execute procedure sp_curva_01(:pdata1, :pdata2, :pind, :puf,  null);
  if (vindexcurva = 2) then --curva industrias
   execute procedure sp_curva_02(:pdata1, :pdata2, :pcli, :puf,  null);
  if (vindexcurva = 3) then --curva produtos
   execute procedure sp_curva_03(:pdata1, :pdata2, :pcli, null, :pind, :puf, :pgrp, :pgrupoloja);
  if (vindexcurva = 4) then --curva por grupo de produtos
   execute procedure sp_curva_04(:pind, :pdata1, :pdata2, :pcli, null, :puf);
  if (vindexcurva = 5) then --curva grupo de lojas
   execute procedure sp_curva_05(:pdata1, :pdata2, :pind, :puf);
  if (vindexcurva = 6) then --curva cliente em comparacao aos demais
   execute procedure sp_curva_06(:pdata1, :pdata2, :pcli, :pind);
  if (vindexcurva = 7) then --em breve
   --execute procedure sp_curva_07(:pind, :pdata1, :pdata2, :pgrp, :pcli);
  if (vindexcurva = 8) then --curva produtos vendidos por grupo de lojas
   execute procedure sp_curva_08(:pind, :pdata1, :pdata2, :pgrupoloja);
  if (vindexcurva = 9) then --desempenho por regiao
  execute procedure sp_curva_09(:pind, :pdata1, :pdata2);
  if (vindexcurva = 10) then --desempenho por regiao
  execute procedure sp_curva_10(:pind, :pdata1, :pdata2, 0);

  select sum(t.tmp_valor), sum(t.tmp_quant)
  from tab_temp t
  into :totgeral, :qtdgeral;

  if (vfiltro = 'V') then
   begin
      for
       select
       tmp_conversao,
       c.tmp_descricao,
       c.tmp_valor,
       c.tmp_quant,
       coalesce(c.tmp_valor, 0) / (:totgeral) * 100,
       coalesce(c.tmp_quant, 0) / (:qtdgeral) * 100,
       coalesce(c.tmp_geral,  0)
       from tab_temp c
       where coalesce(c.tmp_valor, 0) > 0
       order by 3 desc
       into :conversao, :descricao, :valor, :quantidade, :percentual, :percqtd, :geral
      do
      begin
        acumulado = acumulado + percentual;
        if (acumulado > 0 and acumulado < 80) then
          classificacao = 'A';
        else if (acumulado > 0 and acumulado < 95) then
          classificacao = 'B';
        else
          classificacao = 'C';
        suspend;
      end
   end

  if (vfiltro = 'Q') then
   begin
      for
       select
       tmp_conversao,
       c.tmp_descricao,
       c.tmp_valor,
       c.tmp_quant,
       coalesce(c.tmp_valor, 0) / (:totgeral) * 100,
       coalesce(c.tmp_quant, 0) / (:qtdgeral) * 100,
       coalesce(c.tmp_geral,  0)
       from tab_temp c
       where coalesce(c.tmp_valor, 0) > 0
       order by 4 desc
       into :conversao, :descricao, :valor, :quantidade, :percentual, :percqtd, :geral
      do
      begin
        acumulado = acumulado + percqtd;
        if (acumulado > 0 and acumulado < 80) then
         classificacao = 'A';
        else if (acumulado > 0 and acumulado < 95) then
         classificacao = 'B';
        else
         classificacao = 'C';
       suspend;
      end
   end
end^


ALTER PROCEDURE SP_MONTAREPLICADOR (
    ITABELAS VARCHAR(2000))
RETURNS (
    VVALOR VARCHAR(50))
AS
declare variable VPARTE varchar(1000);
declare variable VLINHA varchar(1000);
declare variable VIDX integer;
begin
  for
    select bp.parte
    from sp_blobempartes(:iTabelas,'|') bp
    into vParte
  do
  begin
    for
      select ss.texto
      from sp_splitstring(:vParte,'|') ss
      into vLinha
    do
    begin
      for
        select ss.idx, trim(nullif(ss.texto, ''))
        from sp_splitstring(:vLinha, ';') ss
        into vIdx, vValor
      do
      begin
        suspend;
      end
    end
  end



end^


ALTER PROCEDURE SP_MONTATABELAS (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80)
AS
declare variable VIDX integer;
declare variable VPARTE varchar(30000);
declare variable VLINHA varchar(500);
declare variable VVALOR varchar(300);
declare variable VIDPROD integer;
declare variable CIND varchar(3);
declare variable CPRODUTO varchar(25);
declare variable CTABELA varchar(20);
declare variable CGRUPODES integer;
declare variable CDESCADD double precision;
declare variable CIPI double precision;
declare variable CST double precision;
declare variable CPREPESO double precision;
declare variable CPRECOBRUTO double precision;
declare variable CPRECOPROMO double precision;
declare variable CPRECOESPECIAL double precision;
declare variable CDATATAB varchar(10);
declare variable CDATAVENC varchar(10);
declare variable CSTATUS char(1);
declare variable V_ROWS_UPDATED integer;
declare variable CSTATUS2 boolean;
begin
  for
    select bp.parte
    from sp_blobempartes(:pDados,'|') bp
    into vParte
  do
  begin
    for
      select ss.texto
      from sp_splitstring(:vParte,'|') ss
      into vLinha
    do
    begin
      for
        select ss.idx, trim(nullif(ss.texto, ''))
        from sp_splitstring(:vLinha, ';') ss
        into vIdx, vValor
      do
      begin
        vValor = iif(character_length(vValor) > 0, :vvalor, null);

        if (vIdx = 1)       then cind        = vValor;
        else if (vIdx = 2)  then cproduto    = fn_normalizar_codigo(trim(vValor));
        else if (vIdx = 3)  then ctabela     = trim(vValor);
        else if (vIdx = 4)  then cgrupodes   = :vValor;
        else if (vIdx = 5)  then cdescadd    = :vValor;
        else if (vIdx = 6)  then cipi        = :vValor;
        else if (vIdx = 7)  then cst         = :vValor;
        else if (vIdx = 8)  then cprepeso    = replace(vValor,'/','.');
        else if (vIdx = 9)  then cprecobruto = :vValor;
        else if (vIdx = 10) then cprecopromo = :vValor;
        else if (vIdx = 11) then cprecoespecial = :vValor;
        else if (vIdx = 12) then cdatatab    = :vValor;
        else if (vIdx = 13) then cdatavenc   = :vValor;
        else if (vIdx = 14) then cstatus     = :vValor;
        --
      end

      select cp.pro_id
      from cad_prod cp
      where cp.pro_codigonormalizado = :cproduto
      into :vidprod;

      select count(*)
      from cad_tabelaspre t
      where t.itab_idprod = :vidprod   and
            t.itab_idindustria = :cind and
            t.itab_tabela = :ctabela
      into :v_rows_updated;

      cstatus2 = iif(cstatus = 'T', True, False);
  
      if (v_rows_updated > 0) then
       begin
          update cad_tabelaspre set
            itab_idprod             = :vidprod,
            itab_idindustria        = :cind,
            itab_tabela             = :ctabela,
            itab_grupodesconto      = COALESCE(:cgrupodes, itab_grupodesconto),
            itab_descontoadd        = COALESCE(:cdescadd, itab_descontoadd),
            itab_ipi                = COALESCE(:cipi, itab_ipi),
            itab_st                 = COALESCE(:cst, itab_st),
            itab_prepeso            = COALESCE(:cprepeso, itab_prepeso),
            itab_precobruto         = COALESCE(:cprecobruto, itab_precobruto),
            itab_precopromo         = COALESCE(:cprecopromo, itab_precopromo),
            itab_precoespecial      = COALESCE(:cprecoespecial, itab_precoespecial),
            itab_datatabela         = COALESCE(:cdatatab, itab_datatabela),
            itab_datavencimento     = COALESCE(:cdatavenc, itab_datavencimento),
            itab_status             = COALESCE(:cstatus2, itab_status)
          where
            itab_idprod      = :vidprod and
            itab_idindustria = :cind and
            itab_tabela      = :ctabela;
       end
       else
       begin
          if (v_rows_updated = 0) then  --se nao atualizou nada acima, eh porque o codigo nao existe
           begin
           insert into cad_tabelaspre
           (itab_idprod, itab_idindustria, itab_tabela, itab_grupodesconto, itab_descontoadd,
            itab_ipi, itab_st, itab_prepeso, itab_precobruto, itab_precopromo, itab_precoespecial,
            itab_datatabela, itab_datavencimento, itab_status )
           values
           (:vidprod, :cind, :ctabela, :cgrupodes, :cdescadd,
            :cipi, :cst, :cprepeso, :cprecobruto, :cprecopromo, :cprecoespecial,
            :cdatatab, :cdatavenc, :cstatus2);
           end
       end
    end
  end
end^


ALTER PROCEDURE SP_PORTIFOLIO_VENDAS (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    IDFOR INTEGER,
    NOME VARCHAR(30),
    PORTIFOLIO INTEGER,
    VENDAS INTEGER,
    PERCENTUAL NUMERIC(6,2))
AS
declare variable VPERC numeric(6,2);
begin
 if (imes = 0) then
  begin
      for
       with prod as (
            select p.pro_industria idind,
            count(distinct p.pro_codprod) as portfolio
            from produtos p
            join fornecedores f on p.pro_industria = f.for_codigo
            where f.for_tipo2 = 'A'
            group by 1)
    
        select
            f.for_codigo,
            f.for_nomered,
            max(d.portfolio),
            count(distinct iv.ite_produto)
        from fornecedores f
        join pedidos p    on p.ped_industria = f.for_codigo
        join itens_ped iv on p.ped_pedido = iv.ite_pedido
        join prod d       on p.ped_industria = d.idind
        where extract(year from p.ped_data) = :iAno and
              f.for_tipo2 = 'A'
        group by 1, 2
        order by 4 desc
        into :idfor, :nome, :portifolio, :vendas
      do
      begin
       vperc = (vendas * 100) / portifolio;
       percentual = vperc;
    
       suspend;
      end
 end
 else
 begin
      for
       with prod as (
            select p.pro_industria idind,
            count(distinct p.pro_codprod) as portfolio
            from produtos p
            join fornecedores f on p.pro_industria = f.for_codigo
            where f.for_tipo2 = 'A'
            group by 1)
    
        select
            f.for_codigo,
            f.for_nomered,
            max(d.portfolio),
            count(distinct iv.ite_produto)
        from fornecedores f
        join pedidos p    on p.ped_industria = f.for_codigo
        join itens_ped iv on p.ped_pedido    = iv.ite_pedido
        join prod d       on p.ped_industria = d.idind
        where extract(year from p.ped_data)  = :iAno and
              extract(month from p.ped_data) = :imes and
              f.for_tipo2 = 'A'
        group by 1, 2
        order by 4 desc
        into :idfor, :nome, :portifolio, :vendas
      do
      begin
       vperc = (vendas * 100) / portifolio;
       percentual = vperc;
    
       suspend;
      end
 end


end^


ALTER PROCEDURE SP_QUEBRABLOB (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80)
RETURNS (
    CIND VARCHAR(3),
    CDESCONTO VARCHAR(3),
    CGRUPOPROD VARCHAR(3),
    CTABELA VARCHAR(20),
    CDATATAB VARCHAR(10),
    CVENCPROMO VARCHAR(10),
    CSTATUS VARCHAR(50),
    CCODIGO VARCHAR(25),
    CDESCR VARCHAR(50),
    CPRECO1 VARCHAR(10),
    CPRECO2 VARCHAR(10),
    CPRECO3 VARCHAR(10),
    CDBARRAS VARCHAR(13),
    CPESO VARCHAR(10),
    CAPLIC VARCHAR(100),
    CEMBAL VARCHAR(10),
    CST VARCHAR(10),
    CIPI VARCHAR(10),
    CCODORI VARCHAR(40),
    CPREPESO VARCHAR(10),
    CCONVERSAO VARCHAR(300),
    CDESCESPEC VARCHAR(10),
    CNCM VARCHAR(10),
    CDESCADD VARCHAR(10),
    CCODIGO2 VARCHAR(25),
    CPERCOMGRUPO VARCHAR(10),
    CSETOR VARCHAR(35))
AS
declare variable VPS bigint;
declare variable PTEXTO varchar(800);
declare variable PDELIMITADOR char(1);
begin
  pdelimitador = ';';
  for
    select bp.parte
    from sp_blobempartes(:pDados, '|') bp
    into ptexto
    do
     begin
      vps    = position(pdelimitador, ptexto);
      if (vps > 0) then
      begin
        cind     = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        ctabela  = left(ptexto, vps -1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        ccodigo2 = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        ccodigo  = trim(left(ptexto, vps - 1));
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cpercomgrupo = left(ptexto, vps - 1);
        ptexto       = substring(ptexto from vps+1);
        vps          = position(pdelimitador, ptexto);

        cdesconto = left(ptexto, vps - 1);
        ptexto    = substring(ptexto from vps+1);
        vps       = position(pdelimitador, ptexto);

        cgrupoprod = left(ptexto, vps - 1);
        ptexto     = substring(ptexto from vps+1);
        vps        = position(pdelimitador, ptexto);

        cdatatab = left(ptexto, vps - 1);
        cdatatab = replace(cdatatab,'/','.');
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cvencpromo = left(ptexto, vps - 1);
        cvencpromo = replace(cdatatab,'/','.');
        ptexto     = substring(ptexto from vps+1);
        vps        = position(pdelimitador, ptexto);

        cstatus  = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cdescr   = substring(left(ptexto, vps - 1) from 1 for 50);
        ptexto   = substring(ptexto from vps+1);
        vps     = position(pdelimitador, ptexto);

        cpreco1  = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps     = position(pdelimitador, ptexto);

        cpreco2  = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cpreco3  = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cdbarras = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cpeso    = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps     = position(pdelimitador, ptexto);

        caplic   = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cembal   = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps     = position(pdelimitador, ptexto);

        cst      = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cipi     = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        ccodori  = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cprepeso = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cconversao = left(ptexto, vps - 1);
        ptexto     = substring(ptexto from vps+1);
        vps        = position(pdelimitador, ptexto);

        cdescespec = left(ptexto, vps - 1);
        ptexto     = substring(ptexto from vps+1);
        vps        = position(pdelimitador, ptexto);

        cncm     = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        cdescadd = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        csetor   = left(ptexto, vps - 1);
        ptexto   = substring(ptexto from vps+1);
        vps      = position(pdelimitador, ptexto);

        suspend;
      end
   end
end^


ALTER PROCEDURE SP_RAZAO (
    PDT1 DATE,
    PDT2 DATE)
RETURNS (
    CON_CODIGO INTEGER,
    CON_TIPO VARCHAR(1),
    CON_GRAU VARCHAR(10),
    CON_DESCRICAO VARCHAR(50),
    TOTAL_CONTA DOUBLE PRECISION)
AS
begin
  for
    select distinct
           cc.con_codigo,
           cc.con_tipo,
           cc.con_grau,
           cc.con_descricao,
           sum(m.lan_valorpago) over(partition by cc.con_grau) as total_conta
    from contas cc
    join contaspgrec m on m.lan_conta = cc.con_codigo
    where m.lan_datapago between :pDt1 and :pDt2

    union

    select distinct
         cc1.con_codigo,
         cc1.con_tipo,
         cc1.con_grau,
         cc1.con_descricao,
         sum(cx.cai_valor) over(partition by cc1.con_grau) as total_conta
    from contas cc1
    join caixa cx on cx.cai_conta = cc1.con_codigo
    order by 1 asc

    into :con_codigo, :con_tipo, :con_grau, :con_descricao, :total_conta
  do
  suspend;
end^


ALTER PROCEDURE SP_RECEBEPRODUTOS (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80)
AS
declare variable VIDX integer;
declare variable VPARTE varchar(30000);
declare variable VLINHA varchar(500);
declare variable VVALOR varchar(300);
declare variable CIND varchar(3);
declare variable CCODIGO varchar(25);
declare variable CCODORI varchar(40);
declare variable CCODNORM varchar(25);
declare variable CDESCR varchar(100);
declare variable CEHLANCTO boolean;
declare variable CDATALCTO varchar(10);
declare variable CCURVAABC char(1);
declare variable CCDBARRAS varchar(13);
declare variable CGRUPOPROD varchar(3);
declare variable CSETOR varchar(50);
declare variable CLINHA varchar(50);
declare variable CEMBAL varchar(10);
declare variable CPESO varchar(10);
declare variable CCONVERSAO varchar(300);
declare variable CNCM varchar(10);
declare variable CAPLIC varchar(800);
declare variable CAPLIC2 varchar(800);
declare variable CLEVE boolean;
declare variable CPESADA boolean;
declare variable CAGRICOLA boolean;
declare variable CUTILITARIO boolean;
declare variable COFFROAD boolean;
declare variable CMOTOCICLE boolean;
declare variable CSTATUS char(1);
declare variable V_ROWS_UPDATED integer;
declare variable CSTATUS2 boolean;
declare variable CORIGEM char(1);
begin
  for
    select bp.parte
    from sp_blobempartes(:pDados,'|') bp
    into vParte
  do
  begin
    for
      select ss.texto
      from sp_splitstring(:vParte,'|') ss
      into vLinha
    do
    begin
      for
        select ss.idx, trim(nullif(ss.texto, ''))
        from sp_splitstring(:vLinha, ';') ss
        into vIdx, vValor
      do
      begin
        vValor = iif(character_length(vValor) > 0, :vvalor, null);

        if (vIdx = 1)       then cind       = vValor;
        else if (vIdx = 2)  then ccodigo    = trim(vValor);
        else if (vIdx = 3)  then ccodori    = :vValor;
        else if (vIdx = 4)  then ccodnorm   = fn_normalizar_codigo(trim(ccodigo));
        else if (vIdx = 5)  then cdescr     = :vValor;
        else if (vIdx = 6)  then cehlancto  = :vValor;
        else if (vIdx = 7)  then cdatalcto  = replace(vValor,'/','.');
        else if (vIdx = 8)  then ccurvaabc  = :vValor;
        else if (vIdx = 9)  then ccdbarras  = :vValor;
        else if (vIdx = 10) then cgrupoprod = :vValor;
        else if (vIdx = 11) then csetor     = :vValor;
        else if (vIdx = 12) then clinha     = :vValor;
        else if (vIdx = 13) then cembal     = :vValor;
        else if (vIdx = 14) then cpeso      = :vValor;
        else if (vIdx = 15) then cconversao = :vValor;
        else if (vIdx = 16) then cncm       = :vValor;
        else if (vIdx = 17) then caplic     = :vValor;
        else if (vIdx = 18) then caplic2    = :vValor;
        else if (vIdx = 19) then cleve      = :vValor;
        else if (vIdx = 20) then cpesada    = :vValor;
        else if (vIdx = 21) then cagricola  = :vValor;
        else if (vIdx = 22) then cutilitario = :vValor;
        else if (vIdx = 23) then coffroad    = :vValor;
        else if (vIdx = 24) then cmotocicle  = :vvalor;
        else if (vIdx = 25) then cstatus     = :vvalor;
        else if (vIdx = 25) then corigem     = :vvalor;
        --
      end
      select count(*) from cad_prod p
      where pro_industria = :cind and p.pro_codigonormalizado = :ccodnorm
      into :v_rows_updated;

      cstatus2 = iif(cstatus = 'T', True, False);

  
      if (v_rows_updated > 0) then
       begin
          update cad_prod set
            pro_industria           = :cind,
            pro_codprod             = :ccodigo,
            pro_codigooriginal      = COALESCE(:ccodori, pro_codigooriginal),
            pro_nome                = COALESCE(:cdescr, pro_nome),
            pro_produtolancamento   = COALESCE(:cehlancto, pro_produtolancamento),
            pro_datalancamento      = COALESCE(:cdatalcto, pro_datalancamento),
            pro_curvaindustria      = COALESCE(:ccurvaabc, pro_curvaindustria),
            pro_codbarras           = COALESCE(:ccdbarras, pro_codbarras),
            pro_grupo               = COALESCE(:cgrupoprod, pro_grupo),
            pro_setor               = COALESCE(:csetor, pro_setor),
            pro_linha               = COALESCE(:clinha, pro_linha),
            pro_embalagem           = COALESCE(:cembal, pro_embalagem),
            pro_peso                = COALESCE(:cpeso, pro_peso),
            pro_conversao           = COALESCE(:cconversao, pro_conversao),
            pro_ncm                 = COALESCE(:cncm, pro_ncm),
            pro_aplicacao           = COALESCE(:caplic, pro_aplicacao),
            pro_aplicacao2          = COALESCE(:caplic2, pro_aplicacao2),
            pro_linhaleve           = COALESCE(:cleve, pro_linhaleve),
            pro_linhapesada         = COALESCE(:cpesada, pro_linhapesada),
            pro_linhaagricola       = COALESCE(:cagricola, pro_linhaagricola),
            pro_linhautilitarios    = COALESCE(:cutilitario, pro_linhautilitarios),
            pro_offroad             = COALESCE(:coffroad, pro_offroad),
            pro_motocicletas        = COALESCE(:cmotocicle, pro_offroad),
            pro_status              = COALESCE(:cstatus2, pro_status),
            pro_origem              = COALESCE(:corigem, pro_origem)
          where
            pro_industria = :cind and
            pro_codigonormalizado = :ccodnorm;
       end
       else
       begin
          if (v_rows_updated = 0) then  --se nao atualizou nada acima, eh? porque o codigo nao existe
           begin
           insert into cad_prod
           (pro_industria, pro_codprod, pro_codigooriginal, pro_codigonormalizado, pro_nome,
            pro_produtolancamento, pro_datalancamento, pro_curvaindustria, pro_codbarras,
            pro_grupo, pro_setor, pro_linha, pro_embalagem, pro_peso, pro_conversao, pro_ncm,
            pro_aplicacao, pro_aplicacao2, pro_linhaleve, pro_linhapesada, pro_linhaagricola,
            pro_linhautilitarios, pro_offroad, pro_motocicletas, pro_status, pro_origem)
           values
           (:cind, :ccodigo, :ccodori, :ccodnorm, :cdescr,
            :cehlancto, :cdatalcto, :ccurvaabc, :ccdbarras,
            :cgrupoprod, :csetor, :clinha, :cembal, :cpeso, :cconversao, :cncm,
            :caplic, :caplic2, :cleve, :cpesada, :cagricola,
            :cutilitario, :coffroad, :cmotocicle, :cstatus2, :corigem);
           end
       end
    end
  end
end^


ALTER PROCEDURE SP_RECEBETABELA (
    PDADOS BLOB SUB_TYPE TEXT SEGMENT SIZE 80,
    P_ROTINA CHAR(1))
AS
declare variable VIDX integer;
declare variable VPARTE varchar(30000);
declare variable VLINHA varchar(500);
declare variable VVALOR varchar(300);
declare variable CIND varchar(3);
declare variable CDESCONTO varchar(3);
declare variable CGRUPOPROD varchar(3);
declare variable CTABELA varchar(20);
declare variable CDATATAB varchar(10);
declare variable CVENCPROMO varchar(10);
declare variable CSTATUS varchar(50);
declare variable CCODIGO varchar(25);
declare variable CDESCR varchar(100);
declare variable CPRECO1 double precision;
declare variable CPRECO2 double precision;
declare variable CPRECO3 double precision;
declare variable CDBARRAS varchar(13);
declare variable CPESO varchar(10);
declare variable CAPLIC varchar(800);
declare variable CEMBAL varchar(10);
declare variable CST varchar(10);
declare variable CIPI double precision;
declare variable CCODORI varchar(40);
declare variable CPREPESO varchar(25);
declare variable CCONVERSAO varchar(300);
declare variable CDESCESPEC double precision;
declare variable CNCM varchar(10);
declare variable CDESCADD double precision;
declare variable CCODIGO2 varchar(25);
declare variable CCURVAABC char(1);
declare variable VDESC varchar(100);
declare variable VPRECO1 double precision;
declare variable VPRECO2 double precision;
declare variable VPRECO3 double precision;
declare variable VCDBARRAS varchar(13);
declare variable VPESO varchar(10);
declare variable VAPLIC varchar(800);
declare variable VEMBAL varchar(10);
declare variable VST varchar(10);
declare variable VIPI double precision;
declare variable VCODORI varchar(40);
declare variable VPREPESO double precision;
declare variable VCONVERSAO varchar(300);
declare variable VDESCESPEC double precision;
declare variable VNCM varchar(10);
declare variable VDESCADD double precision;
declare variable VSTATUS varchar(50);
declare variable VGRUPODESC integer;
declare variable VGRUPOPROD integer;
declare variable VPERCOMGRUPO varchar(10);
declare variable VLEVE boolean;
declare variable VPESADA boolean;
declare variable VAGRICOLA boolean;
declare variable VUTILITARIO boolean;
begin
  for
    select bp.parte
    from sp_blobempartes(:pDados,'|') bp
    into vParte
  do
  begin
    for
      select ss.texto
      from sp_splitstring(:vParte,'|') ss
      into vLinha
    do
    begin
      for
        select ss.idx, trim(nullif(ss.texto, ''))
        from sp_splitstring(:vLinha, ';') ss
        into vIdx, vValor
      do
      begin
        if (vIdx = 1)       then cind       = vValor;
        else if (vIdx = 2)  then ctabela    = trim(vValor);
        else if (vIdx = 3)  then ccodigo2   = trim(vValor);
        else if (vIdx = 4)  then ccodigo    = trim(vValor);
        else if (vIdx = 5)  then vpercomgrupo  = vValor;

        else if (vIdx = 6)  then cdesconto  = iif(vvalor = '0', :vgrupodesc, vvalor);
        else if (vIdx = 7)  then cgrupoprod = iif(vvalor = '000', :vgrupoprod, vvalor);
        else if (vIdx = 8)  then cdatatab   = replace(vValor,'/','.');
        else if (vIdx = 9)  then cvencpromo = replace(vValor,'/','.');
        else if (vIdx = 10) then cstatus    = iif(char_length(coalesce(vvalor, '')) < 2, :vstatus, vvalor); --familia de produtos
        else if (vIdx = 11) then cdescr     = iif(char_length(coalesce(vvalor, '')) < 2, :vdesc, vvalor);
        else if (vIdx = 12) then cpreco1    = iif(cast(vvalor as numeric(10,2)) = 0, :vpreco1, vvalor);
        else if (vIdx = 13) then cpreco2    = iif(cast(vvalor as numeric(10,2)) = 0, :vpreco2, vvalor);
        else if (vIdx = 14) then cpreco3    = iif(cast(vvalor as numeric(10,2)) = 0, :vpreco3, vvalor);
        else if (vIdx = 15) then cdbarras   = iif(char_length(coalesce(vvalor, '')) < 2, :vcdbarras, vvalor);
        else if (vIdx = 16) then cpeso      = iif(char_length(coalesce(vvalor, '')) < 1, :vpeso, vvalor);
        else if (vIdx = 17) then caplic     = iif(char_length(coalesce(vvalor, '')) < 2, :vaplic, vvalor);
        else if (vIdx = 18) then cembal     = iif(cast(vvalor as integer) = 0, :vembal, vvalor);
        else if (vIdx = 19) then cst        = iif(cast(vvalor as numeric(10,2)) < 1, :vst, vvalor);
        else if (vIdx = 20) then cipi       = iif(cast(vvalor as numeric(10,2)) = 0, :vipi, vvalor);
        else if (vIdx = 21) then ccodori    = iif(char_length(coalesce(vvalor, '')) < 2, :vcodori, vvalor);
        else if (vIdx = 22) then cprepeso   = iif(cast(vvalor as numeric(10,2)) < 1, :vprepeso, vvalor);
        else if (vIdx = 23) then cconversao = iif(char_length(coalesce(vvalor, '')) < 2, :vconversao, vvalor);
        else if (vIdx = 24) then cdescespec = iif(cast(vvalor as numeric(10,2)) < 1, :vdescespec, vvalor);
        else if (vIdx = 25) then cncm       = iif(char_length(coalesce(vvalor, '')) < 2, :vncm, vvalor);
        else if (vIdx = 26) then cdescadd   = iif(cast(vvalor as numeric(10,2)) < 1, :vdescadd, vvalor);
        else if (vIdx = 27) then vleve      = iif(vvalor =  'S', true, false);
        else if (vIdx = 28) then vpesada    = iif(vvalor =  'S', true, false);
        else if (vIdx = 29) then vagricola  = iif(vvalor =  'S', true, false);
        else if (vIdx = 30) then vutilitario = iif(vvalor =  'S', true, false);
        else if (vIdx = 31) then ccurvaabc   = trim(vValor);
        --
        if (vIdx = 5 and p_rotina = 'U') then -- update em lista ja cadastrada
         begin
           select first 1 p.pro_nome, p.pro_linha, p.pro_valornormal, p.pro_valorpromo, p.pro_preco3, p.pro_codbarras, p.ite_peso,
                  p.pro_aplicacao2, p.pro_embalagem, p.pro_st, p.pro_ipi, p.pro_codoriginal, p.ite_prepeso,
                  p.ite_conversao, p.pro_descadic2, p.pro_ncm, p.pro_descadic, p.pro_grupo, p.pro_grupopro,
                  p.pro_qtdped, p.pro_linhaleve, p.pro_linhapesada, p.pro_linhaagricola, p.pro_linhautilitarios
           from produtos p
           where p.pro_industria = :cind and p.ite_codigo2 = :ccodigo2 and p.pro_nometabela = :ctabela
           into
           :vdesc, :vstatus, :vpreco1, :vpreco2, :vpreco3, :vcdbarras, :vpeso, :vaplic,
           :vembal, :vst,  :vipi, :vcodori, :vprepeso, :vconversao, :vdescespec, :vncm, :vdescadd,
           :vgrupodesc, :vgrupoprod, :vpercomgrupo, vleve, vpesada, vagricola, vutilitario;

           cstatus = iif(char_length(coalesce(cstatus, '')) < 2, :vstatus, cstatus);
         end
      end
  
      update or insert into produtos
      (pro_industria, pro_grupo, pro_grupopro, pro_nometabela, pro_datatabela, pro_vencpromocao, pro_linha,
       pro_codprod, pro_nome, pro_valornormal, pro_valorpromo, pro_preco3, pro_codbarras, ite_peso, pro_aplicacao2,
       pro_embalagem, pro_st, pro_ipi, pro_codoriginal, ite_prepeso, ite_conversao, pro_descadic2,
       pro_ncm, pro_descadic, ite_codigo2, pro_qtdped, pro_linhaleve, pro_linhapesada, pro_linhaagricola, pro_linhautilitarios,
       pro_status)
      values
      (:cind, :cdesconto, :cgrupoprod, :ctabela, :cdatatab, :cvencpromo, :cstatus,
       :ccodigo,:cdescr, :cpreco1, :cpreco2, :cpreco3, :cdbarras, :cpeso, :caplic,
       :cembal, :cst,  :cipi, :ccodori, :cprepeso, :cconversao, :cdescespec, :cncm,
       :cdescadd, :ccodigo2, :vpercomgrupo, :vleve, :vpesada, :vagricola, :vutilitario,
       :ccurvaabc)
       matching (pro_industria,pro_codprod,pro_nometabela);
    end
  end
end^


ALTER PROCEDURE SP_REL_CLIENTES_YTD (
    MES_REFERENCIA INTEGER,
    ANO_REFERENCIA INTEGER,
    IFOR INTEGER,
    IREDE BOOLEAN)
RETURNS (
    CLIENTE VARCHAR(30),
    VALOR_ANT DOUBLE PRECISION,
    QTD_ANT DOUBLE PRECISION,
    VALOR_ATU DOUBLE PRECISION,
    QTD_ATU DOUBLE PRECISION,
    PERC_VAL DOUBLE PRECISION,
    PERC_QTD DOUBLE PRECISION)
AS
declare variable START_CURR date;
declare variable END_CURR date;
declare variable START_PREV date;
declare variable END_PREV date;
begin
  /* validacao: industria obrigatoria */
  if (:ifor is null) then
    exception ex_invalid_input 'parametro iFor (industria) obrigatorio';

  /* periodo corrente: 1o. de janeiro do ano informado ate o ultimo dia do mes informado */
  start_curr = cast(cast(:ano_referencia as varchar(4)) || '-01-01' as date);

   end_curr =
    dateadd(day, -1,
        dateadd(month, 1,
            cast( :ano_referencia || '-' || lpad(:mes_referencia, 2, '0') || '-01' as date )
        )
    );
  /* mesmo pereodo no ano anterior */
  start_prev = dateadd(year, -1, start_curr);
  end_prev   = dateadd(year, -1, end_curr);

  /* consulta principal: clientes + agregados dos periodos (acumulados) */
  if (irede = false) then
   begin
      for
        select
          c.cli_nomred,
          coalesce(drv.valor_mes_anterior, 0)      as valor_prev,
          coalesce(drv.quantidade_mes_anterior, 0) as qtd_prev,
          coalesce(drv.valor_mes_atual, 0)         as valor_curr,
          coalesce(drv.quantidade_mes_atual, 0)    as qtd_curr
        from clientes c
        left join (
                  select
                    p.ped_cliente,
                    /* acumulado do mesmo periodo no ano anterior (01/01..fim do mes no ano-1) */
                    sum(iif(p.ped_data between :start_prev and :end_prev
                            and p.ped_situacao in ('P','F'), i.ite_totliquido, 0)) as valor_mes_anterior,
                    sum(iif(p.ped_data between :start_prev and :end_prev
                            and p.ped_situacao in ('P','F'), i.ite_quant, 0)) as quantidade_mes_anterior,
                    /* acumulado do periodo corrente (01/01..fim do mes informado) */
                    sum(iif(p.ped_data between :start_curr and :end_curr
                            and p.ped_situacao in ('P','F'), i.ite_totliquido, 0)) as valor_mes_atual,
                    sum(iif(p.ped_data between :start_curr and :end_curr
                            and p.ped_situacao in ('P','F'), i.ite_quant, 0)) as quantidade_mes_atual
                  from pedidos p
                  join itens_ped i on i.ite_pedido = p.ped_pedido
                  where p.ped_industria = :ifor
                    /* limitar leitura ao intervalo necessario (ano-1 ate ano corrente) para performance */
                    and ( (p.ped_data between :start_prev and :end_curr) or p.ped_data is null )
                  group by p.ped_cliente
                 ) drv on c.cli_codigo = drv.ped_cliente
        where coalesce(drv.valor_mes_atual,0) > 0 or coalesce(drv.valor_mes_anterior,0) > 0
        order by coalesce(drv.valor_mes_atual,0) desc
        into :cliente, :valor_ant, :qtd_ant, :valor_atu, :qtd_atu
      do
      begin
        /* calculo % valor com protecao contra divisao por zero */
        if (:valor_ant = 0) then
        begin
          if (:valor_atu > 0) then
            perc_val = 100;
          else
            perc_val = 0;
        end
        else
          perc_val = round((( :valor_atu - :valor_ant ) / :valor_ant) * 100, 2);
    
        /* calculo % quantidade com protecao contra divisao por zero */
        if (:qtd_ant = 0) then
        begin
          if (:qtd_atu > 0) then
            perc_qtd = 100;
          else
            perc_qtd = 0;
        end
        else
          perc_qtd = round((( :qtd_atu - :qtd_ant ) / :qtd_ant) * 100, 2);
    
        suspend; -- retorna a linha
      end
   end -- do igrupo
  if (irede = true) then
   begin
      for
        select distinct
          iif(character_length(c.cli_redeloja) > 0, c.cli_redeloja, 'Demais clientes ') cli_redeloja,
          coalesce(drv.valor_mes_anterior, 0)      as valor_prev,
          coalesce(drv.quantidade_mes_anterior, 0) as qtd_prev,
          coalesce(drv.valor_mes_atual, 0)         as valor_curr,
          coalesce(drv.quantidade_mes_atual, 0)    as qtd_curr
        from clientes c
        left join (
                  select
                    iif(character_length(c1.cli_redeloja) > 0, c1.cli_redeloja, 'Demais clientes ') cli_redeloja,
                    sum(iif(p.ped_data between :start_prev and :end_prev
                            and p.ped_situacao in ('P','F'), i.ite_totliquido, 0)) as valor_mes_anterior,
                    sum(iif(p.ped_data between :start_prev and :end_prev
                            and p.ped_situacao in ('P','F'), i.ite_quant, 0)) as quantidade_mes_anterior,
                    sum(iif(p.ped_data between :start_curr and :end_curr
                            and p.ped_situacao in ('P','F'), i.ite_totliquido, 0)) as valor_mes_atual,
                    sum(iif(p.ped_data between :start_curr and :end_curr
                            and p.ped_situacao in ('P','F'), i.ite_quant, 0)) as quantidade_mes_atual
                  from pedidos p
                  join itens_ped i on i.ite_pedido = p.ped_pedido
                  join clientes c1 on p.ped_cliente = c1.cli_codigo
                  where p.ped_industria = :ifor and
                        ( (p.ped_data between :start_prev and :end_curr) or p.ped_data is null )
                  group by 1
                 ) drv on iif(character_length(c.cli_redeloja) > 0, c.cli_redeloja, 'Demais clientes ') = drv.cli_redeloja
        where coalesce(drv.valor_mes_atual,0) > 0 or coalesce(drv.valor_mes_anterior,0) > 0
        order by coalesce(drv.valor_mes_atual,0) desc
        into :cliente, :valor_ant, :qtd_ant, :valor_atu, :qtd_atu
      do
      begin
        /* calculo % valor com protecao contra divisao por zero */
        if (:valor_ant = 0) then
        begin
          if (:valor_atu > 0) then
            perc_val = 100;
          else
            perc_val = 0;
        end
        else
          perc_val = round((( :valor_atu - :valor_ant ) / :valor_ant) * 100, 2);
    
        /* calculo % quantidade com protecao contra divisao por zero */
        if (:qtd_ant = 0) then
        begin
          if (:qtd_atu > 0) then
            perc_qtd = 100;
          else
            perc_qtd = 0;
        end
        else
          perc_qtd = round((( :qtd_atu - :qtd_ant ) / :qtd_ant) * 100, 2);
    
        suspend; -- retorna a linha
      end
   end -- do igrupo
end^


ALTER PROCEDURE SP_RELCRMPORIND (
    XDATA1 DATE,
    XDATA2 DATE,
    XIND1 INTEGER)
RETURNS (
    AGE_LANCTO INTEGER,
    AGE_DATA DATE,
    AGE_CLIENTE INTEGER,
    AGE_HORARIO VARCHAR(5),
    AGE_STATUS VARCHAR(1),
    AGE_OBS VARCHAR(1800),
    AGE_INDUSTRIA INTEGER,
    AGE_TELEFONE VARCHAR(35),
    AGE_CONTATO VARCHAR(35),
    AGE_OPERADOR VARCHAR(35),
    FOR_NOMERED VARCHAR(15),
    CLI_NOMRED VARCHAR(30),
    CLI_CIDADE VARCHAR(25),
    CLI_CNPJ VARCHAR(18),
    CLI_FONE1 VARCHAR(20),
    METACOMPLETADA DOUBLE PRECISION,
    LIGACOES INTEGER,
    METAIND INTEGER)
AS
declare variable XIND2 integer;
declare variable XMETA integer;
declare variable XMESANO varchar(10);
begin
  /* busca o ultimo dia do mes informado no xdata2 */
  select dateadd(-extract(day from dateadd(1 month to :xdata2 )) day to dateadd(1 month to :xdata2)) ultimo_dia
  from rdb$database
  into :xmesano;

  ligacoes = 1;
  xind2 = xind1;
  xmeta = 1;
  if (xind1 = 0) then
   begin
    xind1 = 1;
    xind2 = 9999;
   end

  select count(distinct p.ped_cliente) as total_clientes
  from pedidos p
  where p.ped_industria = :xind1
  into :xmeta;

  for
    select age_lancto, age_data, age_cliente, age_horario, age_status, age_assunto,  age_industria,
    age_telefone, age_contato, age_operador, f.for_nomered, c.cli_nomred, c.cli_cidade, c.cli_cnpj, 
    c.cli_fone1
    from crm_interacoes a
    join fornecedores f on a.age_industria = f.for_codigo
    join clientes     c on a.age_cliente   = c.cli_codigo
    where age_industria between :xInd1 and :xInd2 and
          age_data between :xdata1 and :xdata2
    order by age_industria, age_data, age_horario
    into :age_lancto, :age_data, :age_cliente, :age_horario, :age_status, :age_obs,  :age_industria,
         :age_telefone, :age_contato, :age_operador, :for_nomered, :cli_nomred, :cli_cidade, :cli_cnpj,
         :cli_fone1
  do
  begin
   ligacoes       = ligacoes + 1;
   metacompletada = (ligacoes * 100) / xmeta;
   metaind        = :xmeta;
  suspend;
  end



end^


ALTER PROCEDURE SP_SAMEPERIOD_3YARS (
    IANO INTEGER)
RETURNS (
    OANO INTEGER,
    OMES VARCHAR(10),
    OQTD INTEGER)
AS
declare variable VDATA date;
begin
 vData = extract(day from current_date)||'.'||extract(month from current_date)||'.'||:iano;
 for
    select  first 3 distinct
    extract(year from p.ped_data),
    decode(extract(month from p.ped_data),
          '1', 'Janeiro',
          '2', 'Fevereiro',
          '3', 'Marco',
          '4', 'Abril',
          '5', 'Maio',
          '6', 'Junho',
          '7', 'Julho',
          '8', 'Agosto',
          '9', 'Setembro',
          '10', 'Outubro',
          '11', 'Novembro',
          '12', 'Dezembro'),
    cast(sum(i.ite_quant) over(partition by extract(month from p.ped_data)) as integer)
    from itens_ped i
    join pedidos p on i.ite_pedido = p.ped_pedido
    where p.ped_data >= dateadd(-2 month to :vdata) and
          p.ped_situacao in ('P','F') and
          extract(year from p.ped_data) = :iano
    order by 1
    into :oano, :omes, :oqtd
  do
  suspend;
end^


ALTER PROCEDURE SP_SAMEPERIOD_QTD (
    IANO INTEGER)
RETURNS (
    OANO INTEGER,
    OMES VARCHAR(10),
    OVALOR INTEGER)
AS
declare variable VDATA date;
begin
 vData = extract(day from current_date)||'.'||extract(month from current_date)||'.'||:iano;
 for
    select distinct
    extract(year from p.ped_data),
    decode(extract(month from p.ped_data),
          '1', 'Janeiro',
          '2', 'Fevereiro',
          '3', 'Marco',
          '4', 'Abril',
          '5', 'Maio',
          '6', 'Junho',
          '7', 'Julho',
          '8', 'Agosto',
          '9', 'Setembro',
          '10', 'Outubro',
          '11', 'Novembro',
          '12', 'Dezembro'),
    cast(sum(i.ite_quant) over(partition by extract(month from p.ped_data)) as integer)
    from itens_ped i
    join pedidos p on i.ite_pedido = p.ped_pedido
    where p.ped_situacao in ('P','F') and
          extract(year from p.ped_data) = :iano
    order by 1
    into :oano, :omes, :ovalor
  do
  suspend;
end^


ALTER PROCEDURE SP_SAMEPERIOD_VALANO (
    IANO INTEGER)
RETURNS (
    OANO INTEGER,
    OMES VARCHAR(10),
    OVALOR DOUBLE PRECISION)
AS
declare variable VDATA date;
begin
 vData = extract(day from current_date)||'.'||extract(month from current_date)||'.'||:iano;
 for
    select distinct
    extract(year from p.ped_data),
    decode(extract(month from p.ped_data),
          '1', 'Janeiro',
          '2', 'Fevereiro',
          '3', 'Marco',
          '4', 'Abril',
          '5', 'Maio',
          '6', 'Junho',
          '7', 'Julho',
          '8', 'Agosto',
          '9', 'Setembro',
          '10', 'Outubro',
          '11', 'Novembro',
          '12', 'Dezembro'),
    cast(sum(i.ite_totliquido) over(partition by extract(month from p.ped_data)) as NUMERIC(10,2))
    from itens_ped i
    join pedidos p on i.ite_pedido = p.ped_pedido
    where p.ped_situacao in ('P','F') and
          extract(year from p.ped_data) = :iano
    order by 1
    into :oano, :omes, :ovalor
  do
  suspend;
end^


ALTER PROCEDURE SP_SAMEPERIOD_VALOR (
    IANO INTEGER)
RETURNS (
    OANO INTEGER,
    OMES VARCHAR(10),
    OVALOR DOUBLE PRECISION)
AS
declare variable VDATA date;
begin
 vData = extract(day from current_date)||'.'||extract(month from current_date)||'.'||:iano;
 for
    select  first 3 distinct
    extract(year from p.ped_data),
    decode(extract(month from p.ped_data),
          '1', 'Janeiro',
          '2', 'Fevereiro',
          '3', 'Marco',
          '4', 'Abril',
          '5', 'Maio',
          '6', 'Junho',
          '7', 'Julho',
          '8', 'Agosto',
          '9', 'Setembro',
          '10', 'Outubro',
          '11', 'Novembro',
          '12', 'Dezembro'),
    cast(sum(i.ite_totliquido) over(partition by extract(month from p.ped_data)) as numeric(10,2))
    from itens_ped i
    join pedidos p on i.ite_pedido = p.ped_pedido
    where p.ped_data >= dateadd(-2 month to :vdata) and
          p.ped_situacao in ('P','F') and
          extract(year from p.ped_data) = :iano
    order by 1
    into :oano, :omes, :ovalor
  do
  suspend;
end^


ALTER PROCEDURE SP_SPLIT_RECEBER (
    PTEXTO VARCHAR(32000),
    PDELIMITADOR CHAR(1))
RETURNS (
    IDX INTEGER,
    LINHA VARCHAR(2000))
AS
begin
  idx = 0;

  while (position(pDelimitador, pTexto) > 0) do
  begin
    idx = idx + 1;
    linha = left(pTexto, position(pDelimitador, pTexto) - 1);
    pTexto = substring(pTexto from position(pDelimitador, pTexto) + 1);
    suspend;
  end
end^


ALTER PROCEDURE SP_SPLITSTRING (
    PTEXTO VARCHAR(30000),
    PDELIMITADOR CHAR(1))
RETURNS (
    IDX INTEGER,
    TEXTO VARCHAR(500))
AS
declare variable VPOS bigint;
begin
  vPos = position(pDelimitador,pTexto);
  idx = 0;

  while (vPos > 0) do
  begin
    idx = idx + 1;
    texto = left(pTexto,vPos - 1);
    pTexto = substring(pTexto from vPos + 1);
    suspend;
    vPos = position(pDelimitador,pTexto);
  end
end^


ALTER PROCEDURE SP_STATUSTRIGGERS (
    ISTATUS INTEGER)
AS
declare variable VTABELA varchar(50);
declare variable VSQL varchar(200);
begin
 for
  select trim(rdb$field_name)
  from rdb$relation_fields
  into :vtabela
  do
   begin
     for
     select x.rdb$trigger_name
     from rdb$triggers x
     where rdb$trigger_source is not null and
          (coalesce(rdb$system_flag,0) = 0) and
           rdb$trigger_source not starting with 'check'
     into :vtabela
     do
      begin
        vtabela=trim(vtabela);
        if (istatus = 1) then
        vsql= 'alter trigger ' || :vtabela || ' inactive;';
        else
        vsql= 'alter trigger ' || :vtabela || ' active;';
    
        execute statement vsql;
      end
   end
end^


ALTER PROCEDURE SP_TEMP (
    ITABELA VARCHAR(30))
RETURNS (
    VCAMPOS VARCHAR(800))
AS
declare variable VTEMP blob sub_type 0 segment size 800;
declare variable VTEMP2 varchar(500);
declare variable VCONT integer = 1;
declare variable VFOR integer;
declare variable VSQL varchar(1000);
declare variable VTESTE varchar(1000);
declare variable ID integer;
declare variable DESCR varchar(60);
declare variable SEL char(1);
declare variable GID varchar(38);
declare variable CQ char(1);
begin
  select list(trim(rdb$field_name))
  from rdb$relation_fields
  where rdb$relation_name = upper(:itabela)
  into :vtemp;

  cQ = ascii_char(39);

  vsql =  'select * from '||:itabela;
  for
   execute statement (vsql)
   into :id, :descr, :sel, :gid
  do
  suspend;
end^


ALTER PROCEDURE SP_TOP10_FOR (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    OIDCLI INTEGER,
    ONOME VARCHAR(15),
    OVALOR DOUBLE PRECISION,
    OCOR VARCHAR(12))
AS
declare variable VSEQ integer;
declare variable VIDFOR integer;
declare variable VNOME varchar(30);
declare variable VVALOR double precision;
begin
 delete from tab_temp where tmp_id > 0;
 vseq = 0;

 if (imes = 0) then
  begin
     for
        select first 10
               f.for_codigo,
               f.for_nomered,
               sum(i.ite_quant * i.ite_puniliq)
        from fornecedores f
        join pedidos p on p.ped_industria = f.for_codigo
        join itens_ped i on i.ite_pedido = p.ped_pedido
        where extract(year from p.ped_data) = :iano and
              p.ped_situacao in ('P', 'F') and
              f.for_tipo2 = 'A'
        group by f.for_codigo, f.for_nomered
        order by 3 desc
        into :vidfor, :vnome, :vvalor
      do
      begin
       vseq = vseq + 1;
       insert into tab_temp (tmp_id, tmp_industria, tmp_valor, tmp_descricao)
       values (:vseq, :vidfor, :vvalor, :vnome);
      end
    
      for
       select t.tmp_industria, t.tmp_valor, r.cor, t.tmp_descricao
       from tab_temp t
       join rgbcores r on t.tmp_id = r.id
       order by 2 desc
       into :oidcli, :ovalor, :ocor, :onome
       do
       suspend;
  end
  else
  begin
     for
        select first 10
               f.for_codigo,
               f.for_nomered,
               sum(i.ite_quant * i.ite_puniliq)
        from fornecedores f
        join pedidos p on p.ped_industria = f.for_codigo
        join itens_ped i on i.ite_pedido = p.ped_pedido
        where extract(year from p.ped_data) = :iano and
              extract(month from p.ped_data) = :imes and
              p.ped_situacao in ('P', 'F') and
              f.for_tipo2 = 'A'
        group by f.for_codigo, f.for_nomered
        order by 3 desc
        into :vidfor, :vnome, :vvalor
      do
      begin
       vseq = vseq + 1;
       insert into tab_temp (tmp_id, tmp_industria, tmp_valor, tmp_descricao)
       values (:vseq, :vidfor, :vvalor, :vnome);
      end
    
      for
       select t.tmp_industria, t.tmp_valor, r.cor, t.tmp_descricao
       from tab_temp t
       join rgbcores r on t.tmp_id = r.id
       order by 2 desc
       into :oidcli, :ovalor, :ocor, :onome
       do
       suspend;
  end
end^


ALTER PROCEDURE SP_TOP10_FOR_QTD (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    OIDCLI INTEGER,
    ONOME VARCHAR(15),
    OVALOR DOUBLE PRECISION,
    OCOR VARCHAR(12))
AS
declare variable VSEQ integer;
declare variable VIDFOR integer;
declare variable VNOME varchar(30);
declare variable VVALOR double precision;
begin
 delete from tab_temp where tmp_id > 0;
 vseq = 0;

 if (imes = 0) then
  begin
     for
        select first 10
               f.for_codigo,
               f.for_nomered,
               sum(i.ite_quant)
        from fornecedores f
        join pedidos p on p.ped_industria = f.for_codigo
        join itens_ped i on i.ite_pedido = p.ped_pedido
        where extract(year from p.ped_data) = :iano and
              p.ped_situacao in ('P', 'F') and
              f.for_tipo2 = 'A'
        group by f.for_codigo, f.for_nomered
        order by 3 desc
        into :vidfor, :vnome, :vvalor
      do
      begin
       vseq = vseq + 1;
       insert into tab_temp (tmp_id, tmp_industria, tmp_valor, tmp_descricao)
       values (:vseq, :vidfor, :vvalor, :vnome);
      end
    
      for
       select t.tmp_industria, t.tmp_valor, r.cor, t.tmp_descricao
       from tab_temp t
       join rgbcores r on t.tmp_id = r.id
       order by 2 desc
       into :oidcli, :ovalor, :ocor, :onome
       do
       suspend;
  end
  else
  begin
     for
        select first 10
               f.for_codigo,
               f.for_nomered,
               sum(i.ite_quant)
        from fornecedores f
        join pedidos p on p.ped_industria = f.for_codigo
        join itens_ped i on i.ite_pedido = p.ped_pedido
        where extract(year from p.ped_data) = :iano and
              extract(month from p.ped_data) = :imes and
              p.ped_situacao in ('P', 'F') and
              f.for_tipo2 = 'A'
        group by f.for_codigo, f.for_nomered
        order by 3 desc
        into :vidfor, :vnome, :vvalor
      do
      begin
       vseq = vseq + 1;
       insert into tab_temp (tmp_id, tmp_industria, tmp_valor, tmp_descricao)
       values (:vseq, :vidfor, :vvalor, :vnome);
      end
    
      for
       select t.tmp_industria, t.tmp_valor, r.cor, t.tmp_descricao
       from tab_temp t
       join rgbcores r on t.tmp_id = r.id
       order by 2 desc
       into :oidcli, :ovalor, :ocor, :onome
       do
       suspend;
  end
end^


ALTER PROCEDURE SP_TOP10_QTD (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    OIDCLI INTEGER,
    ONOME VARCHAR(30),
    OVALOR DOUBLE PRECISION,
    OCOR VARCHAR(12))
AS
declare variable VSEQ integer;
declare variable VIDCLI integer;
declare variable VNOME varchar(30);
declare variable VVALOR double precision;
begin
 delete from tab_temp where tmp_id > 0;
 vseq = 0;
 if (imes = 0) then
  begin
     for
       select first 10
              c.cli_codigo,
              c.cli_nomred,
              sum(i.ite_quant)
       from clientes c
       join pedidos p on p.ped_cliente = c.cli_codigo
       join itens_ped i on i.ite_pedido = p.ped_pedido
       where extract(year from p.ped_data) = :iano and
             p.ped_situacao in ('P', 'F') and
             c.cli_tipopes = 'A'
       group by c.cli_codigo, c.cli_nomred
       order by 3 desc
       into :vidcli, :vnome, :vvalor
      do
      begin
       vseq = vseq + 1;
       insert into tab_temp (tmp_id, tmp_cliente, tmp_valor, tmp_descricao)
       values (:vseq, :vidcli, :vvalor, :vnome);
      end
  end
  else
  begin
     for
       select first 10
              c.cli_codigo,
              c.cli_nomred,
              sum(i.ite_quant)
       from clientes c
       join pedidos p on p.ped_cliente = c.cli_codigo
       join itens_ped i on i.ite_pedido = p.ped_pedido
       where extract(year from p.ped_data) = :iano and
             extract(month from p.ped_data) = :imes and
             p.ped_situacao in ('P', 'F') and
             c.cli_tipopes = 'A'
       group by c.cli_codigo, c.cli_nomred
       order by 3 desc
       into :vidcli, :vnome, :vvalor
      do
      begin
       vseq = vseq + 1;
       insert into tab_temp (tmp_id, tmp_cliente, tmp_valor, tmp_descricao)
       values (:vseq, :vidcli, :vvalor, :vnome);
      end
  end

  for
   select t.tmp_cliente, t.tmp_valor, r.cor, t.tmp_descricao
   from tab_temp t
   join rgbcores r on t.tmp_id = r.id
   order by 2 desc
   into :oidcli, :ovalor, :ocor, :onome
   do
   suspend;
end^


ALTER PROCEDURE SP_TOP10_VAL (
    IANO INTEGER,
    IMES INTEGER)
RETURNS (
    OIDCLI INTEGER,
    ONOME VARCHAR(30),
    OVALOR DOUBLE PRECISION,
    OCOR VARCHAR(12))
AS
declare variable VSEQ integer;
declare variable VIDCLI integer;
declare variable VNOME varchar(30);
declare variable VVALOR double precision;
begin
 delete from tab_temp where tmp_id > 0;
 vseq = 0;
 if (imes = 0) then
  begin
     for
       select first 10
              c.cli_codigo,
              c.cli_nomred,
              sum(i.ite_quant * i.ite_puniliq) as valor
       from clientes c
       join pedidos p on p.ped_cliente = c.cli_codigo
       join itens_ped i on i.ite_pedido = p.ped_pedido
       where extract(year from p.ped_data) = :iano and
             p.ped_situacao in ('P', 'F') and
             c.cli_tipopes = 'A'
       group by c.cli_codigo, c.cli_nomred
       order by 3 desc
       into :vidcli, :vnome, :vvalor
      do
      begin
       vseq = vseq + 1;
       insert into tab_temp (tmp_id, tmp_cliente, tmp_valor, tmp_descricao)
       values (:vseq, :vidcli, :vvalor, :vnome);
      end
  end
  else
  begin
     for
       select first 10
              c.cli_codigo,
              c.cli_nomred,
              sum(i.ite_quant * i.ite_puniliq) as valor
       from clientes c
       join pedidos p on p.ped_cliente = c.cli_codigo
       join itens_ped i on i.ite_pedido = p.ped_pedido
       where extract(year from p.ped_data) = :iano and
             extract(month from p.ped_data) = :imes and
             p.ped_situacao in ('P', 'F') and
             c.cli_tipopes = 'A'
       group by c.cli_codigo, c.cli_nomred
       order by 3 desc
       into :vidcli, :vnome, :vvalor
      do
      begin
       vseq = vseq + 1;
       insert into tab_temp (tmp_id, tmp_cliente, tmp_valor, tmp_descricao)
       values (:vseq, :vidcli, :vvalor, :vnome);
      end
  end
  for
   select t.tmp_cliente, t.tmp_valor, r.cor, t.tmp_descricao
   from tab_temp t
   join rgbcores r on t.tmp_id = r.id
   order by 2 desc
   into :oidcli, :ovalor, :ocor, :onome
   do
   suspend;
end^


ALTER PROCEDURE SP_TOTALIZA_CONTAS (
    PDATAINI DATE,
    PDATAFIM DATE)
RETURNS (
    ID INTEGER,
    ID_PAI INTEGER,
    GRAU VARCHAR(8),
    DESCRICAO VARCHAR(50),
    TOTAL NUMERIC(15,2))
AS
begin
  --Inicializa o total do PC
  update contas set con_saldo = null
  where con_codigo > 0;

  for
    --Buscar valores da tabela contas a pagar/receber
    select
      p.con_codigo,
      p.con_idpai,
      sum(c.lan_valorpago) total
    from contaspgrec c
    join contas p on p.con_codigo = c.lan_conta
    where c.lan_datapago between :pdataini and :pdatafim and
          c.lan_valorpago > 0
    group by 1,2
    into id, id_pai, total
  do
  begin
    --Atualiza garu maior
    update contas p
      set p.con_saldo = :total
      where p.con_codigo = :id;

    --Atualiza o pai, avo, e assim por diante
    while (:id_pai is not null) do
    begin
      update contas p
        set p.con_saldo = coalesce(p.con_saldo,0) + :total
      where p.con_codigo = :id_pai
      returning con_idpai into :id_pai;
    end
  end

  --Lista o plano de contas
  for
    select
      p.con_codigo,
      p.con_idpai,
      p.con_grau,
      p.con_descricao,
      coalesce(p.con_saldo,0)
    from contas p
    order by p.con_grau
    into id, id_pai, grau, descricao, total
  do
    suspend;

  --Limpa a sujeira
  update contas p set p.con_saldo = null
  where con_codigo > 0;
end^


ALTER PROCEDURE TRANSF_DADOS_CLIENTES (
    VTABELA VARCHAR(20))
RETURNS (
    SQL VARCHAR(32000))
AS
declare variable CQ char(1);
declare variable VINSERT varchar(1000);
declare variable VTAMANHO integer = 0;
declare variable VDADOS varchar(31800) = '';
begin
--  cQ = ascii_char(39);
--  vInsert = 'INSERT INTO PRODUTOS (ID, CODIGO_BARRAS, DESCRICAO, CUSTO, ESTOQUE, ATIVO) VALUES';
--  vInsert = 'insert into clientes (cli_codigo, cli_cnpj, cli_inscricao, cli_tipopes, cli_nome, cli_nomred, cli_fantasia, '+
--            'cli_endereco, cli_endnum, cli_compendereco, cli_bairro, cli_cidade, cli_uf, cli_cep, cli_ptoref, cli_fone1, ' +
--            'cli_fone2, cli_fone3, cli_endcob, cli_baicob, cli_cidcob, cli_cepcob, cli_ufcob, cli_email, cli_emailnfe, '+
--            'cli_skype, cli_refcome, cli_suframa, cli_vencsuf, cli_caixapostal, cli_obs, cli_obspedido, cli_emailfinanc, '+
--            'cli_vendedor, cli_regimeemp, cli_regiao2, cli_atuacao, cli_redeloja, cli_datacad, cli_usuario, cli_dataalt, '+
--            'cli_imp, cli_idcidade, cli_dataabertura, cli_atuacaoprincipal) VALUES';
--
--  for
--    select
--       :vTamanho + char_length(a.dados) tamanho,
--       :vDados || a.dados
--    from (
--      select
--        '('
--        || p.id
--        ||', '||coalesce(:cQ||p.codigo_barras||:cQ,'null')
--        ||', '||coalesce(:cQ||p.descricao||:cQ,'null')
--        ||', '||coalesce(p.custo,'null')
--        ||', '||coalesce(p.estoque,'null')
--        ||', '||coalesce(p.ativo,'null')||');' dados
--      from produtos p) a
--    into vTamanho, vDados
--  do
--  begin
--    if (vTamanho > 29000) then
--    begin
--      sql = 'execute procedure sp_inserir_dados('||cQ||vInsert||cQ||','||cQ||replace(vDados,cQ,cQ||cQ)||cQ||');';
--      execute statement sql on external '200.150.197.152/3050:DPS2' as user 'ADMIN' password '123';
--
--      vTamanho = 0;
--      vDados = '';
--    end
--  end

--  if (vTamanho > 0) then
--  begin
--    sql = 'execute procedure sp_inserir_dados('||cQ||vInsert||cQ||','||cQ||replace(vDados,cQ,cQ||cQ)||cQ||');';
--    execute statement sql on external '200.150.197.152/3050:DPS2' as user 'ADMIN' password '123';
--  end

  cQ = ascii_char(39);
  select list(trim(rdb$field_name))
  from rdb$relation_fields
  where rdb$relation_name = upper(:vTabela)
  into :vInsert;

  vInsert = 'insert into '||trim(:vTabela)||' ('||vInsert||cQ||')';

  sql = vInsert;
  suspend;

end^



SET TERM ; ^



/******************************************************************************/
/****                           Stored functions                           ****/
/******************************************************************************/



SET TERM ^ ;

ALTER FUNCTION FN_NORMALIZAR_CNPJ (
    CODIGO VARCHAR(50))
RETURNS VARCHAR(50)
AS
declare variable RESULTADO varchar(50);
declare variable POS integer;
begin
    -- converte tudo para mai?sculas e remove caracteres especiais
    resultado = upper(codigo);
    resultado = replace(resultado, '-', '');
    resultado = replace(resultado, ' ', '');
    resultado = replace(resultado, '.', '');
    resultado = replace(resultado, '/', '');
    resultado = replace(resultado, '|', '');
    return trim(resultado);
end^


ALTER FUNCTION FN_NORMALIZAR_CODIGO (
    CODIGO VARCHAR(50))
RETURNS VARCHAR(50)
AS
declare variable RESULTADO varchar(50);
declare variable POS integer;
begin
    -- converte tudo para mai?sculas e remove caracteres especiais
    resultado = upper(codigo);
    resultado = replace(resultado, '-', '');
    resultado = replace(resultado, ' ', '');
    resultado = replace(resultado, '.', '');
    resultado = replace(resultado, '/', '');
    resultado = replace(resultado, '|', '');
    resultado = replace(resultado, ',', '');

    -- remover zeros ? esquerda:
    pos = 1;
    while (substring(resultado from pos for 1) = '0') do
    begin
        pos = pos + 1;
    end

    -- se todos forem zeros, retorna '0', sen?o retorna a substring a partir do primeiro caractere diferente de zero
    if (pos > char_length(resultado)) then
        resultado = '0';
    else
        resultado = substring(resultado from pos);

    return trim(resultado);
end^



SET TERM ; ^



/******************************************************************************/
/****                                Roles                                 ****/
/******************************************************************************/

CREATE ROLE RDB$ADMIN;
